theory Chapter_basic
  imports Chapter_intro
begin
chapter "Isabelle Basics"
text_raw\<open>\label{basic}\<close>

text \<open>
Isabelle is a ``proof assistant'' for formal mathematical proofs. It supports a notation for propositions and 
their proofs, it can check whether a proof is correct, and it can even help to find a proof.
\<close>

section "Invoking Isabelle"
text_raw\<open>\label{basic-invoke}\<close>

text \<open>
After installation, Isabelle can be invoked interactively as an editor for entering propositions and proofs,
or it can be invoked noninteractively to check a proof and generate a PDF document which displays the 
propositions and proofs.
\<close>

subsection "Installation and Configuration"
text_raw\<open>\label{basic-invoke-install}\<close>
text \<open>** todo **\<close>

subsection "Theories and Sessions"
text_raw\<open>\label{basic-invoke-theory}\<close>
text \<open>
The propositions and proofs in Isabelle notation are usually collected in ``theory files'' with names of the 
form \<^verbatim>\<open>name.thy\<close>. A theory file must import at least one other theory file to build upon its content. For theories
based on higher order logic (``HOL''), as it is the case for the Cogent shallow embedding, the usual starting point to
import is the theory @{theory Main}.

Several theory files can be grouped in a ``session''. A session is usually stored in a directory in the file system.
It consists of a file named \<^verbatim>\<open>ROOT\<close> which contains a specification of the session, and the theory files which
belong to the session.

When Isabelle loads a session it loads and checks all its theory files. Then it can generate a ``heap file'' for
the session which contains the processed session content. The heap file can be reloaded by Isabelle to avoid 
the time and effort for processing and checking the theory files.

A session always has a single parent session, with the exception of the Isabelle builtin session @{session Pure}.
Thus, every session depends on a linear sequence of ancestor sessions which begins at @{session Pure}. The ancestor 
sessions have separate heap files. A session is always loaded together with all ancestor sessions. 

Every session has a name of the form \<^verbatim>\<open>chap/sess\<close> where \<^verbatim>\<open>chap\<close> is an arbitrary ``chapter name'', it defaults to
\<^verbatim>\<open>Unsorted\<close>. The session name and the name of the parent session are specified in the \<^verbatim>\<open>ROOT\<close> file in the session
directory. When a session is loaded by Isabelle, its directory and the directories of all ancestor sessions must
be known by Isabelle.

Every session may be displayed in a ``session document''. This is a PDF document generated by translating the 
content of the session theory files to \LaTeX. A frame \LaTeX document must be provided which includes all content
generated from the theory files. The path of the frame document, whether a session document shall be generated and 
which theories shall be included is specified in the \<^verbatim>\<open>ROOT\<close> file.

The command
\begin{verbatim}
  isabelle mkroot [OPTIONS] [Directory]
\end{verbatim}
can be used to initialize the given directory (default is the current directory) as session directory. It creates
an initial \<^verbatim>\<open>ROOT\<close> file to be populated with theory files names and other specification for the session, and it
creates a simple frame \LaTeX document.
\<close>

subsection "Invocation as Editor"
text_raw\<open>\label{basic-invoke-edit}\<close>
text \<open>
Isabelle is invoked for editing using the command
\begin{verbatim}
  isabelle jedit [OPTIONS] [Files ...]
\end{verbatim}
It starts an interactive editor and opens the specified theory files. If no file is specified it opens the 
file \<^verbatim>\<open>Scratch.thy\<close> in the user's home directory. If that file does not exist, it is created as an empty file.

The editor also loads (but does not open) all transitively imported theory files. If these are Isabelle standard
theories it finds them automatically. If they belong to the session in the current directory it also finds them.
If they belong to other sessions, the option
\begin{verbatim}
  -d <directory pathname>
\end{verbatim}
must be used to make the session directory known to Isabelle. For every used session a separate option must be
specified. Also the directories of all ancestor sessions of the session the opened files belong to must be
specified using this option if they are not yet known to Isabelle. 

The option
\begin{verbatim}
  -l <session name>
\end{verbatim}
can be used to specify a session to load (together with all ancestor sessions) to use imported theories from it.
If a heap file exists for that session it is used, otherwise a heap file is created by loading all the session's 
theories.
\<close>

subsection "Invocation for Batch Processing"
text_raw\<open>\label{basic-invoke-build}\<close>
text \<open>
Isabelle is invoked for batch processing of all theory files in one or more sessions using the command
\begin{verbatim}
  isabelle build [OPTIONS] [Sessions ...]
\end{verbatim}
It loads all theory files of the specified sessions and checks the contained proofs. It also loads all required
ancestor sessions. If not know to Isabelle, the corresponding session directories must be specified using option
\<^verbatim>\<open>-d\<close> as described in Section~\ref{basic-invoke-edit}. Sessions required for other sessions are loaded from
heap files if existent, otherwise the corresponding theories are loaded and a heap file is created. 

If option \<^verbatim>\<open>-b\<close> is specified, heap files are also created for all sessions specified in the command. Option
\<^verbatim>\<open>-c\<close> clears the specified sessions (removes their heap files) before processing them. Option \<^verbatim>\<open>-n\<close> omits 
the actual session processing, together with option \<^verbatim>\<open>-c\<close> it can be used to simply clear the heap files.

The specified sessions are only processed if at least one of their theory file has changed since the last 
processing or if the session is cleared using option \<^verbatim>\<open>-c\<close>. If option \<^verbatim>\<open>-v\<close> is specified all loaded sessions
and all processed theories are listed on standard output.

If specified for a session in its \<^verbatim>\<open>ROOT\<close> file (see Section~\ref{basic-invoke-doc}), also the session document 
is generated when a session is processed.
\<close>

section "Isabelle Theories"
text_raw\<open>\label{basic-theory}\<close>

subsection "Theory Structure"
text_raw\<open>\label{basic-theory-structure}\<close>

text \<open>
The content of a theory file has the structure
\begin{verbatim}
  theory <name> 
  imports <name1> ... <namen>
  begin
    ...
  end
\end{verbatim}
where \<^verbatim>\<open><name>\<close> is the theory name and \<^verbatim>\<open><name1> ... <namen>\<close> are the names of the imported theories.
The theory name \<^verbatim>\<open><name>\<close> must be the same which is used for the theory file, i.e., the file name 
must be \<^verbatim>\<open><name>.thy\<close>.

The theory structure is a part of the Isabelle ``outer syntax'' which is mainly fixed and independent
from the specific theories. Other kind of syntax is embedded into the outer syntax. The main embedded
syntax ist the ``inner syntax'' which is mainly used to denote types and terms. Content in inner
syntax must always be surrounded by double quotes.

Additionally, text written in \LaTeX syntax can be embedded into the outer syntax using the form
\begin{verbatim}
  text\<open> ... \<close>
\end{verbatim}
and \LaTeX sections can be created using
\begin{verbatim}
  chapter\<open> ... \<close>
  section\<open> ... \<close>
  subsection\<open> ... \<close>
  subsubsection\<open> ... \<close>
  paragraph\<open> ... \<close>
  subparagraph\<open> ... \<close>
\end{verbatim}
Note that the delimiters used here are not the ``lower'' and ``greater'' symbols, but the ``cartouche
delimiters'' available in the jedit Symols subwindow in tab ``Punctuation''.

It is also possible to embed inner syntax In the \LaTeX syntax.
\<close>

subsection "Types and Constants"
text_raw\<open>\label{basic-theory-typcnst}\<close>

text \<open>
As usual in formal logics, the basic building blocks for propositions are terms. Terms denote arbitrary
objects like numbers, sets, functions, or boolean values. Isabelle is strongly typed, so every term 
must have a type. However, in most situations Isabelle can derive the type of a term automatically,
so that it needs not be specified explicitly. Terms and types are always denoted using the inner syntax.

Types are usually specified by type names. There are predefined type names such as \<open>nat\<close> and \<open>bool\<close>.
Types can be parameterized, then the type arguments are denoted \<^emph>\<open>before\<close> the type name, such as in
\<open>nat set\<close> which is the type of sets of natural numbers.

New type names can be declared in the form
\begin{verbatim}
  typedecl <name>
\end{verbatim}
which introduces the name for a new type for which the values are different from the values of all existing 
types. Alternatively a type name can be introduced as a synonym for an existing type in the form
\begin{verbatim}
  type_synonym <name> = <type>
\end{verbatim}
such as in \<^theory_text>\<open>type_synonym natset = nat set\<close>.

Terms are mainly built as syntactical structures based on constants and variables. Constants are usually
denoted by names, using the same namespace as type names. Whether a name denotes a constant or a 
type depends on its position in a term. 

A constant name denotes an object, which may also be a function of arbitrary order. Functions always
have a single argument. The type of a function is written as \<open>argtype \<Rightarrow> restype\<close>. The result type
of a function may again be a function type, then it may be applied to another argument. This is used
to represent functions with more than one arguments. Function types are right associative, thus a 
type \<open>argtype\<^sub>1 \<Rightarrow> argtype\<^sub>2 \<Rightarrow> ... \<Rightarrow> argtype\<^sub>n \<Rightarrow> restype\<close> represents a function which can be applied 
to \<open>n\<close> arguments. Function application terms for a function \<open>f\<close> and an argument \<open>a\<close> are denoted by 
\<open>f a\<close>, no parentheses are required around the argument. Function application terms are left 
associative, thus a function application to \<open>n\<close> arguments is written \<open>f a\<^sub>1 ... a\<^sub>n\<close>. Note that an
application \<open>f a\<^sub>1 ... a\<^sub>m\<close> where \<open>m < n\<close> (a ``partial application'') is a correct term and denotes a
function taking \<open>n-m\<close> arguments.

A constant name can be introduced by declaring it together with its type. The declaration
\begin{verbatim}
  consts <name1> :: <type1> ... <namen> :: <typen> 
\end{verbatim}
declares \<^verbatim>\<open>n\<close> constant names with their types.
\<close>

subsection "Definitions"
text_raw\<open>\label{basic-theory-definition}\<close>

text \<open>
\<^item> definitions
\<^item> abbreviations
\<close>

subsection "Overloading"
text_raw\<open>\label{basic-theory-overload}\<close>

text \<open>
\<^item> overloading
\<^item> adhoc overloading
\<close>

subsection "Statements"
text_raw\<open>\label{basic-theory-statement}\<close>

text \<open>
\<^item> theorem, lemma, ...
\<^item> statement names
\<^item> named statement collections (lemmas, buckets)
\<close>

subsection "Locales"
text_raw\<open>\label{basic-theory-locale}\<close>

text \<open>
\<^item> locale as parameterized theory
\<^item> locale parameters
\<^item> locale content
\<^item> locale interpretation
\<close>

section "Isabelle Proofs"
text_raw\<open>\label{basic-proof}\<close>

subsection "Goals"
text_raw\<open>\label{basic-proof-goal}\<close>

text \<open>
\<^item> prop syntax
\<^item> assumptions
\<^item> conclusion
\<^item> view as rewrite rule
\<^item> subgoals (proof state)
\<close>

subsection "Proof Scripts"
text_raw\<open>\label{basic-proof-script}\<close>

text \<open>
\<^item> method syntax
\<^item> apply
\<^item> apply scripts
\<^item> done, by
\<^item> sorry
\<close>

subsection "Backward Reasoning"
text_raw\<open>\label{basic-proof-backward}\<close>

text \<open>
\<^item> Reasoning step
\<^item> conclusion unification
\<^item> rule with one assumption
\<^item> rule with several assumptions
\<^item> rule method
\<^item> rule\_tac method
\<^item> introduction rules
\<^item> intro method
\<close>

subsection "Forward Reasoning"
text_raw\<open>\label{basic-proof-forward}\<close>

text \<open>
\<^item> assumption unification
\<^item> assumption selection
\<^item> rotate method
\<^item> drule method
\<^item> drule\_tac method
\<^item> destruction rules
\<^item> erule method
\<^item> erule\_tac method
\<^item> elimination rules
\<close>

section "Isabelle HOL"
text_raw\<open>\label{basic-hol}\<close>

subsection "Meta Level Operators"
text_raw\<open>\label{basic-hol-meta}\<close>

text \<open>
\<^item> rewrite rules
\<^item> \<open>\<equiv>\<close>
\<^item> \<open>\<Longrightarrow>\<close>
\<close>

subsection "Logical Operators"
text_raw\<open>\label{basic-hol-logop}\<close>

text \<open>
\<^item> \<open>\<and>, \<or>, \<not>, \<longrightarrow>\<close>
\<^item> \<open>=, \<noteq>, \<longleftrightarrow>\<close>
\<^item> \<open>\<forall>, \<exists>\<close>
\<close>

subsection "Logic Rules"
text_raw\<open>\label{basic-hol-logrul}\<close>

text \<open>
\<^item> conjI, conjE, disjI1, disjI2, disjE, impI, mp
\<^item> contrapos\_*
\<^item> iffI, iffE, iffD1, iffD2
\<^item> allI, allE, exI, exE
\<close>

subsection "Equational Reasoning"
text_raw\<open>\label{basic-hol-equational}\<close>

text \<open>
\<^item> Equations, conditional equations
\<^item> Substitution
\<^item> subst method
\<^item> symmetric attribut
\<close>

subsection "The Simplifier"
text_raw\<open>\label{basic-hol-simp}\<close>

text \<open>
\<^item> simpset, simp attribute
\<^item> simp method
\<^item> add:, only:, del:
\<^item> simp\_all method
\<^item> recursive simplification for conditions
\<^item> simp trace
\<^item> debugging with subst
\<close>

end
