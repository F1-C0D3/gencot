The goal of this step is to create the parameter modification descriptions (see Section~\ref{design-parmod})
for the C sources. This step is optional, if it is omitted Gencot will translate all functions using the 
assumption that all parameters of linear type are discarded by their function. This will usually lead to
invalid Cogent code if the parameter value is still used after a function invocation.

Basically, the descriptions must be determined for all functions defined in the translation
set. Usually function definitions only reside in \code{.c} files, but there are C <packages> which also put 
some function definitions in \code{.h} files.

Additionally, parmod descriptions are required for all functions invoked but not defined in
the translation set (``external functions''). Since a parmod description is always derived from the function 
definition, this implies that a superset of the translation set must be processed in this step. The strategy 
described here tries to keep this superset minimal. 

If for a function no definition is available (which is the case for function pointers and for functions
defined outside the C <package>), Gencot only generates a description template which must be filled by the
developer. In the other cases Gencot creates a description in a best effort approach, which must be confirmed
be the developer.

The automatic parts of this step are executed with the help of the script command \code{parmod} (see 
Section~\ref{impl-all-parmod}).

\subsection{Describing Defined Functions}
\label{app-parmod-defined}

The descriptions for the functions defined in the translation set are determined iteratively in a first substep. 
The result is a single parmod description file in json format. It is extended in every iteration and finally
evaluated.

To start, the command
\begin{verbatim}
  items used
\end{verbatim}
must be used to create the list of used external items, which is needed by the commands \code{parmod file}
and \code{parmod close} in the following.

Then for every file in the translation base and for every other file in the translation set which contains
function definitions, the command
\begin{verbatim}
  parmod file
\end{verbatim}
is used to create a parmod description file. These files are then merged using the command
\begin{verbatim}
  parmod mergin
\end{verbatim}
to yield the initial working file for the iterations. 

In each iteration the descriptions must be manually confirmed (using a text editor) until the command
\begin{verbatim}
  parmod show
\end{verbatim}
does not signal any remaining unconfirmed descriptions. If it then does not signal any required 
invocations which are defined in the <package>, the iterations end. Otherwise, the developer must
search for all files in the <package> where required invocations are defined (these files will
not belong to the translation set) and generate parmod descriptions for them using \code{parmod file}.
These descriptions are then added to the working file using the command
\begin{verbatim}
  parmod addto
\end{verbatim}
and the next iteration is performed.

When the iterations end, there may still be remaining required invocations. These are invocations of 
functions defined outside the <package>. To generate the description templates for them the command
\begin{verbatim}
  parmod close
\end{verbatim}
is applied to all C sources to which the command \code{parmod file} has been applied previosly. The resulting 
parmod description template files are merged using \code{parmod mergin} and the resulting description template file
is added to the working file using \code{parmod addto}. The command \code{parmod close} generates templates for
all functions and function pointers for which a declaration is visible in the C source. Since for every function
invoked in a C source a declaration must be visible, the working file will not have required invocations after
this step. Since description templates introduce no additional required invocations, after a final confirmation
step the working file is completed.

Instead of merging the parmod description template files generated by \code{parmod close}, they can also be added
separately to the working file. Often, a C source has much more visible declarations than it needs. Therefore it may
cover required invocations of other files. This way it may be the case that not all single description template
files must be generated to complete the working file.

Evaluating the completed working file using the command
\begin{verbatim}
  parmod eval
\end{verbatim}
will eliminate all transitive dependencies and yield the final parmod description file. It contains at least 
the descriptions for all functions defined in the translation set.

\subsection{Describing External Functions}
\label{app-parmod-extern}

The descriptions for the invoked external functions are determined in a second substep. It results in 
a separate parmod description file. 

The invoked external functions must be determined from the translation set, however, their descriptions must
be generated from their definitions, which are outside the translation set. This is done by the command
\begin{verbatim}
  parmod unit
\end{verbatim}
applied to the unit file and a parmod description file which must contain the descriptions for a superset
of the invoked external functions. This parmod description file must be prepared in advance.

One possibility to prepare the file is to process all C source files which do \textit{not} belong to the 
translation set with \code{parmod file} and merge the results. Since the functions defined outside the <package>
are not contained, additionally the C source files which \textit{do} belong to the translation set must be
processed with \code{parmod close} and the resulting description templates merged to the previous results. 

However, this implies that all files in the
<package> must be prepared for parsing as described in Section~\ref{app-prep}. To avoid this, the file can
be build by trying \code{parmod unit} with an empty parmod description (which is an empty JSON list code{[]}).
It will signal all missing invoked functions not defined in the translation set. From this list the defining 
files (or declaring files in the case of a function defined outside the <package>) can be identified and used 
to build the description file passed to \code{parmod unit}.

Instead of starting with an empty description, all files created by \code{parmod file} in the first substep 
(see Section~\ref{app-parmod-defined}) can be merged and used as a starting point.  

When the descriptions resulting from \code{parmod file} and the description templates resulting from \code{parmod close}
are merged, care must be taken that a description is not replaced by a template for the same function. This may 
happen, since a function may be defined in one \code{.c} file but only declared in another, then both the description
and the template will be present. The command \code{parmod mergin} always selects the description or template with less 
unconfirmed parameters. If both have the same number of unconfirmed parameters, it selects the description or template from
its first argument file. 

A fresh template generated by \code{parmod close} never has more confirmed parameter descriptions than a fresh 
description generated by \code{parmod file} for the same function. Thus, descriptions are selected over templates
if first all descriptions are merged, then the templates are merged into the result, with the file containing the
templates being the second argument to \code{parmod mergin}.

When \code{parmod unit} has successfully been executed, the result must be iteratively completed in the same way 
as in Section~\ref{app-parmod-defined}. Initially, however, the result of the first substep should be added 
using \code{parmod addto}, since it may contain additional descriptions not needed in the first substep.
All descriptions added this way are already fully confirmed and evaluated. Only if afterwards there are remaining 
required invocations, the file must be iteratively completed as in the first substep. 

When the file has been completed, it must be evaluated using \code{parmod eval}.
