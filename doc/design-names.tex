\subsection{Mapping Names from C to Cogent}
\label{design-names}

Names used in the C code shall be translated to similar names in the Cogent code, since they usually are descriptive for the
programmer. Ideally, the same names would be used. However, this is not possible, since Cogent differentiates between 
uppercase and lowercase names and uses them for different purposes. Therefore, atleast the names in the ``wrong'' case
need to be mapped.

Additionally, when the Cogent compiler translates a Cogent program to C code, it transfers the names without changes to
the names for the corresponding C items. To distinguish these names from the names in the original C code Gencot uses 
name mapping schemas which support mapping all kinds of names to a different name in Cogent. Generally, this is done by 
substituting a prefix of the name.

Often, a <package> uses one or more specific prefixes for its names, at least for names with external linkage. In this case
Gencot should be able to substitute these prefixes by other prefixes specific for the Cogent translation of the <package>.
Therefore, the Gencot name mapping is configurable. For every <package> a set of prefix mappings can be provided which is
used by Gencot. Two separate mappings are provided depending on whether the Cogent name must be uppercase or lowecase, so 
that the target prefixes can be specified in the correct case.

If a name must be mapped by Gencot which has neither of the prefixes in the provided mapping, it is mapped 
by prepending the prefix \code{cogent\_} or \code{Cogent\_}, depending on the target case.

\subsubsection{Name Kinds in C}

In C code the tags used for struct, union and enum declarations constitute an own namespace separate from the ``regular''
identifiers. These tags are mapped to Cogent type names by Gencot and could cause name conflicts with regular identifiers
mapped to Cogent type names. To avoid these conflicts Gencot maps tags by prepending the prefixes \code{Struct\_}, 
\code{Union\_}, or \code{Enum\_}, respectively, after the mapping described above. Since tags are always translated to Cogent 
type names, which must be uppercase, only one case variant is required.

Member names of C structs or unions are translated to Cogent record field names. Both in C and Cogent the scope of these
names is restricted to the surrounding structure. Therefore, Gencot normally does not map these names and uses them unmodified
in Cogent. However, since Cogent field names must be lowercase, Gencot applies the normal mapping for lowercase target 
names to all uppercase member names (which in practice are unusual in C). Moreover, Cogent field names must not begin
with an underscore, so these names are mapped as well, by prepending \code{cogent\_} (which results in two consecutive 
underscores).

C function parameter names are translated to Cogent variable names bound in the Cogent function body expression. Hence, both
in C and Cogent the scope of these names is restricted to the function body. They are treated by Gencot in the same way as 
member names and are only mapped if they are uppercase in C, which is very unusual in practice.

The remaining names in C are type names, function names, enum constant names, and names for global and local variables.
Additionally, there may be C constant names defined by preprocessor macro directives.
Local variables only occur in C function bodies which are not translated by Gencot. The other names are always mapped by
Gencot, irrespective whether they have the correct case or not.

\subsubsection{Names with internal linkage}

In C a name may have external or internal linkage. A name with internal linkage is local to the compilation unit in which it
is defined, a name with external linkage denotes the same item in all compilation units. Since the result of Gencot's 
translation is always a Cogent program which is translated to a single compilation unit by the Cogent compiler, names 
with internal linkage could cause conflicts when they origin in different C compilation units.

To avoid these conflicts, Gencot uses a name mapping scheme for names with internal linkage which is based on the 
compilation unit's file name. Names with internal linkage are mapped by substituting a prefix by the prefix \code{local\_x\_}
where \code{x} is the basename of the file which contains the definition, which is usually a file \code{x.c}. The default
is to substitute the empty prefix, i.e., prepend the target prefix. The mapping can be configured by specifying prefixes
to be substituted. This is motivated by the C programming practice to sometimes also use a common prefix for names 
with internal linkage which can be removed in this way.

Name conflicts could also occur for type names and tags defined in a \code{.h} file. This would be the case if different
C compilation units include individual \code{.h} files which use the same identifier for different purposes. However, most
C packages avoid this to make include files more robust. Gencot assumes that all identifiers defined in a \code{.h} file
are unique in the <package> and does not apply a file-specific renaming scheme. If a <package> does not satisfy this assumption
Gencot will generate several Cogent type definitions with the same name, which will be detected and signaled by the Cogent 
compiler and must be handled manually.

\subsubsection{Introducing Type Names}

There are cases where in Cogent a type name must be introduced for an unnamed C type (directly specified by a C type 
expression). Then the Cogent type name cannot be generated by mapping the C type name.

Unnamed C types are tagless struct/union/enum types and all derived types, i.e., array types, pointer types and 
function types. Basically, an unnamed C type could be mapped to a corresponding Cogent type expression. However,
this is not always possible or feasible.

Tagless enum types are always mapped to a primitive type in Cogent.

A tagless C struct could be mapped to a corresponding Cogent record type expression. However, the tagless struct
can be used in several declarators and several different types can be derived from it. In this case the Cogent record
expression would occur syntactically in several places, which is semantically correct, but may not be feasible for
large C structs. Therefore, Gencot introduces a Cogent type name for every tagless C struct and union.

Tagless structs and unions syntactically occur at only a single place in the source. The unique name is derived from 
that place, using the name of the corresponding source file and the line number where the struct/union begins
in that file (this is the line where the struct or enum keyword occurs).
The generated names have the forms
\begin{verbatim}
  <kind><lnr>_x_h
  <kind><lnr>_x_c
\end{verbatim}
where the suffix is constructed from the name \code{x.h} or \code{x.c} of the source file. \code{<kind>} is one of
\code{Struct} or \code{Union}, and \code{<lnr>} is the line number in the source file.

Derived C types are pointer types, function types, and array types. They always depend on a base type which in the C program 
must be defined before the base type is used.
In Cogent a similar dependency can only be expressed ba a generic type: the Cogent compiler takes care that in the generated C code
each instance
of a generic type is introduced after all its type arguments have been defined. Therefore Gencot translates every C derived
types to a generic Cogent type with its base type as its (single) type argument. 

For C pointer types a fixed set of generic types is used by Gencot (see Section~\ref{design-types-pointer}). Function types 
are translated to Cogent function type expressions. Only for array types generic type names are introduced which are specific
for the translated C program.

To be able to process every source file independently from all other source files, Gencot uses a schema which generates
a unique generic type name for every C array type. Derived types may syntactically occur at many places in a C program, so
it is not feasible to generate the name from a position in the source file.

For C array types its size (the number of elements) may be part of the derived type specification. Gencot uses two seperate generic
type names for every size for which an array type is used in the C program. If the size is specified by a literal the names
have the form
\begin{verbatim}
  CArr<size>
  UArr<size>
\end{verbatim}
where \code{<size>} is the literal size specification. If the size is specified by a single identifier the names have the form
\begin{verbatim}
  CArrX<size>X
  UArrX<size>X
\end{verbatim}
where \code{X} is a letter not occurring in the identifier.
In all other cases (also if no size is specified) the predefined names
\begin{verbatim}
  CArrXX
  UArrXX
\end{verbatim}
are used which may lead to name conflicts in Cogent and must be handled manually. 

Note that the generated Cogent type names could still cause conflicts with mapped type names. These conflicts can be
avoided if no configured mapping prefix starts with one of the \code{<kind>} strings
or the strings \code{"CArr"}, \code{"UArr"} used for mapping C array types, or any other predefined type used by Gencot.

\subsubsection{Encoding C Function Types}

Gencot represents C function pointer types with the help of abstract Cogent types which encode C function types. These
function type names are constructed from encodings of all parameter types and the result type. Hence Gencot implements
a schema for encoding all C types as Cogent abstract type names.

A C type is either a primitive type, a derived type, a typedef name, or a struct/union/enum type. Gencot maps all
struct/union/enum types to a Cogent type name. Primitive types and typedef names are specified by a single identifier
in C and are also mapped to a Cogent type name by Gencot. These names are directly used as encoding. Thus only for the 
derived types (pointer, array, and function types) a nontrivial encoding must be defined.

Every derived type in C has a single base type from which it is derived. The base type of a derived
type is always either another derived type, or it is mapped by Gencot to a Cogent type name. Hence every derived 
type can be uniquely characterized by a sequence of derivation steps starting with a type name. The sequence of 
derivation steps is syntactically encoded in the generated name as follows.

A pointer derivation step is encoded by a single letter \code{"P"}. 

An array derivation step without size
specification is encoded by a single letter \code{"A"}. An array derivation step with a literal
as size specification is encoded in the form
\begin{verbatim}
  A<size>
\end{verbatim}
where \code{<size>} is the size specification. If the size is specified by a single identifier the 
step is encoded in the form
\begin{verbatim}
  AX<size>X
\end{verbatim}
where \code{X} is a letter not occurring in the identifier.
In all other cases an array derivation step is encoded by
\begin{verbatim}
  AXX
\end{verbatim}
which may lead to name conflicts in Cogent and must be handled manually. As described in 
Section~\ref{design-types-array}, a C array type may be mapped to an unboxed or boxed form, depending
on its usage context. The unboxed form is encoded by prepending the letter \code{"U"} to the step
encoding.

A function derivation step is encoded in the form
\begin{verbatim}
  FX<P1>X<P2>X...X<Pn>X
\end{verbatim}
where the \code{<Pi>} are the encodings of the parameter types and \code{X} is a letter not occurring in 
any of the parameter type encodings. A parameterless function type is encoded as \code{FXX}, whereas an
incomplete function type where no parameter types are specified is encoded as \code{F}.
If the function type is variadic, an additional pseudo parameter type \code{VariadicCogentParameters}
is added as last parameter. 

In some cases Gencot maps a C pointer type to a boxed Cogent type and its base type to the corresponding
unboxed type by applying the unbox operator \code{\#} to the Cogent type. In these cases the pointer derivation
step is omitted in the encoding, and the base type is encoded by applying a pseudo derivation step 
of the form \code{"U"}.

Function parameters of linear type may be mapped by Gencot as readonly or not (see Section~\ref{design-types-readonly}). 
This is encoded by pseudo derivation steps of the form \code{"R"} for readonly and \code{"M"} (``modifyable'')
otherwise. Parameters of nonlinear type are not marked by either of these steps. Parameters of linear typ marked as 
\code{"discarded"} or specified as \code{"f\_result"} in a parameter modification description (see Section~\ref{impl-parmod-struct}) are also not
marked by either of these steps.

For all derivation steps which are applied to a base type, their encodings are concatenated, beginning with the 
last derivation step, with an underscore \code{\_} as separator. For a derived pointer or 
function type the base type can be the pseudo type \code{void}. In these cases the identifier \code{Void} is
used as base type encoding.

Hence, for example for the C type
\begin{verbatim}
  int (* [5])(int, const short*)
\end{verbatim}
the encoding is
\begin{verbatim}
  A5_P_FXU32XR_P_U16X_U32
\end{verbatim}

These encodings are used for representing C function pointer types by prepending \code{CFunPtr\_} or \code{CFunInc\_}
to construct abstract Cogent type names. For example, the C function pointer type
\begin{verbatim}
  int (*)(int[16], struct str)
\end{verbatim}
is mapped to the abstract Cogent type defined as
\begin{verbatim}
  type CFunPtr_FXA16_U32XU_Struct_Cogent_strX_U32
\end{verbatim}
