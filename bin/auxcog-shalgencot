#! /bin/sh

# Generate an Isabelle theory for the extended shallow embedding (core or HOL-tupled). Intended to be applied to 
# X_ShallowShared.thy or X_ShallowShared_Tuples.thy generated by Cogent.
# This is a filter from stdin to stdout with an additional filename argument.
# The argument file must contain a sequence of lines of the form
#   <id>: <id>

if [ $# != 1 ]
then
  echo "Error: Single file name expected as argument."
  exit 0
fi

awk \
'BEGIN { 
   cfile = ARGV[1]; delete ARGV[1]
   gencot_theories = "Default Memory MayNull CPointer CArray"
   common_theories = "common"
   nr_sizes = 0
   nr_afuns = split("siz getArr setArr modifyArr modrefArr toCAES fromCAES rotoCAES rofromCAES", afuns)
 } 
{
  if ($1 == "theory" && NF == 2) {
    if ($2 ~ /_ShallowShared_Tuples$/) { tup = "_Tuples"; prfnam = substr($2,1,length($2)-21) }
    else if ($2 ~ /_ShallowShared$/) { tup = ""; prfnam = substr($2,1,length($2)-14) }
    else {
      printf("Error: auxcog-shalgencot input must be a theory named X_ShallowShared or X_ShallowShared_Tuples.\n")
      exited = 1
      exit 1
    }
    printf("theory %s_Shallow_Gencot%s\n", prfnam, tup)
    printf("  imports \"%s_ShallowConsts_Desugar%s\"\n", prfnam, tup)
    while ((getline cline < cfile) > 0) { 
      if (2 == split(cline,a)) { 
        if (a[1] == "gencot:" && match(gencot_theories,a[2])) printf("  \"Gencot_%s%s\"\n", a[2], tup)
        if (a[1] == "common:" && match(common_theories,a[2])) printf("  \"CogentCommon_%s%s\"\n", a[2], tup)
      } 
    }
    close(cfile) 
    printf("begin\n\n")
  } else if ($1 == "type_synonym" && substr($3,1,4) == "CArr" && $6 == "list") {
    size = substr($3,5,length($3)-12)
    if (size ~ /^[0-9]*$/) { namedsize = 0; sizeval = size }
    else { namedsize = 1; sizeval = substr(size,2,length(size)-2)}
    if (namedsize) {
      printf("lemmas [simp] = cogent_%s_def\n",sizeval)
      printf("definition \"%s \\<equiv> (unat cogent_%s)\"\n", sizeval, sizeval)
    }
    printf("interpretation FxdArrDefs%s: FxdArrDefs arr%s\\<^sub>f CArr%s.make %s \"0::32 word\" .\n", size, size, size, sizeval)
    printf("adhoc_overloading\n")
    printf("      arr arr%s\\<^sub>f\n",size)
    printf("  and carr CArr%s.make\n",size)
    for (i=1; i <= nr_afuns; i++) printf("  and %s FxdArrDefs%s.%s\n", afuns[i], size, afuns[i])
    printf("\n")
  }
}
END {
  if (exited == "") {
    print "end"
  }
}' $1

# documentation:
#
# The generated theory has the following form:
# - the name of the input theory must be X_ShallowShared with an optional suffix _Tuples, which
#   is stored in the variable tup. Otherwise an error message is written to stderr.
# - the name of the output theory is X_Shallow_Gencot[tup]
# - the output theory imports X_ShallowConsts_Desugar[tup]
#   and for every line 
#     gencot: id
#   in the argument file for which id is in gencot_theories the theory Gencot_id[tup], and for every line
#     common: id
#   in the argument file for which id is in common_theories the theory CogentCommon_id[tup].
# - the output theory contains for every type synonym definition of the form
#     type_synonym 'el CArr<size>\<^sub>T = 'el list CArr<size>
#   in the input theory a section of the following form. The <size> my be either specified by a named 
#   constant <sizeval>, or by a number literal <sizeval>. The section always contains a locale interpretation 
#   of the form
#     interpretation FxdArrDefs<size>: FxdArrDefs arr<size>\<^sub>f CArr<size>.make <sizeval> "0::32 word" .
#   and an adhoc overloading of the form
#     adhoc_overloading 
#           arr ...
#       and carr ...
#       ...
#   for all array operations
#     arr, carr, siz, getArr, setArr, modifyArr, modrefArr, toCAES, fromCAES, rotoCAES, rofromCAES
#   If the size is a named constant, the section additionally adds the word constant definition to the simpset
#     lemmas [simp] = cogent_<sizeval>_def
#   and defines a nat constant
#     definition "<sizeval> \<equiv> (unat cogent_<sizeval>)"
#
# The list of theories which can be imported is specified by the string variables 
# gencot_theories and common_thories as a sequence of words separated by blanks.
# The list of array operations is specified in the array afuns of length nr_afuns,
#
# The input is read until a line of the form "theory <name>" is found. Using the <name>, the tup-suffix
# is determined and the output theory header is generated. The argument file is read using getline to 
# generate the corresponding imports.
# 
# Then the rest of the input is read and for each matching type synonym definition the 
# interpretation and adhoc overloading is generated.
# 
# In the END rule the theory is finished by an "end".
#
# Implementation in awk:
# - The filename argument for the comment file must be copied and removed from the argument list ARGV
#   to prevent its processing as normal input to awk. The argument file is explicitly read by getline.
# - The theory lists gencot_theories and common_thories are defined in the BEGIN rule.
# - The function array is filled in the BEGIN rule by splitting a string of words.
# - Since in '...' the ' cannot be escaped, we avoid using it in match expressions.
# - To test whether an entry from the argument file is a member of a theory list the awk builtin function
#   match is used. The theory list is specified as the string, the entry is used as regexp. If a match
#   is found the function returns the index of the first position of the match (which is equivalent to true),
#   otherwise it returns 0 (which is equivalent to false). Note that this works only if no theory name 
#   is a substring of another theory name in the list.
# - To test whether a size specification is a literal or a named constant the regexp /^[0-9]*$/ is used.

