\subsection{Cogent Source File Structure}
\label{design-files}

Although the Cogent source is not structured on the level of compilation units, Gencot intends to reflect the structure of 
the C program at the level of Cogent source files. 

Note, that there are four kinds of include statements available in Cogent source files. One is the \code{include} statement which
is part of the Cogent language. When it is used to include the same file several times in the same Cogent compilation unit,
the file content is automatically inserted only once. However, the Cogent preprocessor is executed separately for every file included 
with this \code{include} statement, thus preprocessor macros defined in an included file are not available in all other files. For 
this reason it cannot be used to reflect the file structure of a C program.

The second kind is the Cogent preprocessor \code{\#include} directive, it works like the C preprocessor \code{\#include} directive
and is used by Gencot to integrate the separate Cogent source files. 
The third kind is the preprocessor \code{\#include} directive 
which can be used in antiquoted Cogent files where the Cogent \code{include} statement is not available. This is only possible 
if the included content is also an antiquoted Cogent file. The fourth kind
is the \code{\#include} directive of the C preprocessor which can be used in antiquoted Cogent files in the form 
\code{\$esc:(\#include ...)}. It is only executed when the C code generated by the Cogent compiler is processed by the C compiler.
Hence it can be used to include normal C code.

Gencot assumes the usual C source structure: Every \code{.c} file contains definitions with internal or external linkage.
Every \code{.h}
file contains preprocessor constant definitions, type definitions and function declarations. The constants and type definitions 
are usually mainly those which are needed for the function declarations. Every \code{.c} file includes the \code{.h} file which
declares the functions which are defined by the \code{.c} file to access the constants and type definitions. Additionally it may
include other \code{.h} files to be able to invoke the functions declared there. A \code{.h} file may include other \code{.h} files
to reuse their constants and type definitions in its own definitions and declarations.

\subsubsection{Cogent Source Files}

In Cogent a function which is defined may not be declared as an abstract function elsewhere in the program. If the types and constants,
needed for defining a set of functions, should be moved to a separate file, like in C, this file must not contain the 
function declarations for the defined functions. Declarations for functions defined in Cogent are not needed at all, since the Cogent 
source is a single compilation unit and functions can be invoked at any place in a Cogent program, independently whether their definition 
is statically before or after this place.

Therefore we map every C source file \code{x.c} to a Cogent source file \code{x.cogent} containing definitions of the same 
functions. We map every C include file \code{x.h} to a Cogent source file \code{x-incl.cogent} 
containing the corresponding constant and type definitions, but omitting any function declarations. The include relations among 
\code{.c} and \code{.h} files are directly transferred to \code{.cogent} and \code{-incl.cogent} using the Cogent preprocessor 
\code{\#include} directive. 

The file \code{x-incl.cogent} also contains Cogent value definitions generated from C preprocessor
constant definitions and from enumeration constants (see below). It would be possible to put the value definitions in a 
separate file. However, then for other preprocessor macro definitions it would not be clear where to put them, since they could
be used both in constant and type definitions. They cannot be moved to a common file included by both at the beginning,
since their position relative to the places where the macros are used is relevant.

In some cases an \code{x.h} file contains function definitions, typically for inlined functions. They are translated to Cogent
function defintions in the \code{x-incl.cogent} file in the usual way.

This file mapping implies that for every translated \code{.c} file all directly or indirectly included \code{.h} files must be 
translated as well.

\subsubsection{External Name References and Derived Types}

For external name references Gencot generates the information required for Cogent. 
All generated type and constant definitions are put in the file \code{<package>-exttypes.cogent}.

This file also contains abstract type definitions for all derived types used in the C source. 
For pointer and function types Gencot also generates C type definitions, mapping the type name to
a simplified derived type, omitting all non-derived types occurring in the original derived type (because 
they are not available in the Cogent compilation unit). All pointer types are mapped to pointer to void.
All function types are mapped to an incompletely defined function type returning void. In both cases
the resulting type is binary compatible with the original derived type.

Gencot puts the corresponding
type mapping definitions in the file \code{<package>-exttypes.c}.

For derived array types to be binary compatible, the element type must have the correct size and the 
element number must be correct. Gencot cannot determine a corresponding C type without using the original
element type and element number expression, a corresponding C type must be provided manually by the developer
and added to file \code{<package>-exttypes.c}.

\subsubsection{Wrapper Definition Files}

The entry wrappers for the functions defined with external linkage in \code{x.c} are implemented in antiquoted Cogent code and
put in the file \code{x-entry.ac}. 

The exit wrappers for invoking C functions from Cogent are only created for the actual
external references in a processing step for the whole <package>. They are implemented in antiquoted Cogent
and put in the file \code{<package>-externs.ac}.

\subsubsection{Dummy Value Functions}

Gencot does not translate C function bodies, instead, it uses a Cogent expression for a dummy result value 
(see Section~\ref{design-fundefs}). For linear and abstract Cogent types these expressions are constructed with the
help of abstract functions. All these abstract function definitions are put in the file \code{<package>-dummies.cogent}.

Since the dummy result expressions are intended to be eliminated when the C bodies are manually translated, Gencot 
does not generate corresponding C function definitions for them.

Putting all abstract dummy function definitions in a single file provides an easy way to remove them from the 
Cogent compilation unit when the manual translation has been completed and they are not needed any more.

\subsubsection{Abstract Functions as Interface to C Functions and Variables}

If a Cogent function in \code{x.cogent} invokes a function which is externally referenced and not defined in another
file \code{y.cogent}, this function must be declared as an abstract function in Cogent. These abstract function declarations
are only created for the actual
external references in a processing step for the whole <package>. They are put in the file \code{<package>-externs.cogent}.

The implementation for these functions is provided by the exit wrappers in \code{<package>-externs.ac}.

For external variables Gencot creates abstract access functions and also puts them in \code{<package>-externs.cogent}.
These functions are mostly intended as information for the developer, no implementation is provided by Gencot.

\subsubsection{Global Variables}

In C a compilation unit can define global variables. Gencot does not generate an access interface to these variables
from Cogent code. However, the variables must still be present in a compilation unit, since they may be accessed
from other C compilation units (if they have external linkage). 

Gencot assumes that global variables are only defined in \code{.c} files. For every file \code{x.c} Gencot generates
the file \code{x-globals.c} containing all toplevel object definitions with external linkage in \code{x.c}. For 
these definitions, some type and constant definitions may be required, so they must also be added to \code{x-globals.c}.
Since the required types may be defined in included \code{.h} files, these files must be included in \code{x-globals.c}.
Instead of tracking, what is required for the global variable definitions, Gencot simply generates \code{x-globals.c}
from \code{x.c} by removing all function definitions. 

Toplevel object definitions with internal linkage cannot be accessed from other C compilation units. They cannot be
accessed from Cogent code either, hence they are useless, they must be replaced manually by a Cogent solution for
managing the corresponding global state. They are not removed from \code{x-globals.c}, because they could be used in
initializers of object definitions with external linkage.

The files \code{x-globals.c} do not become part of the Cogent compilation unit, because they use the original 
include files from the package and should not be read by the Isabelle C parser. Instead, each of them constitutes 
an own C compilation unit which complements the Cogent compilation unit. It must be separately compiled and
linked with the Cogent compilation unit to provide the global variables for the remaining C compilation units.

\subsubsection{Abstract Data Types}

There may also be cases of C types where no corresponding Cogent type can be defined, in this case it must be mapped to an 
abstract data type T in Cogent, consisting of an abstract type together with abstract functions. Both are put in 
the file \code{abstract/T.cogent} which must be included manually by all \code{x-incl.cogent} where it is used. The types and 
functions of T must be implemented in additional C code. In contrast to the abstract functions defined in 
\code{<package>-externs.cogent},
there are no existing C files where these functions are implemented. The implementations are provided as antiquoted Cogent 
code in the file \code{abstract/T.ac}. If T is generic, the additional file \code{abstract/T.ah} is required for 
implementing the types, otherwise they are implemented in \code{abstract/T.h}. 

Gencot does not provide any support for using abstract data types, they must be managed manually according to the following
proposed schema. All related files should be stored in the subdirectory \code{abstract}.
An abstract data type T is defined in the following files:
\begin{description}
\item[\code{T.ac}] Antiquoted Cogent definitions of all functions of T. 
\item[\code{T.ah}] Antiquoted Cogent definition for T if T is generic.
\item[\code{T.h}] Antiquoted Cogent definitions of all non-generic types of T.
\end{description}
Using the flag \code{--infer-c-types} the Cogent compiler generates from \code{T.ah} files \code{T\_t1...tn.h} for all 
instantiations of T with type arguments t1...tn used in the Cogent code.

\subsubsection{File Summary}

Summarizing, Gencot uses the following kinds of Cogent source files for existing C source files \code{x.c} and \code{x.h}:
\begin{description}
\item[\code{x.cogent}] Implementation of all functions defined in \code{x.c}. Abstract access functions for all global
variables defined in \code{x.c}. For each file \code{y.h} included by
  \code{x.c} the file \code{y-incl.cogent} is included.

\item[\code{x-incl.cogent}] Constant and type definitions for all constants and types defined in \code{x.h}. 
  If possible, for every C type definition a binary compatible Cogent type 
  definition is generated by Gencot. Otherwise an abstract type definition is used. Includes
  all \code{y-incl.cogent} for which \code{x.h} includes \code{y.h}.
\item[\code{x-entry.ac}] Antiquoted Cogent definitions of entry wrapper functions for all function definitions with external linkage
  defined in \code{x.c}.
\item[\code{x-globals.c}] Content of \code{x.c} with all function definitions removed.
\end{description}

For the Cogent compilation unit the following common files are used:
\begin{description}
\item[\code{<package>-exttypes.cogent}] Type and constant definitions for all derived and external type and constant references.
\item[\code{<package>-externs.cogent}] Abstract function definitions for all external function and variable references.
\item[\code{<package>-dummies.cogent}] Abstract function definitions for dummy result values.
\item[\code{<package>-externs.ac}] Exit wrapper definitions for all external function references.
\item[\code{<package>-exttypes.c}] C type definitions for abstract types defined in \code{<package>-exttypes.cogent}.
\end{description}

\subsubsection{Main Files}

To put everything together we use the files \code{<package>.cogent} and \code{<package>.ac}. The former includes all 
existing \code{x.cogent} files and the files \code{<package>-exttypes.cogent}, \code{<package>-externs.cogent}, and
\code{<package>-dummies.cogent}.
It is the file processed by the Cogent compiler which translates it to files \code{<package>.c} 
and \code{<package>.h} where \code{<package>.c} includes \code{<package>.h}. 

The file \code{<package>.ac} includes all existing files 
\code{x-entry.ac}, and the files \code{<package>-externs.ac} and \code{<package>.c} and is processed by the Cogent compiler through the 
\code{--infer-c-funcs} flag. The resulting file is \code{<package>\_pp\_inferred.c} which is the C code of 
the Cogent compilation unit. 
The file \code{<package>-exttypes.c} is 
\code{\$esc}-included in \code{<package>.ac}, thus the corresponding normal include directive for it is present in 
\code{<package>\_pp\_inferred.c}.

Every abstract type T yields an additional separate C compilation unit \code{T\_pp\_inferred.c}. 

The content of \code{abstract/T.h} and all \code{abstract/T\_t1...tn.h} is required in the compilation unit for T and in 
that for \code{<package>.c}. The Cogent compiler automatically generates includes for all \code{abstract/T\_t1...tn.h} in 
\code{<package>.h}, 
thus they are available in \code{<package>\_pp\_inferred.c}. By manually \code{\$esc}-including \code{<package>.h} in every 
\code{abstract/T.ac} they are made available there as well. In the same way \code{abstract/T.h} can be \code{\$esc}-included
in \code{abstract/T.ac}. To make it available in the \code{<package>.c} unit Gencot also \code{\$esc}-includes all 
existing \code{abstract/T.h} files in \code{<package>.ac}.

 
