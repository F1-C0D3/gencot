The goal of this step is to translate a single C source file which is part of the translation set to Cogent.
This is done by first using Gencot to translate the file to Cogent with embedded partially translated C code,
and then manually translating the embedded C code.

The translated file is either a \code{.c} file which can be seperately compiled by the C compiler as a compilation unit,
or it is a \code{.h} file which is a part of one or more compilation units by being included by other files. In both cases
the file can include \code{.h} files, both in the package and standard C include files such as \code{stdio.h}.

\subsection{Automatic Translation by Gencot}
\label{app-trans-auto}

To be translated by Gencot the C source file must first be prepared for being read by Gencot as described in
Section~\ref{app-prep}. Then the parameter modification descriptions for all functions and function types defined 
in the source file must be created and evaluated as described in Section~\ref{app-parmod-defined}. 

A \code{.c} file is translated using the command
\begin{verbatim}
  gencot [options] cfile file.c [<parmod>]
\end{verbatim}
where \code{file.c} is the file to be translated and \code{<parmod>} is the file containing the parameter modification 
descriptions. If it is not provided, Gencot assumes for all functions and function types, that linear parameters 
may be modified. The result of the translation is stored as \code{file.cogent} in the current directory.

An \code{.h} file is translated using the command
\begin{verbatim}
  gencot [options] hfile file.h [<parmod>]
\end{verbatim}
where \code{file.h} is the file to be translated and \code{<parmod>} is as above. The result of the translation is 
stored as \code{file-incl.cogent} in the current directory.

Special support is provided for translating configuration files. A configuration file is a \code{.h} file mainly
containing preprocessor directives for defining flags and macros, some of which are deactivated by being ``commented
out'', i.e., they are preceded by \code{//}. If such a file is translated using the command
\begin{verbatim}
  gencot [options] config file.h [<parmod>]
\end{verbatim}
it is translated like a normal \code{.h} file, but before, all \code{//} comment starts at line beginnings are 
removed, and afterwards the corresponding Cogent comment starts \code{--} are re-inserted before the definitions.

\subsection{Manual Translation of C Function Bodies}
\label{app-trans-manbody}

The manual part of the translation is mainly required for the bodies of all C functions defined in the C source file.
A \code{.h} file normally does not contain function or object definitions, then it may be the case that no manual actions 
are necessary. But some \code{.h} files define functions, typically as \code{static inline}, then also their bodies
must be translated manually.

The manual translation is done by modifying the \code{.cogent} file generated by the automatic translation in an 
editor. As described in Section~\ref{design-fundefs-body}, the result of automatically translating a function
definition has the form
The generated Cogent function definition has the form
\begin{verbatim}
  <name> :: (<ptype1>, ..., <ptypen>) -> <restype>
  <name> (<pname1>, ..., <pnamen>) = <dummy result>
  {- <compound statement> -}
\end{verbatim}
where the \code{<compound statement>} is plain C code with global names mapped to Cogent. The task of the manual
translation is to replace the \code{<dummy result>} by a Cogent expression equivalent to the \code{<compound statement>}.

In the following sections we provide some patterns how to translate typical C constructs occurring in a
\code{<compound statement>}.

\subsection{Function Pointer Invocation}
\label{app-trans-funpointer}

In C a function pointer may be \code{NULL}, therefore it is typically tested for being valid before the
referenced function is invoked, such as in 
\begin{verbatim}
  if( fptr == NULL ) ...
  else fptr( params );
\end{verbatim}
We assume that fptr shall have a type which is binary compatible to the function pointer type in C.
This prevents to use a Cogent type \code{Option a} as the natural equivalent of a value that may be undefined.
\code{Option a} is a Cogent variant type and is not binary equivalent to the C function pointer type.

If \code{fptr} is a member of a C struct, it would be possible to use a Cogent record with a taken field,
if the function pointer is undefined. Then it would be clear from the record type whether the function pointer
is valid and can be invoked. However, this would require two implementations for all functions with such a records 
as parameter, which is usually infeasible.

The generic type \code{MayNull} (see Section~\ref{app-trans-null} cannot be used for function pointers since
it is linear and the corresponding abstract functions expect values of the boxed type, whereas function pointers
are always represented by an unboxed type.

The simplest solution is to assume that function pointers are always defined. Instead of using the value 
\code{NULL}, they must then be set to point to a default function. Then no test is required, the function
can simply be invoked in Cogent.

Note that to be binary compatible the Cogent type of \code{fptr} is an abstract type of the form \code{\#F\_...}.
To invoke the referenced function the translation function \code{invk\_F\_...} must be used (see 
Section~\ref{design-types-function}). 

For example, if the function pointer is declared in C as 
\begin{verbatim}
  int (*fptr)(int p1, const char *p2);
\end{verbatim}
the corresponding invocation in Cogent would be
\begin{verbatim}
  invk_F_'U32'RP_U8'_U32 (fptr,arg1,arg2)
\end{verbatim}
with result type \code{U32}.

\subsection{Modifying Linear Values}
\label{app-trans-modify}

Values of linear type can be modified in Cogent. Modification is directly supported by the Cogent language only by the put
and take operations which are applicable to record values and in the simplest case have the form
\begin{verbatim}
  let r' = r { f = v } in ...
  let r' { f = p } = r in ...
\end{verbatim}
Here \code{r} is the old record value, \code{f} is the field to be modified, \code{r'} is the modified record value.
In the put operation \code{v} is the new field value. The type of \code{r'} is either the same as for \code{r} or it
differs, if field \code{f} was taken in \code{r}. In the take operation \code{p} is a pattern for binding the old 
field value, in \code{r'} the field is not present anymore, the type of \code{r'} is always different from that of \code{r}.

For abstract types, which are also linear, a modification operation can only be defined with the help of an abstract function.
To provide a common framework for modification operations, Gencot defines function types for modification functions 
in \code{include/gencot/ModFun.cogent}. The basic function types are
\begin{verbatim}
  type ModTypeFun obj arg res = (obj,arg) -> res
  type ModFun obj arg = ModTypeFun obj arg obj
\end{verbatim}
The first type covers the genaral case where the type of the modified value is different from that of the old value, in the second
case the type is the same before and after the modification. In both cases a value of type \code{arg} is passed to the modification
function, it may provide information about how to modify the value. 

The put operation can now be represented as a function of type \code{ModTypeFun R V (R put f)} where \code{R} is the type of
\code{r} and \code{V} that of field \code{f} and value \code{v}. If the field is not taken in \code{R} the type is \code{ModFun R V}.
The take operation can be represented as a function of type \code{ModTypeFun R () (R take f)}. If the value of the taken
field should also be returned it can be represented as a function of type \code{ModTypeFun R () (V,R take f)} where the result
is a pair of the taken field value and the remaining record.

Gencot defines macros in \code{include/gencot/ModFun.cogent} to generate the type of simple put and take operations.
A macro call of the form 
\begin{verbatim}
  PUTFUN<n>(R,(f1,...,fn),f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f,f1,...,fn)) A (R take (f1,...,fn)) 
\end{verbatim}
for a function which puts field \code{f} while the fields \code{fi} are already taken. A macro call of the form
\begin{verbatim}
  TAKEFUN<n>(R,(f1,...,fn),f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f1,...,fn)) A (R take (f,f1,...,fn)) 
\end{verbatim}
for a function which takes field \code{f} while the fields \code{fi} are already taken.

If field \code{f} again has a linear type, it must have been taken before the put operation can be applied. Thus the 
typical pattern for modifying a field of linear type is
\begin{verbatim}
  let r' { f = p } = r 
  and r'' = r' { f = v }
\end{verbatim}
This can be represented as a function of type \code{ModFun R V} if the old field value is discarded (which is only possible
if the function is abstract). However, often the linear value of field \code{f} is not replaced but modified and then put back
in. This case can be represented by a function of type \code{ModFun R (ModFun V)} where the additional information for the modification
of \code{r} is the modification function to be applied to the value of field \code{f}. More generally, it must also be possible
to specify the additional argument to be passed to the modification function for the field, so the argument to the outer 
modification function should be a pair of the inner modification function and its argument. Gencot defines the corresponding
function type
\begin{verbatim}
  type ModPartFun obj prt arg = ModFun obj (ModFun prt arg, arg)
\end{verbatim}
where \code{obj} is the type of the modified object, \code{prt} is the type of the part to be modified, and \code{arg} is the type
of the information passed to the modification function of the part.

Since every \code{ModPartFun} is a \code{ModFun}, modification functions of this type can be chained to modify linear parts arbitrarily 
deep embedded in other linear parts. Moreover, a \code{ModPartFun} corresponds to combined take and put operation and can be used
to model ``in-place modification'' of linear parts. For these reasons Gencot uses such functions for all cases of modifications 
in the following sections.

As an example, to modify a part \code{p} of type \code{P} in a part \code{q} of type \code{Q} in a linear value \code{r} of type \code{R}
an expression of the form
\begin{verbatim}
  modifyQInR (r, (modifyPInQ, (modifyP, arg)))
\end{verbatim}
modifies \code{p} by replacing it by \code{modifyP (p,arg)}. To make the modification functions generic they can be defined as polymorphic:
\begin{verbatim}
  modifyQInR: all(a). ModPartFun R Q a
  modifyPInQ: all(a). ModPartFun Q P a
  modifyP: ModFun P A
\end{verbatim}

If the modification function \code{modifyP} needs as input information of nonlinear type from other linear parts of \code{q} or \code{r} it is not
possible to pass these parts to \code{modifyP}. Either they must be taken from \code{r} and put back in after the modification, then
the type of \code{r} is \code{R take (...)} and \code{modifyQInR} cannot be applied because of type incompatibility. Or the parts are
accessed as readonly in a banged context for \code{r}, then the readonly parts cannot escape from the banged context to be passed to the
modification operation (which must be outside of the banged context since it modifies \code{r}). Instead, the required nonlinear information must 
be retrieved from the linear parts in a banged context for \code{r}. Since it is nonlinear it may escape from the context and can be passed 
to the modification operation.

In C it is a common pattern to pass pointers to other parts of a data structure around for efficiency and access values through these pointers 
only when needed to modify parts of the structure. In the Cogent translation the values must be accessed separately in a banged context and then
passed to the modification operation.

\subsection{The Null Pointer}
\label{app-trans-null}

The type safety of Cogent relies on the fact that the pointers representing values of linear types are never \code{NULL}.
If null pointers are used in the C source, there is no immediate translation. The way how to translate C code which uses 
null ponters in a binary compatible way depends on the way how the null pointers are used.

A null pointer can be used as struct member \code{f} of linear Type \code{T} in an ``uninitialized state''. 
It is set when the struct is created and later
replaced by a valid pointer. It remains valid until the struct is disposed. If additionally the struct is used only in places
during the ``uninitialized state'' which are different from those afterwards, the ``uninitialized state'' can be represented
by using the record type with the field \code{f} taken. Initializing the pointer changes the type to the normal record
type.

If the field \code{f} is initialized ``on demand'', i.e., not at a statical point in the program, this solution is not possible.
The main problem here is that it must be possible to determine at runtime whether \code{f} is initialized or not. So simply
allocating a ``dummy'' to get a valid pointer is not sufficient, it must also be possible to recognize the dummy pointer.

One possibility for this is if the data structure referenced by the pointer has a field value which never occurs for a valid
pointer. Then it can be used to mark the pointer as dummy.

Another possibility is to use a single dummy pointer for all values of a specific linear type which can be null and store it 
in a seperate place for comparing it. However, this cannot be done in Cogent since the dummy pointer would be a shared linear 
value. Even if implemened in antiquoted C through abstract functions, to prove memory safety every access to such a value must 
be guarded with a test for the dummy pointer. Thus it is easier to actually use the null pointer instead of the dummy pointer,
in combination with a guard testing for the null pointer, resulting in a solution which is binary compatible with the C 
implementation.

A straightforward approach uses abstract functions
\begin{verbatim}
  null_T: () -> T
  ronull_T: () -> T!
  isNull_T: T! -> Bool
\end{verbatim}
to work with the null pointer. To dispose it the function \code{dispose\_T} must also check for the null pointer and ignore
invocations for it. The existence of the function \code{null\_T} makes it necessary to guard all accesses to values of type
\code{T} and \code{T!} with the help of \code{isNull\_T}. The function \code{ronull\_T} is required to initialize record fields 
of readonly type. This cannot be done by applying the bang operator to the result of \code{null\_T} since then the value
cannot escape the banged context. The existence of the function \code{ronull\_T} makes it necessary to guard
all accesses to values of type \code{T!}, the values of type \code{T} need not be guarded since a readonly value can never be 
made modifyable again. Therefore Gencot does not automatically define the functions for all 
linear types \code{T}.

A safer approach replaces type \code{T} by an abstract type and uses type \code{T} only in places where a value has been checked
for not being null. The abstract type must be specific for \code{T} and it must be complemented with abstract functions for
generating and testing the null pointer. Gencot provides the following generic abstract data type in \code{include/gencot/MayNull.cogent}:
\begin{verbatim}
  type MayNull a 
  null:      all(a). () -> MayNull a
  roNull:    all(a). () -> (MayNull a)!
  mayNull:   all(a). a -> MayNull a
  roMayNull: all(a). a! -> (MayNull a)!
  notNull:   all(a). MayNull a -> Option a
  roNotNull: all(a). (MayNull a)! -> (Option a)!
  isNull:    all(a). (MayNull a)! -> Bool
  modifyNull: all(a,b:<DS). ModPartFun (MayNull a) a b
\end{verbatim}
The function \code{notNull} returns \code{None} if the argument is null and \code{Some x} if the argument \code{x} is not null.
Since it is the only function which makes the value available as type \code{a} it is guaranteed that all accesses to the value
are guarded. The function \code{roNotNull} does the same for a readonly argument. The function \code{modifyNull} is a 
modification function according to Section~\ref{app-trans-modify} which treats the non-null pointer as a part of the 
arbitrary pointer. It modifies the object referenced by the non-null pointer if it is present and otherwise does nothing.

It may seem to be an alternative approach to avoid arbitrary access to the null pointer by using it always bound to the struct field \code{f}
with an abstract function of the following form instead:
\begin{verbatim}
  isNull_f: R -> Bool
\end{verbatim}
where \code{R} is the type of the struct containing field \code{f}. The null value would be inserted in the initialization 
function which transforms the result of \code{create\_R} from type \code{R take (..)} to type \code{R}. However, the null 
pointer can still be accessed by taking it from the record, so this is no improvement.

A null pointer can also be used as an ``error'' or ``escape'' value for function parameters or results. If the function is
invoked from Cogent to C code or vice versa, a binary compatible solution is required. Again, the type \code{MayNull} can
be used here.

A typical pattern in C is a guarded access to a member of a struct referenced by a pointer:
\begin{verbatim}
  if (p != NULL) res = p->m;
\end{verbatim}
In Cogent the value \code{p} has type \code{MayNull R} where \code{R} is the record type with field \code{m}. 
Then a translation may be
\begin{verbatim}
  let res = roNotNull p 
            | None -> dflt
            | Some s -> s.m
      !p
\end{verbatim}
Note that a value \code{dflt} must be selected here to bind it to res if the pointer is \code{NULL}. Also note that the access is
done in a banged context for p. Therefore it is only possible if the type of \code{m} is not linear, since otherwise the result
cannot escape from the context.

Another typical pattern in C is a guarded modification of the referenced structure:
\begin{verbatim}
  if (p != NULL) p->m = v;
\end{verbatim}
A translation to Cogent may be
\begin{verbatim}
  let p' = notNull p 
           | None -> p
           | Some s -> mayNull s{m = v}
\end{verbatim}
where the reference to the modified structure is bound to \code{p'}. Alternatively this can be translated using the modification
framework from Section~\ref{app-trans-modify}:
\begin{verbatim}
  let p' = modifyNull (p, (putMInP, v))
\end{verbatim}
where the function used for modifying the structure is defined as
\begin{verbatim}
  putMInP: ModFun P M
  putMInP (s,v) = s{m = v}
\end{verbatim}
and \code{M} is the type of field \code{m}.

\subsection{The Address Operator \code{\&}}
\label{app-trans-addrop}

The address operator \code{\&} is used in C to determine a pointer to data which is not yet accessed through a 
pointer. The main use cases are
\begin{itemize}
\item determine a pointer to a local or global variable as in the example
\begin{verbatim}
  int i = 5;
  int *ptr = &i;
\end{verbatim}

\item determine a pointer to a member in a struct as in the example
\begin{verbatim}
  struct ii { int i1; int i2; } s = {17,4};
  int *ptr = &(s.i2);
\end{verbatim}

\item determine a pointer to an array elemnt as in the example
\begin{verbatim}
  int arr[20];
  int *ptr = &(arr[5]);
\end{verbatim}

determine a pointer to a function as in the example
\begin{verbatim}
  int f(int p) { return p+1; }
  ...
  int *ptr = &f;
\end{verbatim}
\end{itemize}

In all these cases the pointer is typically used as reference to pass it to other functions or store it
in a data structure.

The binary compatible Cogent equivalent of the pointer is a value of a linear type. However, there is
no Cogent functionality to create such values. Hence it must be implemented by an abstract function.

\subsubsection{Address of Variable}

In the first use case there are several problems with this approach. First, there is no true equivalent
for C variables in Cogent. Second, it is not possible to pass the variable to the implementation of the
abstract function, without first determining its address using the address operator. Third, if the address
operator is applied to the variable in the implementation of the abstract function, the Isabelle c-parser
will not be able to process the abstract function, since it only supports the address operator when 
the result is a heap address.

All these problems can be solved by allocating the variable on the heap instead. Then the variable definition
must be replaced by a call to the (abstract) creation function for the corresponding linear type 
(see Section~\ref{design-types-pointer}) and 
at the end of its scope a call to the (abstract) dispose function must be added. Then the address
operator need not be translated, since the creation function already returns the linear value which can be 
used for the same purposes. The resulting Cogent code would be
\begin{verbatim}
  let ptr = create[P_U32] () {cont = 5}
  in dispose (...ptr...)
\end{verbatim}
where the argument of \code{dispose} is an expression which uses and returns the \code{ptr} in the 
usual way for a value of linear type.

\subsubsection{Address of Struct Member}

The second use case cannot be translated in this way, since the referenced data is a part of a larger structure.
If it is separated from the structure and allocated on the heap, the structure is not binary compatible any more.

If the overall structure is not allocated on the heap, the same three problems apply as in the first use case.
This can be solved in the same way, by moving the overall structure to the heap. Then it can be represented
by the linear Cogent type
\begin{verbatim}
  type Struct_Cogent_ii = { i1: U32, i2: U32 }
\end{verbatim}

If the overall structure in Cogent is readonly an abstract function of the form
\begin{verbatim}
  accessI2InCogent_ii : Struct_Cogent_ii! -> P_U32!
\end{verbatim}
can be used to access the Cogent field through a pointer. It returns the field as readonly, thus it is safe 
since neither the field nor the structure can be modified.

If the overall structure is modifyable, determining a pointer to the field would introduce sharing for the
field, since it can be modified through the pointer or by modifying the structure. There are several possible
approaches in this case.

A straighforward approach uses two abstract functions
\begin{verbatim}
  take_i2 : Struct_Cogent_ii -> (P_U32, Struct_Cogent_ii take i2)
  put_i2 : (P_U32, Struct_Cogent_ii take i2) -> Struct_Cogent_ii
\end{verbatim}
The implementation of \code{take\_i2} allocates a new copy of field \code{i2} on the heap
and return this heap pointer as first result component. The implementation of \code{put\_i2} copies the 
value back from the heap and frees the heap entry. Then no sharing can occur and the program has the 
same type safety properties as a usual Cogent program. However, the copying makes it less efficient.

An alternative implementation of \code{take\_i2} would apply the address operator to the field \code{i2} of 
its argument and return it together with the argument. Then \code{put\_i2} would do nothing and simply 
return the record. Since the record returned by \code{take\_i2} has field \code{i2} taken, it
cannot be accessed as long as the type has not been changed to the full record type again, which should be 
done by \code{put\_i2}, discarding the pointer. However, it is possible to apply any other explicit \code{put}
operation which writes the field \code{i2} while the pointer still exists, causing the shared content to
be overwritten. To prevent this it must be proven for the Cogent program that no \code{put} operation for field 
\code{i2} is applied to the result of \code{take\_i2} until it is restored by \code{put\_i2}. This implies that
for proving the type safety properties an arbitrary complex part of the Cogent program must be taken into
account.

A better approach is to combine the pseudo take and put operations in a single abstract modification function according
to the modification framework described in Section~\ref{app-trans-modify}:
\begin{verbatim}
  modifyI2InCogent_ii : all(a). 
    ModPartFun Struct_Cogent_ii P_U32 a
\end{verbatim}
The function expects as arguments the record to be modified, a field modification function and the additional argument
of type \code{a} for the field modification function. The field modification function
returns the pointer to the modified field, thus it does not discard it and can be fully implemented in Cogent.

If the record field is an unboxed record with type \code{\#R}, the type of the pointer to the field has the boxed record
type \code{R} in all cases above. If the record field is an array of type \code{\#UA'n'\_El} the pointer to the field
has the corresponding array type \code{A'n'\_El} (see Section~\ref{design-types-array}.

An alternative definition could be
\begin{verbatim}
  modifyI2InCogent_ii : all(a). 
    ModPartFun Struct_Cogent_ii P_U32
               ((Struct_Cogent_ii take i2)!,a)
\end{verbatim}
Here in addition to the value of type \code{a} the field modification function gets the remaining structure as input.
The remaining structure can be required for working on 
field \code{i2}. It is passed with field \code{i2} taken, so no sharing occurs in the field modification function. Additionally,
it is passed as readonly, so no other value can be put into field \code{i2} in the field modification function.

There could be more complex cases of working with a structure through pointers to fields. The field modification function could
take an additional argument where it returns information, then an additional type variable \code{b} would be required
which is escapable. The field modification function could modify several record fields at the same time, then for every such field
a pointer is passed to it. This complexity is the reason why Gencot does not generate according definitions automatically.

\subsubsection{Address of Array Element}

The third use case is similar to the second. It often occurs if the array itself is represented by a pointer to its first
element (see Section~\ref{app-trans-arrpoint}). This case can simply be replaced by using the element index instead of a 
pointer to the element. The array index is nonlinear and thus easier to work with. However, this solution is not binary
compatible, if the element pointer is also accessed outside the Cogent compilation unit.

A binary compatible solution can be achieved in a similar way as for struct members. The first prerequisite for it is
to allocate the array on the heap.

Then the polymorphic functions \code{arrAccess} and \code{arrModify} (see Section~\ref{design-types-array}) can be used
for working with pointers to elements.

The type of \code{arrModify} is similar to a \code{ModPartFun}, but it differs because in addition to the element modification 
function and its argument the element index must be passed as argument.
As for the struct member the element modification function takes an additional information as argument, which can be
used as input for the modification. Other than for the struct member it cannot get the remaining array as additional input,
since the type of an array with a specific element ``taken'' cannot be expressed in Cogent. Note that it is not possible
to pass the array or parts of it as additional information in the parameter of type \code{a}, since that would always be
a second use of the array of linear type. If several elements must be modified together, a specific modification function
must be defined and used instead of \code{arrModify}.

\subsubsection{Address of Function}

The last use case is translated in a specific way for function pointers, using the translation function
\code{to\_F\_...} (see Section~\ref{design-types-function}), which is generated by Gencot for all function
pointer types. The resulting Cogent code has the form
\begin{verbatim}
  Cogent_f : U32 -> _U32
  Cogent_f p = p+1
  ...
  let ptr = to_F_'U32'_U32 Cogent_f
  in ...
\end{verbatim}
In this case \code{ptr} has the nonlinear type \code{\#F\_'U32'\_U32} in Cogent and may freely be copied and
discarded in its scope.

\subsection{Using Pointers for Array Access}
\label{app-trans-arrpoint}

A common pattern in C programs is to explicitly use a pointer type instead of an array type for referencing an array,
in particular if the array is allocated on the heap. This is typically done if the number of elements in the
array is not statically known at compile time. The C concept of variable length array types can sometimes be
used for a similar purpose, but is restricted to function parameters and local variables and cannot be used for
structure members.

In C the array subscription operator can be applied to terms of pointer type. The semantics is to access an element 
in memory at the specified offset after the element referenced by the pointer. This makes it possible to use 
a pointer as struct member which references an array as in
\begin{verbatim}
  struct ip {... int *p, ...} s;
\end{verbatim}
and access the array elements using the subscription operator as in \code{s.p[i]}.

Gencot translates the struct type to a record type of the form
\begin{verbatim}
  type Struct_Cogent_ip = {... p: P_U32, ...}
\end{verbatim}
and does not generate abstract functions which allow to treat \code{p} as an array, this must be done manually.

The main problem here is the unknown array size. In the C program, however, for working with the array it must be
possible to determine the array size in some way at runtime. Here we distinguish two approaches how this is done.

In the first case the array size can always be determined from the array content. Then the pointer to the first 
element is always sufficient for working with the array. The two typical patterns of this kind either use a 
stop element to mark the array end, such as the zero character ending C strings, or store the array size in a
specific element or elements, such as in a network package represented as a byte array.

Working with the array is supported by manually defining and implementing an abstract data type for the array as follows.
Let \code{tt} be a unique name for the specific kind of array (how its size is determined) and let \code{El} be the
name of the array element type. We use \code{CArray\_tt\_El} as type name for the array, thus the 
type of \code{p} must be manually changed as follows:
\begin{verbatim}
  type Struct_Cogent_ip = {... p: CArray_tt_El, ...}
\end{verbatim}

For the type \code{CArray\_tt\_El} the polymorphic function \code{create} cannot be used since no instance has been
generated by Gencot for it. An abstract function of the form
\begin{verbatim}
  create_CArray_tt_El : UNN -> TCArray_tt_El
\end{verbatim}
must be defined and implemented manually. It takes the actual array size (number of elements) as argument. The type \code{UNN} must be
chosen by the developer so that it can represent all sizes which are used for the array. It is also used for the index
values below. The type 
\code{TCArray\_tt\_El} is used for the uninitialized array, corresponding abstract functions for initializing
and freeing the array elements must be provided.

The implementation in antiquoted C has the following form:
\begin{verbatim}
  typedef el *CArray_tt_El, *TCArray_tt_El;
  
  $ty:TCArray_tt_El $id:create_CArray_tt_El($ty:U32 size) { 
    return calloc(size,sizeof(el));
  }
\end{verbatim}

For disposing values of the array type the usual polymorphic function \code{dispose} can be used, its implementation in
antiquoted C automatically provides instances for all types for which it is used.




The element access functions are defined in the same way as for array types (see Section~\ref{design-types-array}. 
In the case of a non-linear element type they are:
\begin{verbatim}
  get_CArray_tt_El : (CArray_tt_El!,UNN) -> Option El
  put_CArray_tt_El : (CArray_tt_El,UNN,El) -> CArray_tt_El
\end{verbatim}
and for a linear element type:
\begin{verbatim}
  get_CArray_tt_El : (CArray_tt_El!,UNN) -> Option El!
  replacein_CArray_tt_El : 
        (CArray_tt_El,UNN,El) -> (CArray_tt_El,El)
\end{verbatim}
Functions for accessing the element through a pointer (see Section~\ref{app-trans-addrop}) are in both cases:
\begin{verbatim}
  access_CArray_tt_El : (CArray_tt_El!,UNN) -> Option P_El!
  modify_CArray_tt_El : all(a). ModFun CArray_tt_El (UNN,(P_El,a)->P_El, a)
\end{verbatim}

In the second case the array size is determined by additional information separate from the pointer to the array.
Either the size is specified as an integer value as in 
\begin{verbatim}
  struct ip {... int *p, int psize; ...} s;
\end{verbatim}
or it is specified by a second pointer, e.g., pointing to the last element as in
\begin{verbatim}
  struct ip {... int *p, int *pend; ...} s;
\end{verbatim}
In general there may be additional information, such as pointers into the array which are used to reference
``current'' positions in the array. We assume that all this information is provided by a sequence of members
in the surrounding struct:
\begin{verbatim}
  struct ip {...; t1 m1;...tn mn; ...} s;
\end{verbatim}
When working with the array all additional information is required, therefore it must be included in the abstract
type. This is achieved by replacing the sequence of variables containing information about the array by a single
field of the array type in Cogent:
\begin{verbatim}
  type Struct_Cogent_ip = {... a: #SArray_tt_El, ...}
\end{verbatim}
with the array type being defined in C as
\begin{verbatim}
  typedef struct { t1 m1;...tn mn; } SArray_tt_El;
\end{verbatim}
This makes the Cogent type \code{Struct\_Cogent\_ip} binary compatible with the C type \code{struct ip} and it allows
to represent several groups of related members in the struct by a common abstract type. Of course this approach is 
only possible if the members are contiguous in the struct.

To modify the group in the struct the abstract modification function 
\begin{verbatim}
  modifyAInStruct_Cogent_ip: all(a). 
    ModPartFun Struct_Cogent_ip SArray_tt_El 
               ((Struct_Cogent_ip take a)!,a)
\end{verbatim}
is used in the same way as described in Section~\ref{app-trans-addrop}.

The functions for working with the array now look different from those above, since type \code{SArray\_tt\_El}
does not correspond to a pointer to the array elements, but to a pointer to the substructure with members describing
the array. The specific form and functionality of these functions depend on the actual members and their use.

\subsection{Initializing and Clearing Values of Linear Type}
\label{app-trans-init}

As described in Section~\ref{design-types-struct} the function \code{create\_T} returns a record with all fields taken.
Before it can be used it must be initialized by putting values for all fields. Similarly, as described in 
Section~\ref{design-types-array} the function \code{create\_A'<size>'\_El} returns an 
unitialized array of type \code{TA'<size>'\_El} which must be initialized before it is used.
Dually, before disposing a record or an array the value must be cleared.

Gencot defines in \code{include/gencot/ModFun.cogent} the generic types
\begin{verbatim}
  type IniFun uni ini = uni -> ini
  type ClrFun ini uni = ini -> uni
\end{verbatim}
for functions which initialize or clear a value. An initialization function puts simple fixed values into the fields, 
a clearing function takes the fields and disposes all values of linear type. Therefore both do not require any additional 
information as input.

Gencot defines the preprocessor macros
\begin{verbatim}
  RECINIFUN(rectyp)
  RECCLRFUN(rectyp)
  ARRINIFUN(arrtyp)
  ARRCLRFUN(arrtyp)
\end{verbatim}
which generate the types for initialization and clearing function given a record or an array type. (They are implemented 
as preprocessor macros because they cannot be implemented as generic types in Cogent.)

Functions for initializing and clearing an array must be defined as abstract and implemented in antiquoted C. Functions
for initializing and clearing a record \code{r} of type \code{R} can be defined in Cogent by putting or taking values 
into/from all fields.

Putting values into fields of primitive type is straightforward. For fields of a boxed record type \code{S} a value can be created 
using the function \code{create\_S}, then applying an initialization function of type RECINIFUN(S) and putting the result into the field using the
Cogent put operation. For fields of a boxed abstract type it depends which abstract functions are available for creating and 
initializing values. For boxed array fields of type \code{A'<size>'\_El} the function \code{create\_A'<size>'\_El} can be used 
with an initialization function of type \code{ARRINIFUN(A'<size>'\_El)}. Fields of type \code{MayNull a} can be initialized by
putting \code{null[a]()}.

Fields of a readonly record type \code{S!} cannot be initialized according to this schema. If a value is created in the 
initialization function for \code{r} it must be banged there but then it may not leave the banged context. The readonly record must be created
outside and then passed to a banged context. The initialization of \code{r}, its use and its clearing must all happen inside
this context. To support this, the initialization functions must be extended to take as additional argument a tuple of all
values to be used for readonly fields. A simpler solution is to use type \code{(MayNull S)!} instead for the field and 
put the value \code{roNull[a]()} during initialization. Then a readonly non-null value can be set later in the corresponding
banged context. For fields of a readonly abstract type \code{S!} either an abstract function must be provided which returns
a readonly value without using an explicit banged context (which will cause problems for the refinement proof), or the type
\code{(MayNull S)!} is used as for the record type.

Another problem is how to initialize fields of unboxed types.

A field \code{f} with an unboxed record type \code{\#S} corresponds to an embedded struct in C. The space for this struct is allocated together
with the space for the surrounding struct by function \code{create\_T}. The initialization should be done by again using
an initialization function of type \code{RECINIFUN(S)}.

The most natural way of initializing an embedded struct would be in-place using a pointer to the embedded struct as described
in Section~\ref{app-trans-addrop}. But the function \code{modifyFInR} described there takes as argument a record of type \code{R}
where no field is taken, so it cannot be used to put the taken field \code{f} into the record. Separate modification functions
are required for the record with taken fields. If the record contains several embedded structs every modification function
puts one field and the result type has one field less taken. Thus, defining such modification functions imposes an order
in which the embedded structs must be initialized and whether they are initialized before or after the other fields. A corresponding
modification function for field \code{f} which must be initialized before field \code{g} but after all other fields would be
\begin{verbatim}
  putFInR : PUTFUN1(R,(g),f,RECINIFUN(S))
\end{verbatim}
where \code{PUTFUN1} is a macro instance for the type of modification functions which put a field, as described in 
Section~\ref{app-trans-modify}. It is invoked with the initialization function for the embedded record as additional information.
The implementation of \code{putFInR} in antiquoted C would simply apply the initialization function to a pointer to member 
\code{f} which is retrieved using the address operator \code{\&}.

A more flexible way would be to use the Cogent put operation. However, for field \code{f} it needs a value of type 
\code{\#S} which is not produced by \code{init\_S}. To bridge this gap we can use an abstract function
\begin{verbatim}
  deref_S : S -> #S
\end{verbatim}
which dereferences the argument pointer, and returns a copy of its content. Additionally it frees the pointer so that the
linear input value is safely disposed. (Note that the argument cannot be readonly to avoid freeing the pointer, since then
the result must also be readonly if it contains linear values.) Then the Cogent code to initialize the embedded struct 
\code{f} in a record \code{r} would be
\begin{verbatim}
  r { f = deref_S init_S create_S }
\end{verbatim}
It is not as efficient as in-place initialization, since it allocates a struct of type \code{S} on the heap, initializes it,
copies it to the embedded struct \code{f} and deallocates it.

Since both ways may be useful in certain contexts Gencot does not generate one or both of them, they must be provided manually.

Another approach could be that the function \code{create\_R} returns a value where only the fields of primitive and linear type
are taken and the embedded structs are present, but again with all primitive and linear fields taken. Then the function \code{init\_S}
could be directly applied to a pointer to field \code{f}. However, it is still necessary to retrieve the pointer to \code{f}
with the help of an abstract function which now has to respect the fact that other embedded struct fields have types with
some fields taken. So the same number of additional abstract functions is needed as in the approach above and their argument
types are of similar complexity.

Fields of an unboxed abstract type are created by Gencot only in the case of arrays and function pointers (see 
Section~\ref{design-types-array} and~\ref{design-types-function}). Initializing an embedded array field \code{f} of type 
\code{\#UA'<size>'\_El} can be done in-place or separate like an embedded struct field. In the first case an abstract
function of the form 
\begin{verbatim}
  putFInR : PUTFUN1(,(g),f,ARRINIFUN(A'<size>'_El))
\end{verbatim}
is required which uses an array initialization function and puts \code{f} while field \code{g} is still taken. 
In the second case an abstract function of the form
\begin{verbatim}
  deref_A'<size>'_El : A'<size>'_El -> #UA'<size>'_El
\end{verbatim}
is required which copies the array content and frees the array on the heap.

Initializing an array field \code{f} of a function pointer type \code{\#F\_...} can always be done using the Cogent put operation.
The value to be put must be constructed using the function \code{to\_F\_...} (see Section~\ref{design-types-function}). To
avoid null pointers to functions, as described in Section~\ref{app-trans-funpointer}, a dummy function should be defined in
Cogent and passed to the \code{to\_F\_...} function.

In a clearing function for a record all content shall be discarded. For fields of primitive and readonly type this is
straightforward by using the Cogent take operation and ignoring the taken value. For fields of linear type the taken value
cannot be simply discarded, it needs special treatment.

For a field of a boxed record type \code{S} the taken value must be disposed by applying the function \code{dispose\_S}.
For a field of a boxed abstract type it depends on the available abstract functions for disposing values. For a boxed
array of type \code{A'<size>'\_El} the function \code{dispose\_A'<size>'\_El} can be used. For a field of type
\code{MayNull S} the value must be tested whether it is null, otherwise the function \code{dispose\_S} must be used. In
all these cases a clearing function for type \code{S} must be applied first, so that the dispose-function is applicable.

A field of unboxed record type \code{\#S} is linear, if the embedded record contains linear fields. During clearing these must be
disposed. This can be achieved by applying a clearing function for type \code{S} before taking the field. Dually to the 
initialization of an embedded record this can be done in-place or using a copy. The in-place approach requires an abstract
function of the form
\begin{verbatim}
  takeFInR : TAKEFUN1(R,(g),f,RECCLRFUN(S))
\end{verbatim}
which applies a clearing function of type \code{RECCLRFUN(S)} and takes the field \code{f} while field \code{g} is already taken.
The other approach requires an abstract function 
\begin{verbatim}
  refer_S : #S -> S
\end{verbatim}
which allocates an object on the heap and stores the content of its argument into it. Then field \code{f} can be taken, the taken
value passed to \code{refer\_S}, and a clearing function applied to its result, before it is disposed.

A field of an unboxed abstract type is never linear, so the field can always be taken and the taken value discarded.
However, if the C implementation of the abstract type contains pointers, they must be deallocated. This can be achieved by
applying a clearing function in the same way as for an unboxed record field with the help of an abstract function
\code{takeFInR} or \code{refer\_S}.
