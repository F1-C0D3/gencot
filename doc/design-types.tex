
Here we define rules how to map common C types to binary compatible Cogent types. Since the usefulness of a mapping
also depends on the way how values of the type are processed in the C program, the resulting types may require manual 
modification.

For every mapped type Gencot also defines a dummy expression of that type. It is used as a replacement for the actual 
body when translating C functions (see Section~\ref{design-fundefs}).

\subsection{Numerical Types}
\label{design-types-prim}

The Cogent primitive types are mapped to C types in \code{cogent/lib/cogent-defns.h} which is included by the Cogent compiler
in every generated C file with \code{\#include <cogent-defns.h>}. The mappings are: 
\begin{verbatim}
  U8 -> unsigned char
  U16 -> unsigned short 
  U32 -> unsigned int
  U64 -> unsigned long long
  Bool -> struct bool_t { unsigned char boolean }
  String -> char*
\end{verbatim}
The inverse mapping can directly be used for the unsigned C types. For the corresponding signed C types to be binary
compatible, the same mapping is used. Differences only occur when negative values are actually used, this must be handled by using specific functions for numerical operations in Cogent.

In C all primitive types are numeric and are mapped by Gencot to a primitive type in Cogent. Note that in C the representation 
of numeric types may depend on the C version and target system architecture. However, the main goal of Gencot is only to generate
Cogent types which are, after translation to C, binary compatible with the original C types. Hence it is sufficient for the numerical 
types to simply invert the Mapping used by the Cogent compiler.

Together we have the following mappings:
\begin{verbatim}
char, unsigned/signed char -> U8
short, unsigned/signed short -> U16
int, unsigned/signed int -> U32
long int, unsigned/signed long int -> U64
long long int, unsigned/signed long long int -> U64
\end{verbatim}

The only mapping not determined by the Cogent compiler mapping is that for \code{long int}. For the gcc C version 
it depends on the architecture and is either the same as \code{int} (on 32 bit systems) or \code{lon long int}
(on 64 bit systems). Gencot assumes a 64 bit system and maps it like \code{long long int}.

The dummy expression used for all target types is the literal \code{0}.

\subsection{Enumeration Types}
\label{design-types-enum}

A C enumeration type of the form \code{enum e} is a subset of type \code{int} and declares enumeration 
constants which have type \code{int}. According to the C99 standard, an enumeration type may be implemented
by type \code{char} or any integer type large enough to hold all its enumeration constants.

A natural mapping for C enumeration types would be Cogent variant types. However, the C implementation
of a Cogent variant type is never binary compatible with an integer type (see below). 

Therefore C enumeration types must be mapped to a primitive integer type in Cogent. Depending on the C
implementation, this may always be type \code{U32} or it may depend on the value of the last enumeration
constant and be either \code{U8}, \code{U16}, \code{U32}, or maybe even \code{U64}. Under Linux, both cc
and gcc always use type \code{int}, independent of the value of the last enumeration constant. 
Therefore Gencot always maps enumeration types to Cogent type \code{U32}.

If an enumeration type has a tag, Gencot preserves the tag information for the programmer and uses
a type name of the form \code{Enum\_tag}, as described in Section~\ref{design-names}. For tagless enums
no type names are introduced, they are directly mapped to type \code{U32}.

The rules for mapping enumeration types are
\begin{verbatim}
  enum { ... } -> U32
  enum e { ... } -> Enum_e
  enum e -> Enum_e
\end{verbatim}

The enumeration constants must be mapped to Cogent constant definitions of the corresponding type. In 
C the value for an enumeration constant may be explicitly specified, this can easily be mapped to
the Cogent constant definitions.

An enumeration declaration of the form \code{enum e \{C1, C2, C3=5, C4\}} is translated as
\begin{verbatim}
  cogent_C1: U32
  cogent_C1 = 0
  cogent_C2: U32
  cogent_C2 = 1
  cogent_C3: U32
  cogent_C3 = 5
  cogent_C4: U32
  cogent_C4 = 6
\end{verbatim}
Note that the C constant names are mapped to Cogent names as described in Section~\ref{design-names}.

The dummy expression for all mapped enumeration types is the literal \code{0}.

\subsection{Structure and Union Types}
\label{design-types-struct}

A C structure type of the form \code{struct \{ ... \}} is equivalent to a Cogent unboxed record type \code{\#\{ ... \}}.
The Cogent compiler translates the unboxed record type to the C struct and maps all fields in the same order.
If every C field type is mapped to a binary compatible Cogent field type both types are binary compatible as a whole.

A C structure may contain bit-fields where the number of bits used for storing the field is explicitly specified.
Gencot maps every consecutive sequence of bit-fields to a single Cogent field with a primitive Cogent type.
The Cogent type is determined by the sum of the bits of the bit-fields in the sequence. It is the smallest 
type chosen from \code{U8, U16, U32, U64} which is large enough to hold this number of bits. 
***--> test whether this is correct.
The name of the
Cogent field is \code{cogent\_bitfield}<n> where <n> is the number of the bit-field sequence in the C structure.
Gencot does not generate Cogent code for accessing the single bit-fields. If needed this must be done manually in Cogent.
However, Gencot adds comments after the Cogent bitfield showing the original C bit-field declarations.

A C union type of the form \code{union \{ ... \}} is not binary compatible to any type generated by the Cogent compiler.
The semantic equivalent would be a Cogent variant type. However, the Cogent compiler translates every variant type
to a \code{struct} with a field for an \code{enum} covering the variants, and one field for every variant. Even if a variant
is empty (has no additional fields), in the C \code{struct} it is present with type \code{unit\_t} which
has the size of an \code{int}. Therefore Gencot maps every union type to an unboxed abstract Cogent type.

Together we have the mapping rules:
\begin{verbatim}
  struct s -> #Struct_s
  union s -> #Union_s
\end{verbatim}
where \code{Struct\_s} is the Cogent name of a record type corresponding to \code{struct s} and \code{Union\_s} is the
name of the abstract type introduced for \code{union s}.

As explained in Section~\ref{design-names}, Gencot always introduces a Cogent type name for each struct and union,
even if no tag is present in C. Since the tag name is either defined to name a Cogent record or an abstract type,
it is always linear and names a boxed type which corresponds to a pointer. Hence, the type name generated for a struct
is always used to refer to the type ``pointer to struct'', the struct type itself is translated to the type name 
with the unbox operator applied. The same holds for union types.

To be able to provide a dummy expression for mapped structure and union types, Gencot automatically defines an 
abstract function from the unit type to the target type:
\begin{verbatim}
  struct s -> dummy_Unbox_Struct_s: () -> #Struct_s
  union s -> dummy_Unbox_Union_s: () -> #Union_s
\end{verbatim}
Since the dummy expressions are intended to be eliminated before compiling the 
C code generated by the Cogent compiler, Gencot does not provide C definitions for these abstract functions. 

Then the dummy expression for type \code{\#Struct\_s} is \code{dummy\_Unbox\_Struct\_s ()} and analogously
for mapped union types. 

\subsection{Array Types}

A C array type \code{t[n]} has the semantics of a consecutive sequence of n instances of type \code{t}. 

Basically, Cogent does not support accessing elements by an index value in an array. 
This is an important security feature since the index value is computed at runtime and cannot be statically 
compared to the array length by the compiler. Therefore, a C array type can only be mapped to an abstract type 
in Cogent, which prevents accessing its elements in Cogent code. Element access must be implemented externally 
with the help of abstract functions.

The Cogent standard library includes three abstract data types for arrays (\code{Wordarray, Array, UArray}). 
However, they cannot be used as a binary compatible replacement for C arrays, because they are implemented by 
pointers to a \code{struct} containing the array length together with the pointer to the array elements. 
Only if the C array pointer is contained in such a struct, it is possible to use the abstract data types. 
In existing C code the array length is often present somewhere at runtime, but not in a single \code{struct}
directly before the array pointer.

As of December 2018 there is an experimental Cogent array type written \code{T[n]}. It is binary compatible 
with the C array type \code{t[n]}. It is not linear, however it only supports read access to the array elements, 
the element values cannot be replaced. Thus it can be used as replacement for a pure abstract type, if the array 
is never modified and if it does not contain any pointers (directly or indirectly). If it is modified, replacing
elements can be implemented externally with the help of abstract functions.

In C the incomplete type \code{t[]} can be used in certain places. It may be completed statically, e.g. 
when initialized. Then the number of elements is statically known and the type can be mapped like \code{t[n]}.
If the number of elements is not statically known the type cannot be mapped to a Cogent array, it must be mapped 
to an abstract type.

Since the Cogent array type is still under development, the current version of Gencot does not use it for
mapping C array types. Instead, all C array types are mapped to Cogent unboxed abstract types. The name of an 
abstract type always denotes a linear (boxed) type in Cogent. Therefore, as for struct and union types, for
every C array type a name is introduced to refer to the type ``pointer to array'', the array type itself is
translated to the type name with the unbox operator applied.

Instead of generating a new name for every C array type, Gencot uses a single generic type for all 
C array types. One advantage is that the element type need not be mapped to a type name, it may be mapped
to an arbitrary Cogent type expression (which is done for all function types). The generic type for
C arrays is assumed to be defined as
\begin{verbatim}
  type CArrayOf e
\end{verbatim}
A corresponding definition is always added to the file \code{<package>-exttypes.cogent} (see Section~\ref{design-files})
by Gencot.

Together we have the following mapping rule for C arrays with element type \code{el} (if not specified for a 
function parameter, see below):
\begin{verbatim}
  el[...] -> #CArrayOf El
\end{verbatim}
where El is the result of mapping the element type \code{el} to Cogent.

Since dummy expressions are only used for function results and the result type of a C function may not be an array 
type, Gencot does not define a C expression for mapped array types.

\subsection{Function Types}
\label{design-types-function}

C function types of the form \code{t (...)} are used in C only for declaring or defining functions. In all other
places they are either not allowed or automatically adjusted to the corresponding function pointer type
of the form \code{t (*)(...)}. 

In Cogent the distinction between function types and function pointer types does not exist. 
A Cogent function type of the form \code{T1 -> T2} is used both when
defining functions and when binding functions to variables. If used in a function definition, it is mapped by
the Cogent compiler to the corresponding C function type, when used in other places it is mapped to the 
corresponding C function pointer type.

Binary compatibility is only relevant when a function is stored, then it is always a function pointer. All function
pointers are of the same size, hence a C function pointer type can be mapped to an arbitrary Cogent function type.
Of course, to be useful the types of the parameters and result should be mapped as well. In Cogent every function
has only one parameter. To be mapped to Cogent, the parameters of a C function with more than one parameter must
be aggregated in a tuple or in a record. A C function type \code{t (void)} which has no parameters is mapped
to the Cogent function type \code{() -> T} with a parameter of unit type.

The difference between using a tuple or record for the function parameters is that the fields in a 
record are named, in a tuple they are not. In 
a C function definition the parameters may be omitted, otherwise they are specified with names in a prototype.
In C function types the names of some or all parameters may be omitted, specifying only the parameter type.

It would be tempting to map C function types to Cogent functions with a record as parameter, whenever parameter 
names are available in C, and use a tuple as parameter otherwise. However, in C it is possible to assign a 
pointer to a function which has been defined 
with parameter names to a variable where the type does not provide parameter names such as in 
\begin{verbatim}
  int add (int x, int y) {...}
  int (*fun)(int,int);
  fun = &add;
\end{verbatim}
This case would result in Cogent code with incompatible function types.

For this reason we always use a tuple as parameter type in Cogent. Cogent tuple types are equivalent, if they
have the same number of fields and the fields have equivalent types. To preserve the C parameter names in 
a function definition, the parameter is matched with a tuple pattern containing variables of these
names as fields.

C function types where the parameters are omitted, such as in \code{t ()} or where a variable number of
parameters is specified such as in \code{t (...)} cannot be mapped to a Cogent function type in this way. 
They can only be mapped using an abstract type as parameter type. This can again lead to incompatible 
Cogent types if a function pointer is assigned where parameters have been specified, these cases must 
be treated manually in specific ways. Gencot maps these function types to a Cogent function type with an abstract
parameter type.

Together the rules for mapping function types are
\begin{verbatim}
  t(t1, ..., tn), t (*)(t1, ..., tn) 
    -> (T1, ..., Tn) -> T
  t(void), t (*)(void) 
    -> () -> T
  t(), t(*)(), t(t1,...,tn,...), t (*)(t1,...,tn,...) 
    -> P -> T, where P is abstract
\end{verbatim}

The dummy expression for a function type is the lambda expression for the constant function returning the
dummy expression for the result type, i.e. the expression
\begin{verbatim}
  \_ => <dummy expression for the result type>
\end{verbatim}

\subsection{Pointer Types}

In general, a C pointer type \code{t*} is the kind of types targeted by Cogent linear types. The linear type 
allows the Cogent compiler to statically guarantee that pointer values will neither be duplicated nor 
discarded by Cogent code, it will always be passed through. 

If a pointer points to a C \code{struct} there is additional support for field access available in Cogent by 
mapping the pointer to a Cogent boxed record type. For all other pointer types the Cogent type must be abstract, 
then the pointer is opaque in Cogent code, it can only be passed around but no operations can be performed 
directly in Cogent. All processing must be implemented externally by an abstract data type.

A pointer to a function type is mapped in the same way as the function type, as described above.

A pointer type \code{t*} to a struct, union, or array type is mapped to the corresponding boxed type, that means, it is
mapped like type \code{t}, but the unbox operator is omitted.

The remaining cases are pointer types where \code{t} is a primitive type, an enum type, the type \code{void}, 
or again a pointer type. All these cases have no specific representation in Cogent and are mapped by Gencot 
to an abstract type. Similar as for arrays, Gencot uses a single generic abstract type for all such pointer 
types. It is assumed to be defined as
\begin{verbatim}
  type CPointerTo r
\end{verbatim}
A corresponding definition is always added to the file \code{<package>-exttypes.cogent} (see Section~\ref{design-files})
by Gencot.

In C, arrays of type \code{t[n]} can also be accessed through a Pointer of type \code{t*} using pointer
arithmetics. In this case type \code{t*} could be mapped as ``pointer to array of \code{t}''. However, this case
cannot be identified by only looking at the type, hence Gencot does not support it. In the other direction,
a type ``pointer to array of \code{t}'' could always be mapped as \code{t*}. However, this would discard 
information about the type and is not done by Gencot.

If a C array type \code{t[...]} is specified for a function parameter, it is ``adjusted'' by C to the pointer
type \code{t*} with the semantics of being a pointer to array of \code{t}. In this case Cogent maps the 
array type as pointer to array, which results in a type of the form \code{CArrayOf T} where \code{t} is 
mapped to \code{T}.

Together we have the mapping rules for pointer types:
\begin{verbatim}
  struct s * -> Struct_s
  union s * -> Union_s
  (*a)[...] -> CArrayOf A
  as parameter: a[...] -> CArrayOf A
  otherwise: t * -> CPointerTo T
\end{verbatim}
where \code{Struct\_s} and \code{Union\_s} are the names introduced for the struct or union types and \code{A} 
and \code{T} are the Cogent types to which \code{a} and \code{t} are mapped, respectively.

To be able to provide dummy expressions for pointer types, Gencot automatically defines an 
abstract function from the unit type to the pointer target type:
\begin{verbatim}
  struct s * -> dummy_Struct_s: () -> Struct_s
  union s * -> dummy_Union_s: () -> Union_s
  dummy_Array: all a. () -> CArrayOf a
  dummy_Pointer: all a. () -> CPointerTo a
\end{verbatim}
The functions \code{dummy\_Array} and \code{dummy\_Pointer} are polymorphic and are defined together with the 
types \code{CArrayOf} and \code{CPointerTo}. Again, as for structure and union types, Gencot does not 
provide C definitions for these abstract functions.

The dummy expression for type \code{Struct\_s} is \code{dummy\_Struct\_s ()} and analogously
for mapped union pointer types. The dummy expression for type \code{CArrayOf A} is 
\code{dummy\_Array[A] ()} and for type \code{CArrayOf A} it is \code{dummy\_Pointer[A] ()}.

\subsection{Defined Type Names}
\label{design-types-typedef}

In C a typedef can be used to define a name for every possible type. In principle, it would be possible to
map a typedef name by resolving it to its type and then mapping this type as described above. However, the
typedef name often bears information for the programmer, hence the goal for Gencot is to preserve this information
and map the typedef name to the corresponding Cogent type name which is defined by translating the typedef
to a Cogent type definition.

A typedef name can be used in C to derive a pointer type from it. The mapping of pointer types depends on 
the kind of base type, as described above. If the base type is a struct, union, or array type, the pointer 
type is mapped to its name omitting the unbox operator. Otherwise, the generic type \code{CPointerTo} is used.

Always mapping pointer types derived from typedef names with the help of \code{CPointerTo} would result in
the following situation for the case where a typedef name is defined for a struct:
\begin{verbatim}
  typedef struct s snam
  mapping: struct s -> #Struct_s
  mapping: struct s * -> Struct_s
  mapping: snam -> Cogent_snam
  mapping: snam * -> CPointerTo Cogent_snam
\end{verbatim}
where \code{Struct\_s} is the name of the Cogent record type corresponding to \code{struct s}. The problem here
is that \code{snam *} is mapped using \code{CPointerTo}, resolving to the Cogent type \code{CPointerTo \#Struct\_s}
instead of \code{Struct\_s}, preventing access to the record in Cogent.

Therefore Gencot treats every typedef name resolving to a struct, union, or array type as if it would resolve
to the corresponding pointer. The plain name is mapped with the unbox operator applied, the pointer type
derived from it is mapped without unbox operator applied. The resulting mapping rules are:
\begin{verbatim}
  tn -> #TN
  tn* -> TN
\end{verbatim}
where \code{TN} is the name mapping of \code{tn}.

For typedef names resolving to any other type the name is mapped directly:
\begin{verbatim}
  tn -> TN
\end{verbatim}

This implies, that also the Cogent type definitions generated from a C typedef have to be modified, if
the base type is a struct, union, or array type. In this case a typedef name for the base type is mapped
to a type name for the corresponding boxed type in Cogent. A name for the derived pointer type is mapped
in the same way. 

If the base type in a typedef is another typedef name which eventually resolves to a struct, union, or 
array type, typedef names for the base type and the derived pointer type are also treated in the same way, 
mapping them to alias names in Cogent.

The type referred to by a typedef name may be external to the Cogent compilation unit, then the typedef name
is translated to an abstract Cogent type. Then also the function for the dummy expression of the referred
type is not available. Therefore, Gencot automatically defines abstract functions for the unboxed and 
boxed type for every translated typedef name definition in the same way as for structure and union types.
If the target type name is \code{TN} the abstract function definition is
\begin{verbatim}
  dummy_TN: () -> TN
\end{verbatim}
and the dummy expression is \code{dummy\_TN ()}.

For a mapped struct or union type additionally the abstract function definition
\begin{verbatim}
  dummy_Unbox_TN: () -> #TN
\end{verbatim}
is generated. For an array type the unbox form is not generated because array types cannot occur as function 
result types.

Then the dummy expression for type \code{TN} is \code{dummy\_TN ()} or \code{dummy\_Unbox\_TN ()} if 
TN is a mapped struct or union type.

\subsection{Readonly Types}
\label{design-types-readonly}

% For a \code{const} qualified C structure type the fields may not be modified. This is equivalent to the behavior
% of an unboxed record in Cogent, the same mapping is used here.
% 
% For a \code{const} qualified C union type the fields may not be modified. This is equivalent to the behavior
% of all unboxed values in Cogent, the same mapping is used here.
% 
% An array of type \code{const t []} cannot be modified, hence it is fully supported by the corresponding 
% Cogent array type.
% 
% The primitive Cogent type \code{String} is mapped to C type \code{char*}. It is used to pass the usual 
% null terminated C strings through Cogent code. The characters in the string cannot be accessed in Cogent, 
% neither for replacing them nor for reading them. Thus, if the characters are not accessed, Cogent type
% \code{String} is a useful mapping for all kinds of C character arrays.
% 
% \begin{verbatim}
%   char[n], char[], unsigned char[n], unsigned char[], 
%      const char[n], const char[],
%      const unsigned char[n], const unsigned char[] -> String
%   char*, unsigned char*, const char*, const unsigned char* 
%      -> String, if used to access a C string
%   const el[n], const el[], const el* 
%      -> El[n], if n can be statically determined
%   const el[], const el* 
%      -> abstract type, if array size cannot be statically determined
%   el[n], el[], el* -> abstract type
%   const t* -> T[1], if t contains no pointers
% \end{verbatim}
% 
% For a C pointer there are two cases of readonly types. A ``pointer to const'' type of the form \code{const t*}
% means that the data structure pointed to cannot be modified, whereas the pointer itself can be replaced 
% (if, e.g., it is stored in a variable of that type). A ``constant pointer'' type of the form \code{t* const}
% instead means that the pointer itself cannot be modified, whereas the data structure pointed to can. In Cogent 
% no difference is made between the pointer and its target, both together are always immutable, which corresponds 
% to the combination of both C cases. However, for linear types, Cogent internally supports modification of the
% data structure using \code{put} and \code{take}. The Cogent readonly types prevent this, therefore they correspond
% to the first case in C. The second case is always respected by Cogent, if a pointer should be replaced, this 
% must be implemented by an adequate processing approach in Cogent. 
% 
% In C a \code{t*} pointer can be assigned to a \code{const t*} pointer, but not vice versa. This corresponds to
% the Cogent property that a linear value may be made readonly, but not the other way round.

