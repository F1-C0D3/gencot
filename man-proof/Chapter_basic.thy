theory Chapter_basic
  imports Chapter_intro
  "HOL-Library.Adhoc_Overloading"
  "HOL-Library.LaTeXsugar"
begin
chapter "Isabelle Basics"
text_raw\<open>\label{basic}\<close>

text \<open>
Isabelle is a ``proof assistant'' for formal mathematical proofs. It supports a notation for propositions and 
their proofs, it can check whether a proof is correct, and it can even help to find a proof.
\<close>

section "Invoking Isabelle"
text_raw\<open>\label{basic-invoke}\<close>

text \<open>
After installation, Isabelle can be invoked interactively as an editor for entering propositions and proofs,
or it can be invoked noninteractively to check a proof and generate a PDF document which displays the 
propositions and proofs.
\<close>

subsection "Installation and Configuration"
text_raw\<open>\label{basic-invoke-install}\<close>
text \<open>** todo **\<close>

subsection "Theories and Sessions"
text_raw\<open>\label{basic-invoke-theory}\<close>
text \<open>
The propositions and proofs in Isabelle notation are usually collected in ``theory files'' with names of the 
form \<^verbatim>\<open>name.thy\<close>. A theory file must import at least one other theory file to build upon its content. For theories
based on higher order logic (``HOL''), as it is the case for the Cogent shallow embedding, the usual starting point to
import is the theory @{theory Main}.

Several theory files can be grouped in a ``session''. A session is usually stored in a directory in the file system.
It consists of a file named \<^verbatim>\<open>ROOT\<close> which contains a specification of the session, and the theory files which
belong to the session.

When Isabelle loads a session it loads and checks all its theory files. Then it can generate a ``heap file'' for
the session which contains the processed session content. The heap file can be reloaded by Isabelle to avoid 
the time and effort for processing and checking the theory files.

A session always has a single parent session, with the exception of the Isabelle builtin session @{session Pure}.
Thus, every session depends on a linear sequence of ancestor sessions which begins at @{session Pure}. The ancestor 
sessions have separate heap files. A session is always loaded together with all ancestor sessions. 

Every session has a name of the form \<^verbatim>\<open>chap/sess\<close> where \<^verbatim>\<open>chap\<close> is an arbitrary ``chapter name'', it defaults to
\<^verbatim>\<open>Unsorted\<close>. The session name and the name of the parent session are specified in the \<^verbatim>\<open>ROOT\<close> file in the session
directory. When a session is loaded by Isabelle, its directory and the directories of all ancestor sessions must
be known by Isabelle.

Every session may be displayed in a ``session document''. This is a PDF document generated by translating the 
content of the session theory files to \LaTeX. A frame \LaTeX\ document must be provided which includes all content
generated from the theory files. The path of the frame document, whether a session document shall be generated and 
which theories shall be included is specified in the \<^verbatim>\<open>ROOT\<close> file.

The command
\begin{verbatim}
  isabelle mkroot [OPTIONS] [Directory]
\end{verbatim}
can be used to initialize the given directory (default is the current directory) as session directory. It creates
an initial \<^verbatim>\<open>ROOT\<close> file to be populated with theory file names and other specification for the session, and it
creates a simple frame \LaTeX\ document.
\<close>

subsection "Invocation as Editor"
text_raw\<open>\label{basic-invoke-edit}\<close>
text \<open>
Isabelle is invoked for editing using the command
\begin{verbatim}
  isabelle jedit [OPTIONS] [Files ...]
\end{verbatim}
It starts an interactive editor and opens the specified theory files. If no file is specified it opens the 
file \<^verbatim>\<open>Scratch.thy\<close> in the user's home directory. If that file does not exist, it is created as an empty file.

The editor also loads (but does not open) all transitively imported theory files. If these are Isabelle standard
theories it finds them automatically. If they belong to the session in the current directory it also finds them.
If they belong to other sessions, the option
\begin{verbatim}
  -d <directory pathname>
\end{verbatim}
must be used to make the session directory known to Isabelle. For every used session a separate option must be
specified. Also the directories of all ancestor sessions of the session the opened files belong to must be
specified using this option if they are not yet known to Isabelle. 

The option
\begin{verbatim}
  -l <session name>
\end{verbatim}
can be used to specify a session to load (together with all ancestor sessions) to use imported theories from it.
If a heap file exists for that session it is used, otherwise a heap file is created by loading all the session's 
theories.
\<close>

subsection "Invocation for Batch Processing"
text_raw\<open>\label{basic-invoke-build}\<close>
text \<open>
Isabelle is invoked for batch processing of all theory files in one or more sessions using the command
\begin{verbatim}
  isabelle build [OPTIONS] [Sessions ...]
\end{verbatim}
It loads all theory files of the specified sessions and checks the contained proofs. It also loads all required
ancestor sessions. If not know to Isabelle, the corresponding session directories must be specified using option
\<^verbatim>\<open>-d\<close> as described in Section~\ref{basic-invoke-edit}. Sessions required for other sessions are loaded from
heap files if existent, otherwise the corresponding theories are loaded and a heap file is created. 

If option \<^verbatim>\<open>-b\<close> is specified, heap files are also created for all sessions specified in the command. Option
\<^verbatim>\<open>-c\<close> clears the specified sessions (removes their heap files) before processing them. Option \<^verbatim>\<open>-n\<close> omits 
the actual session processing, together with option \<^verbatim>\<open>-c\<close> it can be used to simply clear the heap files.

The specified sessions are only processed if at least one of their theory files has changed since the last 
processing or if the session is cleared using option \<^verbatim>\<open>-c\<close>. If option \<^verbatim>\<open>-v\<close> is specified all loaded sessions
and all processed theories are listed on standard output.

If specified for a session in its \<^verbatim>\<open>ROOT\<close> file (see Section~\ref{basic-invoke-doc}), also the session document 
is generated when a session is processed.
\<close>

subsection "Invocation for Document Creation"
text_raw\<open>\label{basic-invoke-doc}\<close>
text \<open>** todo **\<close>

section "Isabelle Theories"
text_raw\<open>\label{basic-theory}\<close>

text \<open>
Remark: This document uses a pretty printed syntax for Isabelle theories. A major difference
to the actual source syntax is that underscores in names are displayed as hyphens (minus signs).
So for example the keyword displayed as \<^theory_text>\<open>type_synonym\<close> must be written \<^verbatim>\<open>type_synonym\<close> in the
theory source text.
\<close>

subsection "Theory Structure"
text_raw\<open>\label{basic-theory-structure}\<close>

text \<open>
The content of a theory file has the structure
@{theory_text[display]
\<open>theory name
imports name\<^sub>1 \<cdots> name\<^sub>n
begin
  \<cdots>
end\<close>}
where \<^theory_text>\<open>name\<close> is the theory name and \<^theory_text>\<open>name\<^sub>1 \<cdots> name\<^sub>n\<close> are the names of the imported theories.
The theory name \<^theory_text>\<open>name\<close> must be the same which is used for the theory file, i.e., the file name 
must be \<^verbatim>\<open>name.thy\<close>.

The theory structure is a part of the Isabelle ``outer syntax'' which is mainly fixed and independent
from the specific theories. Other kind of syntax is embedded into the outer syntax. The main embedded
syntax is the ``inner syntax'' which is mainly used to denote types and terms. Content in inner
syntax must always be surrounded by double quotes. Note that in the pretty printed forms in this document
these quotes are omitted.

Additionally, text written in \LaTeX\ syntax can be embedded into the outer syntax using the form
\<^theory_text>\<open>text\<open> \<cdots> \<close>\<close>
and \LaTeX\ sections can be created using
\<^theory_text>\<open>chapter\<open> \<cdots> \<close>\<close>, \<^theory_text>\<open>section\<open> \<cdots> \<close>\<close>, \<^theory_text>\<open>subsection\<open> \<cdots> \<close>\<close>, \<^theory_text>\<open>subsubsection\<open> \<cdots> \<close>\<close>, \<^theory_text>\<open>paragraph\<open> \<cdots> \<close>\<close>,
\<^theory_text>\<open>subparagraph\<open> \<cdots> \<close>\<close>.
Note that the delimiters used here are not the ``lower'' and ``greater'' symbols, but the ``cartouche
delimiters'' available in the jedit Symbols subwindow in tab ``Punctuation''.

It is also possible to embed inner and outer syntax in the \LaTeX\ syntax (see the Isabelle reference 
manuals).
\<close>

subsection "Types"
text_raw\<open>\label{basic-theory-types}\<close>

text \<open>
As usual in formal logics, the basic building blocks for propositions are terms. Terms denote arbitrary
objects like numbers, sets, functions, or boolean values. Isabelle is strongly typed, so every term 
must have a type. However, in most situations Isabelle can derive the type of a term automatically,
so that it needs not be specified explicitly. Terms and types are always denoted using the inner syntax.

Types are usually specified by type names. There are predefined type names such as \<open>nat\<close> and \<open>bool\<close>
for natural numbers and boolean values. New type names can be declared in the form
@{theory_text[display]
\<open>typedecl name\<close>}
which introduces the \<^theory_text>\<open>name\<close> for a new type for which the values are different from the values of all existing 
types (and no other information about the values is given). 

Types can be parameterized, then the type arguments are denoted \<^emph>\<open>before\<close> the type name, such as in
\<open>nat set\<close> which is the type of sets of natural numbers. A type name with \<open>n\<close> parameters is declared
in the form
@{theory_text[display]
\<open>typedecl ('name\<^sub>1,\<dots>,'name\<^sub>n) name\<close>}
such as \<^theory_text>\<open>typedecl ('a) set\<close>. Every use where the parameters are replaced by actual types, such 
as in \<open>nat set\<close>, is called an ``instance'' of the parameterized type.

Alternatively a type name can be introduced as a synonym for an existing type in the form
@{theory_text[display]
\<open>type_synonym name = type\<close>}
such as in \<^theory_text>\<open>type_synonym natset = nat set\<close>.
\<close>

subsection "Terms"
text_raw\<open>\label{basic-theory-terms}\<close>

subsubsection "Constants and Variables"

text \<open>
Terms are mainly built as syntactical structures based on constants and variables. Constants are usually
denoted by names, using the same namespace as type names. Whether a name denotes a constant or a 
type depends on its position in a term. Predefined constant names of type \<open>bool\<close> are \<open>True\<close> and 
\<open>False\<close>.

Constants of number types, such as \<open>nat\<close>, may also be denoted by number literals, such as \<open>6\<close>
or \<open>42\<close>.

A constant name can be introduced by declaring it together with its type. The declaration
@{theory_text[display]
\<open>consts name\<^sub>1 :: type\<^sub>1 \<cdots> name\<^sub>n :: type\<^sub>n\<close>}
declares \<open>n\<close> constant names with their types. Constant names declared in this way are 
``atomic'', no other information is given about them.

If the constant's type contains type variables the constant is called ``polymorphic''. Thus the 
declaration
@{theory_text[display]
\<open>consts myset :: "'a set"\<close>}
declares the polymorphic constant \<open>myset\<close> which may be a set of elements of arbitrary type.

A (term) variable has the same form as a constant name, but it has not been introduced as a 
constant. Whenever a variable is used in a term it has a specific type which is either derived 
from its context or is explicitly specified in the form \<open>varname :: type\<close>.
\<close>
 
subsubsection "Functions"

text \<open>
A constant name denotes an object, which, according to its type, may also be a function of 
arbitrary order. Functions basically
have a single argument. The type of a function is written as \<open>argtype \<Rightarrow> restype\<close>. The result type
of a function may again be a function type, then it may be applied to another argument. This is used
to represent functions with more than one argument. Function types are right associative, thus a 
type \<open>argtype\<^sub>1 \<Rightarrow> argtype\<^sub>2 \<Rightarrow> \<cdots> \<Rightarrow> argtype\<^sub>n \<Rightarrow> restype\<close> describes a function which can be applied 
to \<open>n\<close> arguments. 

Function application terms for a function \<open>f\<close> and an argument \<open>a\<close> are denoted by
\<open>f a\<close>, no parentheses are required around the argument. Function application terms are left 
associative, thus a function application to \<open>n\<close> arguments is written \<open>f a\<^sub>1 \<cdots> a\<^sub>n\<close>. Note that an
application \<open>f a\<^sub>1 \<cdots> a\<^sub>m\<close> where \<open>m < n\<close> (a ``partial application'') is a correct term and denotes a
function taking \<open>n-m\<close> arguments.

A constant name for a binary function can also be a symbol such as \<open>+\<close>, \<open>**\<close>, \<open>=\<close>, \<open>\<noteq>\<close>, \<open>\<le>\<close>, or \<open>\<in>\<close>
which is applied in infix notation, i.e., an application term is denoted in the form \<open>a\<^sub>1 + a\<^sub>2\<close>. 
For all infix symbols \<open>s\<close> the form \<open>op s\<close> can be used like a normal function name in prefix notation,
so an application of \<open>+\<close> can also be denoted by \<open>(op +) a\<^sub>1 a\<^sub>2\<close> and \<open>(op +) 5\<close> is a partial 
application and denotes the function which increments its argument by \<open>5\<close>.

Functions can be denoted by lambda terms of the form \<open>\<lambda>x.term\<close> where \<open>x\<close> is a variable
which may occur in the \<open>term\<close>. A function to be applied to \<open>n\<close> arguments can be denoted by the
lambda term \<open>\<lambda>x\<^sub>1 \<cdots> x\<^sub>n.term\<close> where \<open>x\<^sub>1 \<cdots> x\<^sub>n\<close> are distinct variables. As usual, types may be
specified for (some of) the variables in the form \<open>\<lambda>(x\<^sub>1::t\<^sub>1) \<cdots> (x\<^sub>n::t\<^sub>n).term\<close>.

Nested terms are generally written by using parentheses \<open>(\<dots>)\<close>. There are many priority rules how 
to nest terms automatically, but if in doubt, it is always safe to use parentheses.
\<close>

subsection "Definitions"
text_raw\<open>\label{basic-theory-definition}\<close>

text \<open>
Constant names can also be introduced as ``synonyms'' for terms. There are two forms for introducing
constant names in this way, definitions and abbreviations.

A definition introduces the name as a new entity in the logic, in the same way as a declaration.
A definition is denoted in the form
@{theory_text[display]
\<open>definition name :: type
where "name \<equiv> term"\<close>}
Note that the ``defining equation'' \<open>name \<equiv> term\<close> is specified in inner syntax and must be
delimited by quotes in the source text.

If the type of the defined name is a function type, the \<open>term\<close> may be a lambda term. Alternatively,
the definition for a function applicable to \<open>n\<close> arguments can be written in the form
@{theory_text[display]
\<open>definition name :: type
where "name x\<^sub>1 \<cdots> x\<^sub>n \<equiv> term"\<close>}
with variable names \<open>x\<^sub>1 \<cdots> x\<^sub>n\<close> which may occur in the \<open>term\<close>. This form is mainly equivalent to
@{theory_text[display]
\<open>definition name :: type
where "name \<equiv> \<lambda>x\<^sub>1 \<cdots> x\<^sub>n.term"\<close>}

A short form of a definition is
@{theory_text[display]
\<open>definition "name \<equiv> term"\<close>}
Here, the type of the new constant is derived as the type of the \<open>term\<close>.

An abbreviation introduces the name only as a syntactical item which is not known by the internal
logic system, upon input it is automatically expanded, and upon output it is used whenever a term
matches its specification and the term is not too complex. An abbreviation is denoted in a similar 
form as a definition:
@{theory_text[display]
\<open>abbreviation name :: type
where "name \<equiv> term"\<close>}
The alternative form for functions and the short form are also available as for definitions.
\<close>

subsection "Overloading"
text_raw\<open>\label{basic-theory-overload}\<close>

text \<open>
A declared constant name can be associated with a definition afterwards by overloading. Overloading
depends on the type. Therefore, if a constant name is polymorphic, different definitions
can be associated for different type instances.

A declared constant name \<open>name\<close> is associated with \<open>n\<close> definitions by the following overloading
specification:
@{theory_text[display]
\<open>overloading
  name\<^sub>1 \<equiv> name
    \<cdots>
  name\<^sub>n \<equiv> name
begin
  definition name\<^sub>1 :: type\<^sub>1 where \<cdots>
    \<cdots>
  definition name\<^sub>n :: type\<^sub>n where \<cdots>
end\<close>}
where all \<open>type\<^sub>i\<close> must be instances of the type declared for \<open>name\<close>.

There is also a form of overloading which is only performed on the syntactic level, like abbreviations.
To use it, the theory \<^theory>\<open>HOL-Library.Adhoc_Overloading\<close> must be imported by the surrounding
theory:
@{theory_text[display]
\<open>imports "HOL-Library.Adhoc_Overloading"\<close>}
Then constant \<open>name\<close> can be associated with \<open>n\<close> terms of different type instances by
@{theory_text[display]
\<open>adhoc_overloading name term\<^sub>1 \<cdots> term\<^sub>n\<close>}
Several names can be overloaded in a common specification:
@{theory_text[display]
\<open>adhoc_overloading name\<^sub>1 \<cdots> and \<cdots> and name\<^sub>k \<cdots>\<close>}
\<close>

subsection "Propositions"
text_raw\<open>\label{basic-theory-prop}\<close>

text \<open>
A proposition denotes a statement, which can be valid or not. Valid statements are called
``facts'', they are the main content of a theory.
\<close>
subsubsection "Simple Propositions"

text \<open>
In its simplest form a proposition is a single term of type \<open>bool\<close>, such as
@{text[display]
\<open>6 * 7 = 42\<close>}
Like terms, propositions are always written in inner syntax.

A proposition may contain free variables as in
@{text[display]
\<open>2 * x = x + x\<close>}

A simple proposition is valid if it evaluates to \<open>True\<close> for all possible values substituted
for the free variables.
\<close>

subsubsection "Derivation Rules"

text \<open>
More complex propositions can express, ``derivation rules'' used to derive propositions
from other propositions. Derivation rules are denoted using a ``meta logic language''. It is
still written in inner syntax but uses a small set of metalogic operators common to all possible
object logics in Isabelle. 

Derivation rules consist of assumptions and a conclusion. They can be written using the metalogic
operator \<open>\<Longrightarrow>\<close> in the form
@{text[display]
\<open>A\<^sub>1 \<Longrightarrow> \<cdots> \<Longrightarrow> A\<^sub>n \<Longrightarrow> C\<close>}
where the \<open>A\<^sub>1 \<cdots> A\<^sub>n\<close> are the assumptions and \<open>C\<close> is the conclusion, all of them are propositions.
A derivation rule states that if the assumptions are valid, the conclusion can be derived
as also being valid. So it can be viewed as a ``meta implication'' with a similar meaning as a 
boolean implication, but with a different use.

An example for a rule with a single assumption is
@{text[display]
\<open>(x::nat) < c \<Longrightarrow> n*x \<le> n*c\<close>}
Note that type \<open>nat\<close> is explicitly specified for variable \<open>x\<close>. This is necessary, because the
constants \<open><\<close>, \<open>*\<close>, and \<open>\<le>\<close> are overloaded and can be applied to other types than only natural
numbers. Therefore the type of \<open>x\<close> cannot be derived automatically. However, when the type of
\<open>x\<close> is known, the types of \<open>c\<close> and \<open>n\<close> can be derived to also be \<open>nat\<close>.

An example for a rule with two assumptions is
@{text[display]
\<open>(x::nat) < c \<Longrightarrow> n > 0 \<Longrightarrow> n*x < n*c\<close>}

In most cases the assumptions and the conclusion are terms of type \<open>bool\<close>, as in the example. 
However, they can also
be again derivation rules. Then the rule is a ``meta rule'' which derives a new rule from other 
rules. A derivation rule is valid if it has been derived from other valid rules. This manual
usually does not take meta rules into account.
\<close>

subsubsection "Binding Free Variables"

text \<open>
A proposition may contain universally bound variables, using the metalogic quantifier \<open>\<And>\<close> in the
form
@{text[display]
\<open>\<And> x\<^sub>1 \<cdots> x\<^sub>n. P\<close>}
where the \<open>x\<^sub>1 \<cdots> x\<^sub>n\<close> may occur free in the proposition \<open>P\<close>. As usual, types may be
specified for (some of) the variables in the form \<open>\<And> (x\<^sub>1::t\<^sub>1) \<cdots> (x\<^sub>n::t\<^sub>n).P\<close>. An example for
a valid derivation rule with bound variables is
@{text[display]
\<open>\<And> (x::nat) c n . x < c \<Longrightarrow> n*x \<le> n*c\<close>}

If a standalone proposition contains free variables they are implicitly universally bound. Thus
the example derivation rule above is equivalent to the single-assumption example rule in the 
previous section.
\<close>

subsubsection "Alternative Rule Syntax"

text \<open>
An alternative, Isabelle specific syntax for derivation rules is
@{text[display]
\<open>\<And> x\<^sub>1 \<cdots> x\<^sub>n. \<lbrakk>A\<^sub>1; \<cdots>; A\<^sub>n\<rbrakk> \<Longrightarrow> C\<close>}
which is often considered as more readable, because it better separates the assumptions from the
conclusion. In the Jedit editor it may be necessary to switch to this form by setting \<^verbatim>\<open>Print Mode\<close> 
to \<^verbatim>\<open>brackets\<close> in \<^verbatim>\<open>Plugin Options\<close> for \<^verbatim>\<open>Isabelle General\<close>.

Using this syntax the two-assumption example rule from the previous section is denoted by
@{text[display]
\<open>\<And> (x::nat) c n. \<lbrakk>x < c; n > 0\<rbrakk> \<Longrightarrow> n*x < n*c\<close>}
or equivalently without quantifier by
@{text[display]
\<open>\<lbrakk>(x::nat) < c; n > 0\<rbrakk> \<Longrightarrow> n*x < n*c\<close>}

Note that in the literature a derivation rule @{thm conjI[no_vars]} is often denoted in the form
@{thm[display,mode=Rule] conjI[no_vars]}

Another alternative, Isabelle specific syntax for a derivation rule 
\<open>\<And> x\<^sub>1 \<cdots> x\<^sub>n. \<lbrakk>A\<^sub>1; \<cdots>; A\<^sub>n\<rbrakk> \<Longrightarrow> C\<close> is the ``structured'' proposition 
@{text[display]
\<open>C if A\<^sub>1 and \<cdots> and A\<^sub>n for x\<^sub>1 \<cdots> x\<^sub>n\<close>}
Again, types can be specified for some variables in the usual form.
Note that the keywords \<open>if\<close>, \<open>and\<close>, \<open>for\<close> belong to the outer syntax. Thus, the original rule
must be quoted as a whole, whereas in the structured proposition only the sub-propositions
\<open>C\<close>, \<open>A\<^sub>1\<close>, \<dots>, \<open>A\<^sub>n\<close> must be individually quoted. The \<open>x\<^sub>1 \<cdots> x\<^sub>n\<close> need not be quoted, but if a
type is specified for a variable the type must be quoted, if it is not a single type name.

If written in this form, the two-assumption example rule from the previous subsections becomes
@{text[display]
\<open>"n*x < n*c" if "x < c" and "n > 0" for x::nat n c\<close>}
\<close>

subsection "Theorems"
text_raw\<open>\label{basic-theory-theorem}\<close>

text \<open>
A theorem specifies a proposition together with a proof, that the proposition is valid. Thus it
adds a fact to the enclosing theory. A simple form of a theorem is
@{theory_text[display]
\<open>theorem "prop" "proof"\<close>}
where \<open>prop\<close> is a proposition in inner syntax and \<open>proof\<close> is a proof as described in 
Section \ref{basic-proof}. The keyword \<^theory_text>\<open>theorem\<close> can be replaced by one of the keywords
\<^theory_text>\<open>lemma\<close>, \<^theory_text>\<open>corollary\<close>, \<^theory_text>\<open>proposition\<close> to give a hint about the use of the statement to
the reader.
\<close>

subsubsection "Unknowns"

text \<open>
Whenever a theorem turns a proposition to a fact, the free (or universally bound) variables
are replaced by ``unknowns''. For a variable \<open>name\<close> the corresponding unknown is \<open>?name\<close>.
This is only a technical difference, it signals to Isabelle that the unknowns can be 
consistently substituted by arbitrary terms, as long as the types are preserved.

When turned to a fact, the example rule from the previous sections becomes
@{text[display]
\<open>?x < ?c \<Longrightarrow> ?n*?x \<le> ?n*?c\<close>}
with type \<open>nat\<close> associated to all unknowns.

The result of such a substitution is always a special case of the fact and therefore also
a fact. In this way a fact with unknowns gives rise to a (usually infinite) number of facts
which are constructed by substituting unknowns by terms.

Isabelle can be configured to suppress the question mark when displaying unknowns, then
this technical difference becomes invisible.
\<close>

subsubsection "Named Facts"

text \<open>
Facts are often used in proofs of other facts. For this purpose they can be named so 
that they can be referenced by name. A named fact is specified by a theorem of the form
@{theory_text[display]
\<open>theorem name: "prop" "proof"\<close>}

The example rule from the previous sections can be turned into a fact named \<open>example1\<close> by
@{theory_text[display]
\<open>theorem example1: "(x::nat) < c \<Longrightarrow> n*x \<le> n*c" "proof"\<close>}

It is also possible to introduce named collections of facts. A simple way to introduce
such a named collection is 
@{theory_text[display]
\<open>lemmas name = name\<^sub>1 \<cdots> name\<^sub>n\<close>}
where \<open>name\<^sub>1 \<cdots> name\<^sub>n\<close> are names of existing facts or fact collections.

If there is a second rule stated as a named fact by
@{theory_text[display]
\<open>theorem example2: "(x::nat) \<le> c \<Longrightarrow> x + m \<le> c + m" "proof"\<close>}
a named collection can be introduced by
@{theory_text[display]
\<open>lemmas examples = example1 example2\<close>}

Alternatively a ``dynamic fact'' can be declared by
@{theory_text[display]
\<open>named_theorems name\<close>}
It can be used as a ``bucket'' where facts can be added afterwards by specifying the bucket
name in the theorem:
@{theory_text[display]
\<open>theorem [name]: "prop" "proof"\<close>}
or together with specifying a fixed fact name \<^theory_text>\<open>name\<^sub>f\<close> by
@{theory_text[display]
\<open>theorem name\<^sub>f[name]: "prop" "proof"\<close>}
\<close>

subsubsection "Alternative Theorem Syntax"

text \<open>
There is an alternative syntax for theorems which have a derivation rule as their proposition.
A theorem \<open>theorem "\<open>\<And> x\<^sub>1 \<cdots> x\<^sub>n. \<lbrakk>A\<^sub>1; \<cdots>; A\<^sub>n\<rbrakk> \<Longrightarrow> C\<close>" "proof"\<close> can also be specified in the form
@{theory_text[display]
\<open>theorem 
  fixes x\<^sub>1 and \<cdots> and x\<^sub>n 
  assumes A\<^sub>1 and \<cdots> and A\<^sub>n
  shows C
  "proof"\<close>}
Similar to the structured proposition form, the keywords belong to the outer syntax and the 
\<open>C\<close>, \<open>A\<^sub>1\<close>, \<dots>, \<open>A\<^sub>n\<close> must be individually quoted.

Using this syntax the two-assumption example rule from the previous sections can be written as
@{theory_text[display]
\<open>theorem 
  fixes x::nat and c and n 
  assumes "x < c" and "n > 0"
  shows "n*x < n*c"
  "proof"\<close>}

In contrast to the general theorem syntax this alternative syntax allows to specify names 
for some or all of the assumptions as
@{theory_text[display]
\<open>assumes name\<^sub>1: A\<^sub>1 and \<cdots> and name\<^sub>n: A\<^sub>n\<close>}
These names can (only) be used in the proof of the theorem. More consequences this syntax has
for the proof are described in Section~\ref{basic-proof}.

Note that a name specified for the conclusion as
@{theory_text[display]
\<open>shows name: C\<close>}
becomes the name for the whole fact introduced by the theorem, not only for the conclusion. It
is not available in the proof of the theorem.
\<close>

subsubsection "Definitions as Facts"

text \<open>
The definitions described in Section~\ref{basic-theory-definition} also introduce facts in
the enclosing theory. Every definition introduces a new constant and specifies a defining
equation of the form \<open>name \<equiv> term\<close> for it. This equation is a proposition using the ``meta
equality'' \<open>\<equiv>\<close> which is another metalogic operator. It is the initial information given for
the new constant, thus it is valid ``by definition'' and is a fact in the theory.

These facts are automatically named. If \<open>name\<close> is the name of the defined constant, the 
defining equation is named \<open>name_def\<close>. Alternatively an explicit name can be specified in 
the form
@{theory_text[display]
\<open>definition name :: type
where fact_name: "name \<equiv> term"\<close>}
\<close>

subsection "Locales"
text_raw\<open>\label{basic-theory-locale}\<close>

text \<open>
There are cases where theory content such as definitions and theorems occur which has similar 
structure but differs in some types or terms. Then it is useful to define a ``template'' and 
instantiate it several times. This can be done in Isabelle using a ``locale''.
\<close>

subsubsection "Simple Locales"

text \<open>
A locale can be seen as a parameterized theory fragment, where the parameters are terms. A locale
with \<open>n\<close> parameters is defined by
@{theory_text[display]
\<open>locale name = 
  fixes name\<^sub>1 :: type\<^sub>1 and \<cdots> and name\<^sub>n :: type\<^sub>n
begin
  \<cdots>
end\<close>}
where for each parameter its name and its type is specified. The content between \<^theory_text>\<open>begin\<close> and \<^theory_text>\<open>end\<close>
may consist of definitions and theorems which may use the parameter names like constant names. 
Content may also be added to an existing locale in the form 
@{theory_text[display]
\<open>context name
begin
  \<cdots>
end\<close>}
Therefore the \<^theory_text>\<open>begin \<cdots> end\<close> block can also be omitted in the locale definition and the locale can be
filled later.

An instance of the parameterized theory fragment is created by ``interpreting'' the locale in the form
@{theory_text[display]
\<open>interpretation name term\<^sub>1 \<cdots> term\<^sub>n .\<close>}
where \<open>term\<^sub>1 \<cdots> term\<^sub>n\<close> are the terms to be substituted for the locale parameters, their types must
match the parameter types, i.e., must be instances of them. The final dot in the interpretation
is a rudimentary proof. An actual proof is needed, if the locale definition specifies additional
assumptions for the parameters.
\<close>

subsubsection "Locales with Assumptions"

text \<open>
Additional assumptions for locale parameters can be specified as propositions in the form
@{theory_text[display]
\<open>locale name = 
  fixes name\<^sub>1 :: type\<^sub>1 and \<cdots> and name\<^sub>n :: type\<^sub>n
  assumes namp\<^sub>1: prop\<^sub>1 and \<cdots> and namp\<^sub>m: prop\<^sub>m
begin
  \<cdots>
end\<close>}
where \<open>namp\<^sub>1 \<cdots> namp\<^sub>m\<close> are names declared for the propositions \<open>prop\<^sub>1 \<cdots> prop\<^sub>m\<close>. They can be used to
reference the assumptions in proofs in the locale content. If the locale is interpreted, all the
assumptions must be proved with the actual terms substituted for the parameters. Therefore the more
general form of an interpretation is
@{theory_text[display]
\<open>interpretation name term\<^sub>1 \<cdots> term\<^sub>n "proof"\<close>}
\<close>

subsubsection "Extending Locales"

text \<open>
A locale can extend one or more other locales using the form
@{theory_text[display]
\<open>locale name = name\<^sub>1 + \<cdots> + name\<^sub>n +
  fixes \<cdots>
  assumes \<cdots>
begin
  \<cdots>
end\<close>}
where \<^theory_text>\<open>name\<^sub>1 \<cdots> name\<^sub>n\<close> are the names of the extended locales. Their parameters become parameters
of the defined locale, inserted before the parameters declared by the \<^theory_text>\<open>fixes \<cdots>\<close> clause.
\<close>

section "Isabelle Proofs"
text_raw\<open>\label{basic-proof}\<close>

text \<open>
Every proposition stated as a fact in an Isabelle theory must be proven
immediately by specifying a proof for it. A proof may have a complex structure of several steps 
and nested sub-proofs, its structure is part of the outer syntax.
\<close>

subsection "Proof Context"
text_raw\<open>\label{basic-proof-context}\<close>

text \<open>
Every proof is performed in a temporary environment which collects facts and other proof elements.
This environment is called the ``proof context''. At the end of the proof the proof context is
disposed with all its content, only the proven fact remains in the enclosing entity.

The proof context may contain
 \<^item> Facts: as usual, facts are valid propositions. However, they need not be globally valid, 
  they can be assumed to be only valid locally during the proof. 
 \<^item> Goals: a goal is a proposition which has not yet been proven. Typically it is the duty of
  a proof to prove one or more goals in its proof context.
 \<^item> Fixed variables: fixed variables are used to denote the ``arbitrary but fixed'' objects 
  often used in a proof. They can be used in all facts and goals in the same proof context.
 \<^item> Term abbreviations: these are names introduced locally for terms. Using such names for terms
  occurring in propositions it is often possible to denote facts in a more concise form.
\<close>

subsection "Proof Procedure"
text_raw\<open>\label{basic-proof-proc}\<close>

text \<open>
The basic procedure to build a proof for a rule \<open>A \<Longrightarrow> C\<close> is to construct a sequence of the form
\<open>A \<Longrightarrow> F\<^sub>1 \<Longrightarrow> \<cdots> \<Longrightarrow> F\<^sub>n \<Longrightarrow> C\<close> where \<open>A\<^sub>i \<Longrightarrow> C\<^sub>i\<close> for \<open>i=0\<dots>n\<close> are rules already known to be valid 
(i.e., facts) and \<open>A\<close> matches with \<open>A\<^sub>1\<close>, \<open>C\<^sub>n\<close> matches with \<open>C\<close> and every \<open>F\<^sub>i\<close> matches \<open>C\<^sub>i\<^sub>-\<^sub>1\<close> 
with \<open>A\<^sub>i\<close>.

The sequence can be constructed from left to right (called ``forward reasoning'') or from right 
to left (called ``backward reasoning'') or by a combination of both. 

Consider the rule \<open>(x::nat) < 5 \<Longrightarrow> 2*x+3 \<le> 2*5+3\<close>. A proof can be constructed from the two 
example rules \<open>example1\<close> and \<open>example2\<close> from the previous sections as the sequence
\<open>(x::nat) < 5 \<Longrightarrow> 2*x \<le> 2*5 \<Longrightarrow> 2*x+3 \<le> 2*5+3\<close>

Forward reasoning starts by assuming \<open>A\<close> to be a local fact and incrementally constructs the
sequence from it. An intermediate result is a part \<open>A \<Longrightarrow> F\<^sub>1 \<Longrightarrow> \<cdots> \<Longrightarrow> F\<^sub>i\<close> of
the sequence, here \<open>F\<^sub>i\<close> is the ``current fact''. A forward reasoning step consists of
stating a proposition \<open>F\<^sub>j\<close> and proving it to be a new local fact from the current fact \<open>F\<^sub>i\<close> 
by constructing a sequence \<open>F\<^sub>i \<Longrightarrow> \<cdots> \<Longrightarrow> F\<^sub>j\<close>. The step results in the extended sequence
\<open>A \<Longrightarrow> F\<^sub>1 \<Longrightarrow> \<cdots> \<Longrightarrow> F\<^sub>j\<close> and the new current fact \<open>F\<^sub>j\<close>. When a step successfully proves 
the conclusion \<open>C\<close> from the current fact \<open>F\<^sub>n\<close> the proof is complete.

Backward reasoning starts with \<open>C\<close> being the only goal and incrementally constructs the sequence
from it backwards. An intermediate result is a part \<open>F\<^sub>i \<Longrightarrow> \<cdots> \<Longrightarrow> F\<^sub>n \<Longrightarrow> C\<close> of the sequence,
here \<open>F\<^sub>i\<close> is the ``current goal''. A backward reasoning step consists of applying a proof
method to \<open>F\<^sub>i\<close> which constructs a new current goal \<open>F\<^sub>j\<close> and a sequence \<open>F\<^sub>j \<Longrightarrow> \<cdots> \<Longrightarrow> F\<^sub>i\<close>. The
step results in the extended sequence \<open>F\<^sub>j \<Longrightarrow> \<cdots> \<Longrightarrow> F\<^sub>n \<Longrightarrow> C\<close> and the new current goal. When
a step produces a new current goal which matches the assumption \<open>A\<close> the proof is complete.

Note the slight difference in how the steps are specified: A forward step specifies the 
new current fact \<open>F\<^sub>j\<close> and then proves it. A backward step specifies the proof method, the
new current goal \<open>F\<^sub>j\<close> is constructed by the method and is not an explicit part of the proof text.
For that reason a proof constructed by forward reasoning is usually easier to read and write
than a proof constructed by backward reasoning, since in the former case the sequence of the
facts \<open>F\<^sub>i\<close> is explicitly specified in the proof text, whereas in the latter case the sequence
of the goals \<open>F\<^sub>i\<close> is implicitly constructed and the proof text specifies only the methods.

However, since every forward reasoning step again requires a proof as its part (a ``subproof''), 
no proof can be written using only forward reasoning steps. The main idea of writing ``good''
proofs is to use forward reasoning until every subproof is simple enough to be done in a single
backward reasoning step, i.e., the proof method directly goes from the conclusion to the 
assumption.
\<close>

subsubsection "Unification"

text \<open>
The matching at the beginning and end of the sequence and when joining the used rules is done
by ``unification''. Two propositions \<open>P\<close> and \<open>Q\<close> are unified by substituting terms 
for unknowns in \<open>P\<close> and \<open>Q\<close> so that the results become syntactically equal.

Since only the \<open>A\<^sub>i \<Longrightarrow> C\<^sub>i\<close> are facts containing unknowns, only they are modified by the
unification, \<open>A\<close> and \<open>C\<close> remain unchanged. 

Note that when an unknown is substituted by a term in \<open>A\<^sub>i\<close>, the same unknown must be substituted 
by the same term in \<open>C\<^sub>i\<close> and vice versa, to preserve the validness of the rule \<open>A\<^sub>i \<Longrightarrow> C\<^sub>i\<close>. In
other words, the sequence is usually constructed from specializations of the facts \<open>A\<^sub>i \<Longrightarrow> C\<^sub>i\<close>
where every conclusion is syntactically equal to the assumption of the next rule.

In the example the assumption \<open>?x < ?c\<close> of rule \<open>example1\<close> is unified with \<open>(x::nat) < 5\<close> by 
substituting the term \<open>5\<close> for the unknown \<open>?c\<close>, and the variable \<open>x\<close> for the unknown \<open>?x\<close>
resulting in the specialized rule \<open>(x::nat) < 5 \<Rightarrow> n*x \<le> n*5\<close>.
The conclusion \<open>?x + ?m \<le> ?c + ?m\<close> of rule \<open>example2\<close> is unified with \<open>2*x+3 \<le> 2*5+3\<close> by 
substituting the term \<open>2*x\<close> for the unknown \<open>?x\<close>, the term \<open>2*5\<close> for the unknown \<open>?c\<close>, and the 
term \<open>3\<close> for the unknown \<open>?m\<close> resulting in the specialized rule 
\<open>"2*x \<le> 2*5 \<Longrightarrow> 2*x+3 \<le> 2*5+3\<close>. Now the two specialized rules can be joined by substituting
the term \<open>2\<close> for the unknown \<open>?n\<close> in the first.
\<close>

subsubsection "Multiple Assumptions"

text \<open>
If the rule to be proven has more than one assumption the sequence to be constructed becomes
a tree where the branches start at (copies of) the assumptions and merge to finally lead to 
the conclusion. 

Now a forward reasoning step may use several current facts to prove a new current fact.
Therefore all proven local facts are stored in the proof context for possible later use.
Every forward reasoning step selects a subset of the stored local facts as the current
facts and uses them to prove a new local fact.

A backward reasoning step may now produce several new current goals, which belong to different
branches in the tree. A step always produces the goals for all branches, therefore the 
previous goal is never used again in a step and is removed from the proof context after the
step. When a current goal unifies with an assumption the proof method ``assumption'' removes 
it from the goal state without producing a new goal. Thus a proof ends when no goal remains
in the proof context.

The set of current goals is called the ``goal state'' of the proof. Since it is not visible
in the proof text, the Jedit editor displays the current proof state in a separate window, 
according to the cursor position in the proof text.
\<close>

subsection "Proof Structure"
text_raw\<open>\label{basic-proof-struct}\<close>





lemma 
l1: "(x::nat) < c \<Longrightarrow> n*x \<le> n*c"
  by simp
lemma 
l2: "x < c \<Longrightarrow> x + m < c + m" for x :: nat
  by simp
lemma 
"x < 5 \<Longrightarrow> 2*x+3 \<le> 13" for x :: nat
  by simp


subsection "Goals"
text_raw\<open>\label{basic-proof-goal}\<close>

text \<open>
Goals are inserted in a proof context when the context is created. During the proof the goals 
are transformed by applying ``proof methods''. By applying a method a goal may be split into 
subgoals or it may be completely proven, then it is removed from the proof context. A proof
is finished if no goal remains in its context.

 Since it results from
the applied methods it is not directly visible in the proof text. 

A theorem of the form \<open>theorem "prop" "proof"\<close> inserts its proposition \<open>prop\<close> as the only goal
in the proof context of its \<open>proof\<close>. When the proof is finished \<open>prop\<close> becomes a fact in the
enclosing theory.
\<close>

subsection "Fixed Variables"
text_raw\<open>\label{basic-proof-fix}\<close>

text \<open>
Fixed variables 
\<close>

subsection "Facts"
text_raw\<open>\label{basic-proof-fact}\<close>

subsubsection "Assumed Facts"

subsubsection "Stated Facts"

subsection "Term Abbreviations"
text_raw\<open>\label{basic-proof-abbrev}\<close>


subsection "Fact Chaining"
text_raw\<open>\label{basic-proof-chain}\<close>





subsection "Proof Scripts"
text_raw\<open>\label{basic-proof-script}\<close>

text \<open>
One form of an Isabelle proof is a ``proof script''. It consists of a linear sequence of steps,
each step applies a ``proof method'' to one or more goals in the goal state. Depending on the 
goal state, a proof method may be applicable or not. If it is not applicable the step is marked as 
an error and is omitted from the proof script. If it is applicable it may modify goals, solve
goals (and remove them from the goal state), or create new goals.

A step has the form
@{theory_text[display]
\<open>apply method\<close>}
where \<open>method\<close> is an expression denoting the proof method applied by the step. A proof method can
be elementary or complex. An elementary proof method is denoted by a method name, optionally
followed by arguments. A complex method has one of the following forms:
 \<^item> \<open>m\<^sub>1, \<dots>, m\<^sub>n\<close> : a sequence of methods which are applied in their order,
 \<^item> \<open>m\<^sub>1; \<dots>; m\<^sub>n\<close> : a sequence of methods where each is applied to the goals created by the previous method,
 \<^item> \<open>m\<^sub>1| \<dots>| m\<^sub>n\<close> : a sequence of methods where only the first applicable method is applied,
 \<^item> \<open>m[n]\<close> : the method \<open>m\<close> is applied to the first \<open>n\<close> goals,
 \<^item> \<open>m?\<close> : the method \<open>m\<close> is applied if it is applicable,
 \<^item> \<open>m+\<close> : the method \<open>m\<close> is applied once and then repeated as long as it is applicable.

Parentheses are used to structure and nest complex methods.

The last step of a proof script must result in an empty goal state. After it the
proof script is terminated by a step of the form
@{theory_text[display]
\<open>done\<close>}
Alternatively a proof script may be terminated in an arbitrary goal state (even at the beginning)
by a step of the form
@{theory_text[display]
\<open>sorry\<close>}
This can be used to include statements which are not yet proved in a theory. However, such 
statements cannot be referenced and used in subsequent proofs.

The last step \<^theory_text>\<open>apply method\<close> together with the terminating \<^theory_text>\<open>done\<close> can be combined to
@{theory_text[display]
\<open>by method\<close>}
where this form additionally solves remaining goals which unify with assumptions and applies
a simple form of backtracking if the \<open>method\<close> can be applied in different ways to the goal state.
\<close>

subsection "Backward Reasoning"
text_raw\<open>\label{basic-proof-backward}\<close>

text \<open>
\<^item> Reasoning step
\<^item> conclusion unification
\<^item> rule with one assumption
\<^item> rule with several assumptions
\<^item> rule method
\<^item> rule\_tac method
\<^item> introduction rules
\<^item> intro method
\<close>

subsection "Forward Reasoning"
text_raw\<open>\label{basic-proof-forward}\<close>

text \<open>
\<^item> assumption unification
\<^item> assumption selection
\<^item> rotate method
\<^item> drule method
\<^item> drule\_tac method
\<^item> destruction rules
\<^item> erule method
\<^item> erule\_tac method
\<^item> elimination rules
\<close>

section "Isabelle HOL"
text_raw\<open>\label{basic-hol}\<close>

subsection "Meta Level Operators"
text_raw\<open>\label{basic-hol-meta}\<close>

text \<open>
\<^item> rewrite rules
\<^item> \<open>\<equiv>\<close>
\<^item> \<open>\<Longrightarrow>\<close>
\<close>

subsection "Logical Operators"
text_raw\<open>\label{basic-hol-logop}\<close>

text \<open>
\<^item> \<open>\<and>, \<or>, \<not>, \<longrightarrow>\<close>
\<^item> \<open>=, \<noteq>, \<longleftrightarrow>\<close>
\<^item> \<open>\<forall>, \<exists>\<close>
\<close>

subsection "Logic Rules"
text_raw\<open>\label{basic-hol-logrul}\<close>

text \<open>
\<^item> conjI, conjE, disjI1, disjI2, disjE, impI, mp
\<^item> contrapos\_*
\<^item> iffI, iffE, iffD1, iffD2
\<^item> allI, allE, exI, exE
\<close>

subsection "Equational Reasoning"
text_raw\<open>\label{basic-hol-equational}\<close>

text \<open>
\<^item> Equations, conditional equations
\<^item> Substitution
\<^item> subst method
\<^item> symmetric attribut
\<close>

subsection "The Simplifier"
text_raw\<open>\label{basic-hol-simp}\<close>

text \<open>
\<^item> simpset, simp attribute
\<^item> simp method
\<^item> add:, only:, del:
\<^item> simp\_all method
\<^item> recursive simplification for conditions
\<^item> simp trace
\<^item> debugging with subst
\<close>

end
