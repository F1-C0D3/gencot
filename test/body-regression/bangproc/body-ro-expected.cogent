-- Using values of readonly type.

-- Functions used as context:
cogent_fcln : CPtr U32 -> ()
cogent_fcln i = let _ = 0 in ()
cogent_fcro : (CPtr U32)! -> ()
cogent_fcro i = let _ = 0 in ()
-- Global variables used as context:
type GlobState1 =
   CPtr (CPtr U32)
type GlobState2 =
   CPtr ((CPtr U32)!)

-- struct probes:
type Struct_Cogent_ros1 = { mrg : U32, mro : (CPtr U32)!, mln : CPtr U32 }
type Struct_Cogent_ros2 = { sln : Struct_Cogent_ros1, sub : #Struct_Cogent_ros1 }

-- array probes:
type Cogent_roa1 = CArr5 U32 -- regular elements
type Cogent_roa2 =
   CArr5 ((CPtr U32)!) -- readonly elements
type Cogent_roa3 =
   CArr5 (CPtr U32) -- linear elements
type Cogent_roa4 =
   CArr5 #Cogent_roa1 -- array elements
type Cogent_roa5 =
   CArr5 #Cogent_roa2 -- array elements
type Cogent_roa6 =
   CArr5 #Cogent_roa3 -- array elements

-- Direct use of probe in context
cogent_f11ln : (CPtr U32)! -> ()
cogent_f11ln pro =
   let _ = let v' = let v' = cogent_fcln
         and v1' = pro
         and v' = v' (gencotDummy "Readonly expression used in linear context")
         in v'
      in 0
   in ()
cogent_f11ro : (CPtr U32)! -> ()
cogent_f11ro pro =
   let _ = let v' = let v' = cogent_fcro
         and v1' = pro
         and v' = v' v1'
         in v'
      in 0
   in ()
cogent_f12ln : () -> ()
cogent_f12ln () =
   let _ = let v' = let v' = cogent_fcln
         and v1' = cogent_glob ()
         and v' = v' (gencotDummy "Readonly expression used in linear context")
         in v'
      in 0
   in ()
cogent_f12ro : () -> ()
cogent_f12ro () =
   let _ = let v' = let v' = cogent_fcro
         and v1' = cogent_glob ()
         and v' = v' v1'
         in v'
      in 0
   in ()
cogent_f13ln : () -> ()
cogent_f13ln () =
   let _ = let v' = let v' = cogent_fcln
         and v1' = cogent_frro
         and v1' = v1' ()
         and v' = v' (gencotDummy "Readonly expression used in linear context")
         in v'
      in 0
   in ()
cogent_f13ro : () -> ()
cogent_f13ro () =
   let _ = let v' = let v' = cogent_fcro
         and v1' = cogent_frro
         and v1' = v1' ()
         and v' = v' v1'
         in v'
      in 0
   in ()
cogent_f14ln : ( (CPtr U32)!, (CPtr U32)!, U32 ) -> ()
cogent_f14ln (pro, qro, i) =
   let _ = let v' = let v' = cogent_fcln
         and v1' = i
         and v2' = pro
         and v3' = qro
         and v1' = if v1'
            then v2'
            else v3'
         and v' = v' (gencotDummy "Readonly expression used in linear context")
         in v'
      in 0
   in ()
cogent_f14ro : ( (CPtr U32)!, (CPtr U32)!, U32 ) -> ()
cogent_f14ro (pro, qro, i) =
   let _ = let v' = let v' = cogent_fcro
         and v1' = i
         and v2' = pro
         and v3' = qro
         and v1' = if v1'
            then v2'
            else v3'
         and v' = v' v1'
         in v'
      in 0
   in ()

-- Probe assigned to variable
cogent_f21ln : GlobState1 -> ( (), GlobState1 )
cogent_f21ln g =
   let (_, g) = let (v'
                    , g) = let v1' = cogent_frro
         and v1' = v1' ()
         and v' = g
         and g { cont = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', p0') = (v'
                         , gencotDummy "Readonly expression used in linear context")
         and g = g { cont = p0' }
         in (v', g)
      in (0, g)
   in ((), g)
cogent_f21ro : GlobState2 -> ( (), GlobState2 )
cogent_f21ro g =
   let (_, g) = let (v'
                    , g) = let v1' = cogent_frro
         and v1' = v1' ()
         and v' = g
         and g { cont = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', p0') = (v', v')
         and g = g { cont = p0' }
         in (v', g)
      in (0, g)
   in ((), g)
cogent_f22ln : CPtr U32 -> ( (), CPtr U32 )
cogent_f22ln pln =
   let (_, pln) = let (v'
                      , pln) = let v1' = cogent_frro
         and v1' = v1' ()
         and v' = pln
         and v' = v1'
         and (v', pln) = (v'
                         , gencotDummy "Readonly expression used in linear context")
         in (v', pln)
      in (0, pln)
   in ((), pln)
cogent_f22ro : (CPtr U32)! -> ()
cogent_f22ro pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = cogent_frro
         and v1' = v1' ()
         and v' = pro
         and v' = v1'
         and (v', pro) = (v', v')
         in (v', pro)
      in (0, pro)
   in ()

-- Probe returned as result
cogent_f31ln : () -> CPtr U32
cogent_f31ln () =
   let (_
       , r') = let v' = let v' = cogent_frro
         and v' = v' ()
         in v'
      in (3
         , gencotDummy "Readonly expression used in linear context")
   in r'
cogent_f31ro : () -> (CPtr U32)!
cogent_f31ro () =
   let (_
       , r') = let v' = let v' = cogent_frro
         and v' = v' ()
         in v'
      in (3, v')
   in r'

-- Probe used in conditional expression with other branch as context
cogent_f41ln : ( (CPtr U32)!, CPtr U32, U32 ) -> ( (), CPtr U32 )
cogent_f41ln (pro, qln, i) =
   let _ = (let v' = let v' = cogent_fcro
            and v1' = i
            and v2' = pro
            and v3' = qln
            and v1' = if v1'
               then v2'
               else v3'
            and v' = v' v1'
            in v'
         in 0) !qln
   in ((), qln)
cogent_f42ln : ( CPtr U32, (CPtr U32)!, U32 ) -> ( (), CPtr U32 )
cogent_f42ln (pln, qro, i) =
   let _ = (let v' = let v' = cogent_fcro
            and v1' = i
            and v2' = pln
            and v3' = qro
            and v1' = if v1'
               then v2'
               else v3'
            and v' = v' v1'
            in v'
         in 0) !pln
   in ((), pln)

-- Probe used by accessing a struct component
cogent_f51ln : Struct_Cogent_ros1! -> ()
cogent_f51ln pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = 5
         and v' = pro
         and pro { mrg = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', err') = (v', v')
         and pro = pro { mrg = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f51ro : Struct_Cogent_ros1! -> ()
cogent_f51ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = pro
         and pro { mrg = p0' } = v'
         and v' = p0'
         and pro = pro { mrg = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f52ln : Struct_Cogent_ros1! -> ()
cogent_f52ln pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = cogent_frro
         and v1' = v1' ()
         and v' = pro
         and pro { mro = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', err') = (v', v')
         and pro = pro { mro = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f52ro : Struct_Cogent_ros1! -> ()
cogent_f52ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = pro
         and pro { mro = p0' } = v'
         and v' = p0'
         and pro = pro { mro = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f53ln : Struct_Cogent_ros1! -> ()
cogent_f53ln pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = cogent_frln
         and v1' = v1' ()
         and v' = pro
         and pro { mln = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', err') = (v'
                          , gencotDummy "Linear expression used in readonly context")
         and pro = pro { mln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f53ro : Struct_Cogent_ros1! -> ()
cogent_f53ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = pro
         and pro { mln = p0' } = v'
         and v' = p0'
         and pro = pro { mln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f54ln : Struct_Cogent_ros1! -> ()
cogent_f54ln pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = 5
         and v' = pro
         and pro { mln = p0' } = v'
         and v' = p0'
         and p0' { cont = p1' } = v'
         and v' = p1'
         and v' = v1'
         and (v', err') = (v', v')
         and p0' = p0' { cont = p1' }
         and pro = pro { mln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f54ro : Struct_Cogent_ros1! -> ()
cogent_f54ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = pro
         and pro { mln = p0' } = v'
         and v' = p0'
         and p0' { cont = p1' } = v'
         and v' = p1'
         and p0' = p0' { cont = p1' }
         and pro = pro { mln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f55ln : Struct_Cogent_ros1! -> ()
cogent_f55ln pro =
   let (_, pro) = let (v'
                      , pro) = let v' = cogent_fcln
         and v1' = pro
         and pro { mln = p0' } = v1'
         and v1' = p0'
         and v' = v' (gencotDummy "Readonly expression used in linear context")
         and pro = pro { mln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f55ro : Struct_Cogent_ros1! -> ()
cogent_f55ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = cogent_fcro
         and v1' = pro
         and pro { mln = p0' } = v1'
         and v1' = p0'
         and v' = v' v1'
         and pro = pro { mln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f56ln : ( Struct_Cogent_ros1!, GlobState1 ) -> ( (), GlobState1 )
cogent_f56ln (pro, g) =
   let (_, g, pro) = let (v'
                         , g
                         , pro) = let v1' = pro
         and pro { mln = p1' } = v1'
         and v1' = p1'
         and v' = g
         and g { cont = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', p0') = (v'
                         , gencotDummy "Readonly expression used in linear context")
         and g = g { cont = p0' }
         and pro = pro { mln = p1' }
         in (v', g, pro)
      in (0, g, pro)
   in ((), g)
cogent_f56ro : ( Struct_Cogent_ros1!, GlobState2 ) -> ( (), GlobState2 )
cogent_f56ro (pro, g) =
   let (_, g, pro) = let (v'
                         , g
                         , pro) = let v1' = pro
         and pro { mln = p1' } = v1'
         and v1' = p1'
         and v' = g
         and g { cont = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', p0') = (v', v')
         and g = g { cont = p0' }
         and pro = pro { mln = p1' }
         in (v', g, pro)
      in (0, g, pro)
   in ((), g)
cogent_f57ln : ( Struct_Cogent_ros1!, CPtr U32 ) -> ( (), CPtr U32 )
cogent_f57ln (pro, pln) =
   let (_, pro, pln) = let (v'
                           , pro
                           , pln) = let v1' = pro
         and pro { mln = p0' } = v1'
         and v1' = p0'
         and v' = pln
         and v' = v1'
         and (v', pln) = (v'
                         , gencotDummy "Readonly expression used in linear context")
         and pro = pro { mln = p0' }
         in (v', pro, pln)
      in (0, pro, pln)
   in ((), pln)
cogent_f57ro : ( Struct_Cogent_ros1!, (CPtr U32)! ) -> ()
cogent_f57ro (pro, qro) =
   let (_, pro, qro) = let (v'
                           , pro
                           , qro) = let v1' = pro
         and pro { mln = p0' } = v1'
         and v1' = p0'
         and v' = qro
         and v' = v1'
         and (v', qro) = (v', v')
         and pro = pro { mln = p0' }
         in (v', pro, qro)
      in (0, pro, qro)
   in ()
cogent_f58ln : Struct_Cogent_ros1! -> CPtr U32
cogent_f58ln pro =
   let (_, r', pro) = let (v'
                          , pro) = let v' = pro
         and pro { mln = p0' } = v'
         and v' = p0'
         and pro = pro { mln = p0' }
         in (v', pro)
      in (3
         , gencotDummy "Readonly expression used in linear context"
         , pro)
   in r'
cogent_f58ro : Struct_Cogent_ros1! -> (CPtr U32)!
cogent_f58ro pro =
   let (_, r', pro) = let (v'
                          , pro) = let v' = pro
         and pro { mln = p0' } = v'
         and v' = p0'
         and pro = pro { mln = p0' }
         in (v', pro)
      in (3, v', pro)
   in r'
cogent_f59ln : ( Struct_Cogent_ros1!, CPtr U32, U32 ) -> ( (), CPtr U32 )
cogent_f59ln (pro, qln, i) =
   let (_, pro) = (let (v'
                       , pro) = let v' = cogent_fcro
            and v1' = i
            and v3' = gencotDummy "Necessary banging of qln leads to non-escapeable type"
               {- qln; -}
            and (v1', pro) = if v1'
               then let v2' = pro
                  and pro { mln = p0' } = v2'
                  and v2' = p0'
                  and pro = pro { mln = p0' }
                  in (v2', pro)
               else (v3', pro)
            and v' = v' v1'
            in (v', pro)
         in (0, pro)) !qln
   in ((), qln)
cogent_f59ro : ( Struct_Cogent_ros1!, (CPtr U32)!, U32 ) -> ()
cogent_f59ro (pro, qro, i) =
   let (_, pro) = let (v'
                      , pro) = let v' = cogent_fcro
         and v1' = i
         and v3' = qro
         and (v1', pro) = if v1'
            then let v2' = pro
               and pro { mln = p0' } = v2'
               and v2' = p0'
               and pro = pro { mln = p0' }
               in (v2', pro)
            else (v3', pro)
         and v' = v' v1'
         in (v', pro)
      in (0, pro)
   in ()

cogent_f61ln : Struct_Cogent_ros2! -> ()
cogent_f61ln pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = 5
         and v' = pro
         and pro { sln = p0' } = v'
         and v' = p0'
         and p0' { mrg = p1' } = v'
         and v' = p1'
         and v' = v1'
         and (v', err') = (v', v')
         and p0' = p0' { mrg = p1' }
         and pro = pro { sln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f61ro : Struct_Cogent_ros2! -> ()
cogent_f61ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = pro
         and pro { sln = p0' } = v'
         and v' = p0'
         and p0' { mrg = p1' } = v'
         and v' = p1'
         and p0' = p0' { mrg = p1' }
         and pro = pro { sln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f62ln : Struct_Cogent_ros2! -> ()
cogent_f62ln pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = cogent_frro
         and v1' = v1' ()
         and v' = pro
         and pro { sln = p0' } = v'
         and v' = p0'
         and p0' { mro = p1' } = v'
         and v' = p1'
         and v' = v1'
         and (v', err') = (v', v')
         and p0' = p0' { mro = p1' }
         and pro = pro { sln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f62ro : Struct_Cogent_ros2! -> ()
cogent_f62ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = pro
         and pro { sln = p0' } = v'
         and v' = p0'
         and p0' { mro = p1' } = v'
         and v' = p1'
         and p0' = p0' { mro = p1' }
         and pro = pro { sln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f63ln : Struct_Cogent_ros2! -> ()
cogent_f63ln pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = cogent_frln
         and v1' = v1' ()
         and v' = pro
         and pro { sln = p0' } = v'
         and v' = p0'
         and p0' { mln = p1' } = v'
         and v' = p1'
         and v' = v1'
         and (v', err') = (v'
                          , gencotDummy "Linear expression used in readonly context")
         and p0' = p0' { mln = p1' }
         and pro = pro { sln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f63ro : Struct_Cogent_ros2! -> ()
cogent_f63ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = pro
         and pro { sln = p0' } = v'
         and v' = p0'
         and p0' { mln = p1' } = v'
         and v' = p1'
         and p0' = p0' { mln = p1' }
         and pro = pro { sln = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f64ln : Struct_Cogent_ros2! -> ()
cogent_f64ln pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = cogent_frln
         and v1' = v1' ()
         and v' = pro
         and pro { sub = p0' } = v'
         and v' = p0'
         and p0' { mln = p1' } = v'
         and v' = p1'
         and v' = v1'
         and (v', err') = (v'
                          , gencotDummy "Linear expression used in readonly context")
         and p0' = p0' { mln = p1' }
         and pro = pro { sub = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f64ro : Struct_Cogent_ros2! -> ()
cogent_f64ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = pro
         and pro { sub = p0' } = v'
         and v' = p0'
         and p0' { mln = p1' } = v'
         and v' = p1'
         and p0' = p0' { mln = p1' }
         and pro = pro { sub = p0' }
         in (v', pro)
      in (0, pro)
   in ()

-- Probe used by accessing an array element
cogent_f71ln : Cogent_roa1! -> ()
cogent_f71ln pro =
   let (_, pro) = let (v'
                      , pro) = let v2' = 5
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and v' = v2'
         and (v', err') = (v', v')
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f71ro : Cogent_roa1! -> ()
cogent_f71ro pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f72ln : Cogent_roa2! -> ()
cogent_f72ln pro =
   let (_, pro) = let (v'
                      , pro) = let v2' = cogent_frro
         and v2' = v2' ()
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and v' = v2'
         and (v', err') = (v', v')
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f72ro : Cogent_roa2! -> ()
cogent_f72ro pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f73ln : Cogent_roa3! -> ()
cogent_f73ln pro =
   let (_, pro) = let (v'
                      , pro) = let v2' = cogent_frln
         and v2' = v2' ()
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and v' = v2'
         and (v', err') = (v'
                          , gencotDummy "Linear expression used in readonly context")
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f73ro : Cogent_roa3! -> ()
cogent_f73ro pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f74ln : Cogent_roa3! -> ()
cogent_f74ln pro =
   let (_, pro) = let (v'
                      , pro) = let v2' = 5
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and p0' { cont = p1' } = v'
         and v' = p1'
         and v' = v2'
         and (v', err') = (v', v')
         and p0' = p0' { cont = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f74ro : Cogent_roa3! -> ()
cogent_f74ro pro =
   let (_, pro) = let (v'
                      , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and p0' { cont = p1' } = v'
         and v' = p1'
         and p0' = p0' { cont = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f75ln : Cogent_roa3! -> ()
cogent_f75ln pro =
   let (_, pro) = let (v'
                      , pro) = let v' = cogent_fcln
         and v2' = 1
         and v1' = pro
         and (pro @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v1' = p0'
         and v' = v' (gencotDummy "Readonly expression used in linear context")
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f75ro : Cogent_roa3! -> ()
cogent_f75ro pro =
   let (_, pro) = let (v'
                      , pro) = let v' = cogent_fcro
         and v2' = 1
         and v1' = pro
         and (pro @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v1' = p0'
         and v' = v' v1'
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f76ln : ( Cogent_roa3!, GlobState1 ) -> ( (), GlobState1 )
cogent_f76ln (pro, g) =
   let (_, g, pro) = let (v'
                         , g
                         , pro) = let v2' = 1
         and v1' = pro
         and (pro @{ @v2' = p1' }
             , i1') = (v1', v2')
         and v1' = p1'
         and v' = g
         and g { cont = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', p0') = (v'
                         , gencotDummy "Readonly expression used in linear context")
         and g = g { cont = p0' }
         and pro = pro @{ @i1' = p1' }
         in (v', g, pro)
      in (0, g, pro)
   in ((), g)
cogent_f76ro : ( Cogent_roa3!, GlobState2 ) -> ( (), GlobState2 )
cogent_f76ro (pro, g) =
   let (_, g, pro) = let (v'
                         , g
                         , pro) = let v2' = 1
         and v1' = pro
         and (pro @{ @v2' = p1' }
             , i1') = (v1', v2')
         and v1' = p1'
         and v' = g
         and g { cont = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', p0') = (v', v')
         and g = g { cont = p0' }
         and pro = pro @{ @i1' = p1' }
         in (v', g, pro)
      in (0, g, pro)
   in ((), g)
cogent_f77ln : ( Cogent_roa3!, CPtr U32 ) -> ( (), CPtr U32 )
cogent_f77ln (pro, qln) =
   let (_, pro, qln) = let (v'
                           , pro
                           , qln) = let v2' = 1
         and v1' = pro
         and (pro @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v1' = p0'
         and v' = qln
         and v' = v1'
         and (v', qln) = (v'
                         , gencotDummy "Readonly expression used in linear context")
         and pro = pro @{ @i0' = p0' }
         in (v', pro, qln)
      in (0, pro, qln)
   in ((), qln)
cogent_f77ro : ( Cogent_roa3!, (CPtr U32)! ) -> ()
cogent_f77ro (pro, qro) =
   let (_, pro, qro) = let (v'
                           , pro
                           , qro) = let v2' = 1
         and v1' = pro
         and (pro @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v1' = p0'
         and v' = qro
         and v' = v1'
         and (v', qro) = (v', v')
         and pro = pro @{ @i0' = p0' }
         in (v', pro, qro)
      in (0, pro, qro)
   in ()
cogent_f78ln : Cogent_roa3! -> CPtr U32
cogent_f78ln pro =
   let (_, r', pro) = let (v'
                          , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (3
         , gencotDummy "Readonly expression used in linear context"
         , pro)
   in r'
cogent_f78ro : Cogent_roa3! -> (CPtr U32)!
cogent_f78ro pro =
   let (_, r', pro) = let (v'
                          , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (3, v', pro)
   in r'
cogent_f79ln : ( Cogent_roa3!, CPtr U32, U32 ) -> ( (), CPtr U32 )
cogent_f79ln (pro, qln, i) =
   let (_, pro) = (let (v'
                       , pro) = let v' = cogent_fcro
            and v1' = i
            and v4' = gencotDummy "Necessary banging of qln leads to non-escapeable type"
               {- qln; -}
            and (v1', pro) = if v1'
               then let v3' = 1
                  and v2' = pro
                  and (pro @{ @v3' = p0' }
                      , i0') = (v2', v3')
                  and v2' = p0'
                  and pro = pro @{ @i0' = p0' }
                  in (v2', pro)
               else (v4', pro)
            and v' = v' v1'
            in (v', pro)
         in (0, pro)) !qln
   in ((), qln)
cogent_f79ro : ( Cogent_roa3!, (CPtr U32)!, U32 ) -> ()
cogent_f79ro (pro, qro, i) =
   let (_, pro) = let (v'
                      , pro) = let v' = cogent_fcro
         and v1' = i
         and v4' = qro
         and (v1', pro) = if v1'
            then let v3' = 1
               and v2' = pro
               and (pro @{ @v3' = p0' }
                   , i0') = (v2', v3')
               and v2' = p0'
               and pro = pro @{ @i0' = p0' }
               in (v2', pro)
            else (v4', pro)
         and v' = v' v1'
         in (v', pro)
      in (0, pro)
   in ()

cogent_f81ln : Cogent_roa4! -> ()
cogent_f81ln pro =
   let (_, pro) = let (v'
                      , pro) = let v3' = 5
         and v2' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and (p0' @{ @v2' = p1' }
             , i1') = (v', v2')
         and v' = p1'
         and v' = v3'
         and (v', err') = (v', v')
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f81ro : Cogent_roa4! -> ()
cogent_f81ro pro =
   let (_, pro) = let (v'
                      , pro) = let v2' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and (p0' @{ @v2' = p1' }
             , i1') = (v', v2')
         and v' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f82ln : Cogent_roa5! -> ()
cogent_f82ln pro =
   let (_, pro) = let (v'
                      , pro) = let v3' = cogent_frro
         and v3' = v3' ()
         and v2' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and (p0' @{ @v2' = p1' }
             , i1') = (v', v2')
         and v' = p1'
         and v' = v3'
         and (v', err') = (v', v')
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f82ro : Cogent_roa5! -> ()
cogent_f82ro pro =
   let (_, pro) = let (v'
                      , pro) = let v2' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and (p0' @{ @v2' = p1' }
             , i1') = (v', v2')
         and v' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f83ln : Cogent_roa6! -> ()
cogent_f83ln pro =
   let (_, pro) = let (v'
                      , pro) = let v3' = cogent_frln
         and v3' = v3' ()
         and v2' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and (p0' @{ @v2' = p1' }
             , i1') = (v', v2')
         and v' = p1'
         and v' = v3'
         and (v', err') = (v'
                          , gencotDummy "Linear expression used in readonly context")
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()
cogent_f83ro : Cogent_roa6! -> ()
cogent_f83ro pro =
   let (_, pro) = let (v'
                      , pro) = let v2' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and (p0' @{ @v2' = p1' }
             , i1') = (v', v2')
         and v' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v', pro)
      in (0, pro)
   in ()

-- probe assigned to struct component or array element
cogent_f91ln : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_f91ln pln =
   let (_, pln) = let (v'
                      , pln) = let v1' = cogent_frro
         and v1' = v1' ()
         and v' = pln
         and pln { mln = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', p0') = (v'
                         , gencotDummy "Readonly expression used in linear context")
         and pln = pln { mln = p0' }
         in (v', pln)
      in (0, pln)
   in ((), pln)
cogent_f91ro : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_f91ro pln =
   let (_, pln) = let (v'
                      , pln) = let v1' = cogent_frro
         and v1' = v1' ()
         and v' = pln
         and pln { mro = p0' } = v'
         and v' = p0'
         and v' = v1'
         and (v', p0') = (v', v')
         and pln = pln { mro = p0' }
         in (v', pln)
      in (0, pln)
   in ((), pln)
cogent_f92ln : Cogent_roa3 -> ( (), Cogent_roa3 )
cogent_f92ln pln =
   let (_, pln) = let (v'
                      , pln) = let v2' = cogent_frro
         and v2' = v2' ()
         and v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and v' = v2'
         and (v', p0') = (v'
                         , gencotDummy "Readonly expression used in linear context")
         and pln = pln @{ @i0' = p0' }
         in (v', pln)
      in (0, pln)
   in ((), pln)
cogent_f92ro : Cogent_roa2 -> ( (), Cogent_roa2 )
cogent_f92ro pln =
   let (_, pln) = let (v'
                      , pln) = let v2' = cogent_frro
         and v2' = v2' ()
         and v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v' = p0'
         and v' = v2'
         and (v', p0') = (v', v')
         and pln = pln @{ @i0' = p0' }
         in (v', pln)
      in (0, pln)
   in ((), pln)
