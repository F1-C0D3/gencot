In some cases the mapped data type definitions generated by Gencot according to Section~\ref{design-types} must be manually
adapted by editing the corresponding \code{x-incl.cogent} files. Here we describe typical cases where an adaptation is
necessary.

\subsection{NULL Pointers}
\label{app-transtype-null}

If a linear value is used in the program at a place where in the C program it is not known to be non-null, it's type
must be changed from \code{T} to \code{(MayNull T)} (see Section~\ref{design-operations-null}).

A good hint for the property that a value may be null is if it is tested for being null in the C program. If not, however,
this case may have been overlooked. This will show up if the value's type is not changed and during the manual translation
of the function bodies an assignment of \code{NULL} must be translated for it.

A linear value may occur in the Cogent program as a function parameter, a function result, or a field in a record. In each case
all occurrences of the value must be analyzed to find out whether the type must be changed or not.

If the value is a field in a record the null pointer may be represented by the field being taken. This is possible when 
it is statically known for each occurrence of the record in the Cogent program, whether the field value is null or not. 
Then the type of the record can be changed to the type with the field taken for all cases where the field value is null.
A typical application case is when the field is initialized at a specific point in the program and never set to null
afterwards.

If the value is the parameter or result of a function pointer or the element of an array, or it is referenced by a pointer,
a type name must be introduced 
for the \code{MayNull} type instance and then used to consistently rename the type name generated by Gencot for the 
corresponding derived type. For example, if a C function pointer has type
\begin{verbatim}
  int (*)(some_struct *p)
\end{verbatim}
it is mapped by Gencot to have the abstract type
\begin{verbatim}
  F_XStruct_Cogent_some_structX_U32
\end{verbatim}
If parameter \code{p} may be null, its type should be changed to a new abstract type introduced by:
\begin{verbatim}
  type F_XMayNull_Cogent_some_structX_U32
  type MayNull_Cogent_some_struct = 
    MayNull Struct_Cogent_some_struct
\end{verbatim}

\subsection{Grouping Fields in a Record}
\label{app-transtype-group}

Sometimes in a C struct type several members work closely together by pointing to memory
shared among them. Then in Cogent it would be possible to take the corresponding record fields separately,
resulting in shared values of linear type. Instead, the fields should only be operated on by specific functions
for which the correct handling of the fields can be proven. To avoid taking the fields separately, these
functions should be defined on the record as a whole. Then it can be statically checked that the fields
are never accessed or taken/put outside these functions.

To make this more explicit, the corresponding record fields can be grouped into an embedded unboxed
record in Cogent. This is binary compatible if the members of the original struct are consecutive and in
the same order and are no bitfields. For example in the record type \code{R} as defined in 
\begin{verbatim}
  type A
  type R = {f1: A, f2: A, f3: A, f4: A, f5:A}
\end{verbatim}
the fields \code{f2} and \code{f3} can be grouped by introducing the new record type \code{E}:
\begin{verbatim}
  type A
  type E = {f2: A, f3: A}
  type R = {f1: A, embedded: #E, f4: A, f5:A}
\end{verbatim}
This is translated by Cogent to an embedded struct.

Now operations working on some or all of the grouped fields can be defined on the type \code{E} instead
of \code{R}, guaranteeing that the functions cannot access the other fields of \code{R}.

Note that it is still possible to take the fields separately by first taking \code{embedded} from \code{R}
and then taking the fields from the taken value. This can now be prevented by checking that the field
\code{embedded} is never accessed or taken/put directly in a value of type \code{R}.

Instead, using the conceptual operations \code{getref} and \code{modref} as defined in 
Section~\ref{design-operations-concept}
it is possible to apply the functions defined on \code{E} in-place without copying the field values.
This requires to manually define abstract functions
\begin{verbatim}
  getrefEmbeddedInR: R! -> E!
  modrefEmbeddedInR: all(arg,out). ModPartFun R E arg out
\end{verbatim}
together with type \code{E}. They are implemented in C using the address operator \code{\&} and should
be the only ways how to access the field \code{embedded}.

To provide even more shielding, the type \code{E} can be defined as abstract, providing the definition
as a struct in C:
\begin{verbatim}
  typedef struct {A f2; A f3; } E;
\end{verbatim}
Then it is guaranteed that the fields can never be accessed in the Cogent program. However, then also 
all function working on type \code{E} must be defined as abstract functions which are implemented in C.

\subsection{Using Pointers for Array Access}
\label{app-transtype-arrpoint}

A common pattern in C programs is to explicitly use a pointer type instead of an array type for referencing an array,
in particular if the array is allocated on the heap. This is typically done if the number of elements in the
array is not statically known at compile time. The C concept of variable length array types can sometimes be
used for a similar purpose, but is restricted to function parameters and local variables and cannot be used for
structure members.

In C the array subscription operator can be applied to terms of pointer type. The semantics is to access an element 
in memory at the specified offset after the element referenced by the pointer. This makes it possible to use 
a pointer as struct member which references an array as in
\begin{verbatim}
  struct ip {... int *p, ...} s;
\end{verbatim}
and access the array elements using the subscription operator as in \code{s.p[i]}.

Gencot translates the struct type to a record type of the form
\begin{verbatim}
  type Struct_Cogent_ip = {... p: P_U32, ...}
\end{verbatim}
and does not generate abstract functions which allow to treat \code{p} as an array, this must be done manually.

The main problem here is the unknown array size. In the C program, however, for working with the array it must be
possible to determine the array size in some way at runtime. Here we distinguish two approaches how this is done.

\subsubsection{Self-Descriptive Array}

In the first case the array size can always be determined from the array content. Then the pointer to the first 
element is always sufficient for working with the array. The two typical patterns of this kind either use a 
stop element to mark the array end, such as the zero character ending C strings, or store the array size in a
specific element or elements, such as in the header part of a network package represented as a byte array.

Working with the array is supported by manually defining and implementing an abstract data type for the array as follows.
Let \code{tt} be a unique name for the specific kind of array (how its size is determined) and let \code{El} be the
name of the array element type. We use \code{CArray\_tt\_El} as type name for the array, thus the 
type of \code{p} must be manually changed as follows:
\begin{verbatim}
  type Struct_Cogent_ip = {... p: CArray_tt_El, ...}
\end{verbatim}

For the type \code{CArray\_tt\_El} the polymorphic function \code{create} cannot be used since no instance has been
generated by Gencot for it. Moreover, when an array of this type is created, the size must be specified as an argument.
Hence an abstract function of the form
\begin{verbatim}
  create_CArray_tt_El : UNN -> TCArray_tt_El
\end{verbatim}
must be defined and implemented manually. It takes the actual array size (number of elements) as argument and is
implemented in C using \code{calloc} with the array size and the size of the element type. The type \code{UNN} must be
chosen by the developer so that it can represent all sizes which are used for the array. It is also used for the index
values below. The type \code{TCArray\_tt\_El} is used for the uninitialized array, corresponding abstract functions 
for initializing and freeing the array elements must be provided.

For disposing values of the array type the usual polymorphic function \code{dispose} can be used, its implementation in
antiquoted C automatically provides instances for all types for which it is used.

The element access functions for single elements should be defined as instances of the operations for accessing parts 
of structured values described in Section~\ref{design-operations-concept} in the specific form for arrays as described
in Section~\ref{design-operations-array}:
\begin{verbatim}
  getCArray_tt_El : (CArray_tt_El!,UNN) -> Option El!
  setCArray_tt_El : (CArray_tt_El,UNN,El) -> (CArray_tt_El,())
  exchngCArray_tt_El : (CArray_tt_El,UNN,El) -> (CArray_tt_El,El)
  modifyCArray_tt_El : all(arg:<D,out). 
    ModFun CArray_tt_El (UNN, ModFun El arg out, arg) out
  getrefCArray_tt_El : (CArray_tt_El!,UNN) -> Option P_El!
  modrefCArray_tt_El : all(arg:<D,out). 
    ModFun CArray_tt_El (UNN, ModFun P_El arg out, arg) out
\end{verbatim}

\subsubsection{Externally Described Arrays}

In the second case the array size is determined by additional information separate from the pointer to the array.
Either the size is specified as an integer value as in 
\begin{verbatim}
  struct ip {... int *p, int psize; ...} s;
\end{verbatim}
or it is specified by a second pointer, e.g., pointing to the last element as in
\begin{verbatim}
  struct ip {... int *p, int *pend; ...} s;
\end{verbatim}
In general there may be additional information, such as pointers into the array which are used to reference
``current'' positions in the array. We assume that all this information is provided by a sequence of members
in the surrounding struct:
\begin{verbatim}
  struct ip {...; t1 m1;...tn mn; ...} s;
\end{verbatim}

These members can be grouped into an embedded struct as described in Section~\ref{app-transtype-group}. If they
are consecutive and are grouped in the same order the modified record type should be binary compatible.
We propose to name the embedded record type \code{SArray\_tt\_El} (``structured array'') in analogy to the
array type name for self-descriptive arrays. It can either be defined as a record type in Cogent:
\begin{verbatim}
  type SArray_tt_El = { m1: T1, ... Mn: Tn }
\end{verbatim}
or, providing additional shielding as an abstract type with a C definition:
\begin{verbatim}
  typedef struct { t1 m1;...tn mn; } SArray_tt_El;
\end{verbatim}

Now the single fields in the original structure can be replaced by a field of the embedded structured array type:
\begin{verbatim}
  type Struct_Cogent_ip = {... a: #SArray_tt_El, ...}
\end{verbatim}

To access and modify the group in the struct the abstract functions
\begin{verbatim}
  getrefAInStruct_Cogent_ip: 
    Struct_Cogent_ip! -> SArray_tt_El!
  modrefAInStruct_Cogent_ip: all(arg,out). 
    ModPartFun Struct_Cogent_ip SArray_tt_El arg out 
\end{verbatim}
must be defined and used in the same way as described in Section~\ref{app-transtype-group}.

The element access functions for single elements can be defined as abstract instances of the operations for accessing parts 
in the same way as for self-descriptive arrays, although the implementations will differ because they have to 
take into account the fields of \code{SArray\_tt\_El}. Usually, additional functions will be required for working
with values of type \code{SArray\_tt\_El}, such as for moving an internal pointer to a ``current'' element.
If such a function modifies some of the fields of \code{SArray\_tt\_El} it must be defined as a modification function
which can be applied with the help of \code{modrefAInStruct\_Cogent\_ip}.
