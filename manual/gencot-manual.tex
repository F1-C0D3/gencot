\documentclass[a4paper]{report}
\usepackage[bookmarks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % needed for italic curly braces

\newcommand{\code}[1]{\textnormal{\texttt{#1}}}

\begin{document}

\title{Gencot User Manual}
\author{Gunnar Teege}

\maketitle

\chapter{Introduction}

Gencot (GENerating COgent Toolset) is a set of tools for generating Cogent code from C code. 

Gencot is used for parsing the C sources and generating Cogent sources, 
antiquoted C sources, and auxiliary C code. It does not perform a fully automatic translation, it is
intended to be used in combination with several manual steps of pre- and post-processing. These
steps are described in this manual.

The manual assumes that you are familiar with C and Cogent and know how to work with both.

\section{Rationale}
\label{intro-rationale}

Normally, Cogent is intended to implement from scratch a program which both compiles to a C implementation
and can be used as a high-level specification for formally verifying semantic properties.
Cogent generates a formal proof that the C implementation is a refinement of the high-level specification,
thus all proven semantic properties also hold for the C implementation.

Gencot is intended for the case where there already exists a legacy C implementation for a task. To apply
Cogent as described above, the task must be re-implemented in Cogent. Gencot supports this re-implementation 
by automatically translating several parts of the legacy C program to Cogent code. This should help developers 
to start with the re-implementation, especially if they have more experience in C programming than in Cogent.

However, Gencot does not provide the following:
\begin{itemize}
\item a guarantee, that the translation to Cogent is equivalent to the legacy C program. There is no formal
proof for such an equivalence and Gencot itself is not verified. Also, a part of the re-implementation must 
be done manually, so no automatic evidence can be provided. 

If you are lucky, there is a test suite for the legacy C program. Then you can apply the test suite to the 
Cogent re-implementation and get some evidence, that there is no difference in relevant behaviors. Even if
there is no test suite, building on the legacy C program should be easier and faster than to start the 
re-implementation from scratch. In any case, the formal verification starts at the Cogent program and does not 
extend to the legacy C program.

\item a guarantee that the translation to Cogent is type-safe and respects the constraints of the uniqueness
type system. Gencot translates the types as they are specified in the C program. It maps some memory safety
properties to the Cogent type system, but it does not make unsafe parts safe. In particular, if the legacy
C program shares and discards pointers, so will the translation to Cogent. 

The advantage is that the Cogent typechecker will statically detect all theses cases and signal them as an
error, so that the developer can concentrate on them. The Cogent program must then be refactored to avoid 
such cases, until it can be successfully processed by the Cogent compiler.

\item a guarantee that the translation to Cogent is useful for formally verifying the desired semantic properties. 
The Cogent program generated by Gencot has the same overall structure as the legacy C program. If this structure
is not adequate for formal proofs, e.g., because it massively depends on reading and modifying a global state,
the generated Cogent program (or the legacy C program) must be refactored to better support formal verification.
\end{itemize}

\section{Gencot Distribution}
\label{intro-dist}

The Gencot distribution consists of the following folders:
\begin{description}
\item[manual] this manual,
\item[bin] the main command scripts \code{gencot} and \code{parmod} and many auxiliary commands used by them,
\item[include] Cogent include files used by the generated code,
\item[c] C code implementing abstract types and functions used by the generated code,
\item[examples] example C programs used in this manual for introducing Gencot,
\item[src] the Haskell source code of Gencot components,
\item[doc] a comprehensive documentation of Gencot design and implementation.
\end{description}

Gencot is a command line tool. To use it make sure that you can invoke the commands \code{gencot}, \code{auxcog} and
\code{parmod} (e.g., by linking them in a folder in your command path or by adding the \code{bin} folder
of the Gencot distribution to your command path).

Additionally you have to set the environment variable \code{\$GENCOT\_HOME} to the root folder of the Gencot
distribution.

We also assume that you have a working distribution of Cogent and can invoke the cogent compiler using the
command \code{cogent}.

All example folders contain a UNIX Makefile. You can either run the examples by manually typing the commands
to process them or by using \code{make} with a separate target for each step.

\section{First Encounter}
\label{intro-first}

As usual we will start with a ``Hello World'' example. Go to \code{examples/helloworld}. Ignoring the other files,
look at \code{hello.c}. It contains the C program
\begin{verbatim}
  #include <stdio.h>

  int main() {
    puts("Hello World");
  }
\end{verbatim}

\begin{description}
\item[Step 1:] (make run)

Try it: compile the program with a C compiler, name it \code{hello} and run it. It should do what you expect.

\item[Step 2:] (make all-cogent)

Now use Gencot to translate the program to Cogent. Enter the command
\begin{verbatim}
  gencot cfile hello.c
\end{verbatim}
It creates the file \code{hello.cogent}. Look at it. It contains
\begin{verbatim}
  cogent_main : () -> U32
  cogent_main () =
     0
     {-
         cogent_puts("Hello World");
     -}
\end{verbatim}
This is a Cogent function corresponding to the C function \code{main}. However, the function body is still C code
and put in comment. Instead, the dummy result \code{0} is used, so the file is already valid Cogent code.

The command also creates the file \code{hello-entry.ac} (Not yet implemented! Provided with the example).

Next enter the command
\begin{verbatim}
  gencot unit all.unit
\end{verbatim}
It creates the file \code{all.cogent} and three files \code{all-externs.cogent}, \code{all-exttypes.cogent}, 
and \code{all-dvdtypes.cogent} where the latter two are empty and can be ignored for this example. File 
\code{all-externs.cogent} contains
\begin{verbatim}
  cogent_puts : (MayNull (CPtr U8))! -> U32
\end{verbatim}
which is also valid Cogent code, but uses the non-standard generic types \code{MayNull} and \code{CPtr}. File \code{all.cogent}
includes all generated Cogent files and is the main source file to be processed by the Cogent compiler.

The command also creates the file \code{all-externs.ac} (Not yet implemented! Provided with the example).

\item[Step 3:] (make all-edit)

Now comes the part where your manual work is demanded. You have to translate the function bodies and you have to adapt
some types. Open \code{hello.cogent} in a text editor, replace its content by
\begin{verbatim}
  cogent_main : () -> U32
  cogent_main () =
         cogent_puts("Hello World"); 0
\end{verbatim}
and save. In \code{all-externs.cogent} replace the argument type by \code{String}:
\begin{verbatim}
  cogent_puts : String -> U32
\end{verbatim}
and save.

Now you have a Cogent program which is equivalent to the original C program. It consists of several files,
which are all included by \code{all.cogent}.

\item[Step 4:] (make all-c)

To see that it works, process \code{all.cogent} by the Cogent compiler. Enter the command
\begin{verbatim}
  cogent -o all-gen -g all.cogent --infer-c-funcs="all-externs.ac hello-entry.ac"
\end{verbatim}
It creates the files \code{all-gen.c} and \code{all-gen.h} and two \code{\_pp\_inferred.c} files. 

Gencot is required to perform some postprocessing steps. Enter the command
\begin{verbatim}
  auxcog unit all.unit
\end{verbatim}
It creates the file \code{all.c} which includes \code{all-gen.c} and the other files generated by \code{auxcog}. It wraps together 
the C program generated from the Cogent program by the Cogent compiler and the Gencot postprocessing step.

\item[Step 5:] (make all-run)

Try whether it still works. Compile \code{all.c} with a C compiler, name it \code{cogent-hello} and run it. The result should be the same
as in Step 1.

Note that for the compilation you need to set the include path to the standard library folder of the Cogent 
distribution (\code{STDGUM} in the Makefile) and to the \code{c} directory in the Gencot distribution. The latter contains the files
\code{gencot.h} and \code{cogent-common.c} which are included by \code{all.c}

\item[Step 6:] (make clean)

Clean up all generated files. If you like you can perform the steps again.
\end{description}

\chapter{C Program Structure}

\section{Single Source File}
\label{struct-single}

The simplest case is a C program which consists of a single \code{.c} file, such as the ``Hello World'' program
introduced in Section~\ref{intro-first}. If the C file is named \code{foo.c} the command to process it by Gencot is
\begin{verbatim}
  gencot cfile foo.c
\end{verbatim}
It creates the following files:
\begin{description}
\item[\code{foo.cogent}] The content of \code{foo.c} translated to Cogent, as far as Gencot supports a translation.
Function bodies are not translated.
\item[\code{foo-entry.ac}] (*Not yet implemented*) ``Entry wrapper'' functions for all functions defined in \code{foo.c} 
with external linkage.
\end{description}

An ``entry wrapper'' converts from the original C function API to the Cogent function API, which is usually different 
since Cogent functions always take one argument and return one value. Functions in \code{foo.cogent} are automatically
renamed so that they do not collide with the entry wrappers after translation back to C by Cogent. For a standalone
C program there is atleast an entry wrapper \code{main} for the translated main program. Using the entry wrappers, all
translated C functions can still be invoked from a C program according to their original API.

Additionally, Gencot must be invoked using the command
\begin{verbatim}
  gencot unit all.unit
\end{verbatim}
where \code{all.unit} contains the name of the C source file (\code{"foo.c"}) in a single line. It creates the following
files:
\begin{description}
\item[\code{all-externs.cogent}] Abstract definitions of all external functions used by the C program.
\item[\code{all-exttypes.cogent}] Type definitions for all external types used by the C program.
\item[\code{all-dvdtypes.cogent}] Type definitions for all derived types used in the C program.
\item[\code{all-externs.ac}] (*Not yet implemented*) ``Exit wrapper'' functions for all functions defined in 
\code{all-externs.cogent}.
\item[\code{all.cogent}] The main Cogent source file which includes all other Cogent sources.
\end{description}
An external function is used by the C program if it is actually invoked. Such functions must be declared in C, usually
the declarations are contained in standard include files. In the ``Hello World'' example the file \code{hello.c} includes
\code{stdio.h} where function \code{puts} is declared. Here, Gencot reads \code{stdio.h} to generate the abstract definition for
\code{gencot\_puts} and the corresponding exit wrapper. Although there are many functions declared in \code{stdio.h}, Gencot
does not generate definitions for them, since they are not invoked by the C program.

An external type is a type defined in a standard include file. Again, Gencot provides a Cogent type definition in 
\code{all-exttypes.cogent} for only those 
types which are actually used by the C program. A derived type is a pointer type, an array type, or a function type in C. For 
some of them Gencot generates auxiliary type definitions in \code{all-dvdtypes.cogent}. In the ``Hello World'' example 
both files are empty.

An ``exit wrapper'' is similar to an ``entry wrapper'', it converts from the Cogent function API back to the C function API.
Exit wrappers are also renamed so that they do not collide with the originally invoked C function.

All generated files are named according to the name of the file argument to the \code{gencot} command. If the file is named 
\code{foo.unit} you will get \code{foo.cogent}, \code{foo-externs.cogent}, \code{foo-exttypes.cogent} etc.

\section{Single Source File with Include Files}
\label{struct-include}

Often, a C program consists of a \code{.c} file with function definitions and an included \code{.h} file for data type 
definitions. In this case Gencot must additionally be invoked for translating the \code{.h} file in the form
\begin{verbatim}
  gencot hfile foo.h
\end{verbatim}
It will create the additional file \code{foo-incl.cogent} which contains the translated content of \code{foo.h}. The 
include directive in \code{foo.c} will automatically be adapted, so that \code{foo.cogent} includes \code{foo-incl.cogent}.
So the resulting Cogent program has a similar source file structure as the C program.

If there are several \code{.h} files included by the \code{.c} file gencot must be invoked for every \code{.h} file
separately.

The other files are translated as before, however, the path must be specified where to look for the included files, even
if they are in the same directory. It is specified with an option \code{-I} as for \code{cpp}. Several such options may 
be specified if included files are in different directories. Include paths may be specified relative to the current 
directory. Do not append a slash \code{/} at the end. Paths for system include files cannot be specified, the \code{cpp} 
default is used for accessing them.

Together, the commands for translating the C program are
\begin{verbatim}
  gencot hfile foo.h
  ... <other .h files> ...
  gencot -I. cfile foo.c
  gencot -I. unit all.unit
\end{verbatim}
where \code{all.unit} still contains only the name \code{foo.c} and not \code{foo.h} (because that is automatically
read together with \code{foo.c} which includes it).

\subsection{Example}

The example program in \code{examples/cards} consists of the file \code{cards.c} and the included files \code{cards.h}
and \code{rank.h}. The translation step (\code{make all-cogent}) corresponds to the commands
\begin{verbatim}
  gencot hfile cards.h
  gencot hfile rank.h
  gencot -I. cfile cards.c
  gencot -I. unit all.unit
\end{verbatim}

Note that the function declarations in the \code{.h} files are not translated to Cogent. However, the comments specified 
there are moved to the function definitions in the translation of the \code{.c} file. This feature depends on the order of
processing the \code{.h} files before the \code{.c} file. Otherwise, the ordering of the commands is irrelevant.

\section{Multiple Source Files}
\label{struct-multi}

A larger C program often consists of several \code{.c} files. Every \code{.c} file is a separate translation unit and
must be translated by the C compiler to a seperate \code{.o} file. The \code{.o} files are then linked together to
yield the executable program binary.

To process such a program by Gencot every \code{.c} file must be processed on its own in the form
\begin{verbatim}
  gencot -I. cfile foo.c
\end{verbatim}
and yields a separate Cogent source file \code{foo.cogent}. All these translations together comprise a single
Cogent program which is compiled by the Cogent compiler in a single step and results in a single C compilation unit.

The file \code{all.unit} passed to \code{gencot unit} must now contain the names of all \code{.c} files, each in a 
separate line.

Together, the commands for translating the C program are
\begin{verbatim}
  gencot hfile foo.h
  ... <other .h files> ...
  gencot -I. cfile foo.c
  ... <other .c files> ...
  gencot -I. unit all.unit
\end{verbatim}
The generated file \code{all.cogent} includes all translations of \code{.c} files. As before, it is the 
file to be processed by the Cogent compiler.

\subsection{Example}

In the example program in \code{examples/cards2} the contents of \code{card.c} from \code{examples/cards} has been 
distributed to the three files \code{main.c}, \code{cards.c} and \code{rank.c}, which are listed in \code{all.unit}.
The translation step (\code{make all-cogent}) corresponds to the commands
\begin{verbatim}
  gencot hfile cards.h
  gencot hfile rank.h
  gencot -I. cfile cards.c
  gencot -I. cfile rank.c
  gencot -I. cfile main.c
  gencot -I. unit all.unit
\end{verbatim}
The resulting file \code{all.cogent} includes all three Cogent sources \code{cards.cogent}, \code{rank.cogent}, and
\code{main.cogent}.

The entry wrappers are now distributed in the same way to the three files \code{cards-entry.ac}, \code{rank-entry.ac},
and \code{main-entry.ac} (Not yet implemented! Provided with the example). All three must be specified now for the option
\code{--infer-c-funcs} in the Cogent compilation step (\code{make all-c}) and are included by the final C source
\code{all.c}.

\section{Partial Translation}
\label{struct-partial}

Gencot supports partially translating a C program to Cogent, if the C program consists of multiple \code{.c} source
files. In this case, some of the \code{.c} files are translated to Cogent and together yield a syntactically complete 
Cogent program. When translated back by the Cogent compiler it results in a single C compilation unit, which must be
linked with the remaining \code{.c} files to be executed.

In this way it is possible to incrementally translate a large C program to Cogent, starting with a single \code{.c} 
source and then extending it to more and more \code{.c} files until eventually all \code{.c} files have been translated.
At every intermediate step the program should still be executable after processing the translated part with the Cogent
compiler and can be tested whether it still behaves in the same way as the original C program.

To partially translate a C program, proceed as before, but put into \code{all.unit} only the names of those \code{.c}
files which shall be translated. You need only translate those \code{.h} files which are (directly or transitively)
included by the translated \code{.c} files. 

For a partially translated C program Gencot generates entry wrappers only for the translated functions, but it now
generates exit wrappers for all functions in the remaining \code{.c} files which are invoked from the translated functions.
In this way function invocations between the translated part and the remaining part are supported in both directions.
Additionally, Gencot translates all data types in a binary compatible way (not yet implemented for structs! requires Dargent 
or modification of Cogent), so that data can be passed back and forth between the translated and remaining part.

\subsection{Example}

The example program in \code{examples/cards2} can be partially translated by applying Gencot only to the files \code{main.c}
and \code{rank.c} and using the resulting Cogent program together with the original \code{cards.c}. The example provides
the file \code{part.unit} with the content
\begin{verbatim}
  rank.c
  main.c
\end{verbatim}

The partial translation step (\code{make part-cogent}) corresponds to the commands
\begin{verbatim}
  gencot hfile cards.h
  gencot hfile rank.h
  gencot -I. cfile rank.c
  gencot -I. cfile main.c
  gencot -I. unit part.unit
\end{verbatim}
The resulting file \code{part.cogent} includes only the Cogent sources \code{rank.cogent}, and
\code{main.cogent}. Note that you still have to translate \code{cards.h} because it is also included by \code{main.c}.

To execute the partially translated program, first edit the Cogent files (\code{make part-edit}) so that they contain
the following Cogent code:
\begin{verbatim}
rank.cogent:
  #include "rank-incl.cogent"

  cogent_ranking_to_string : Cogent_hand_ranking_t -> String
  cogent_ranking_to_string r =
    if r == cogent_STRAIGHT_FLUSH then "STRAIGHT_FLUSH" else
    if r == cogent_FOUR_OF_A_KIND then "FOUR_OF_A_KIND" else
    if r == cogent_FULL_HOUSE then "FULL_HOUSE" else
    if r == cogent_FLUSH then "FLUSH" else
    if r == cogent_STRAIGHT then "STRAIGHT" else
    if r == cogent_THREE_OF_A_KIND then "THREE_OF_A_KIND" else
    if r == cogent_TWO_PAIR then "TWO_PAIR" else
    if r == cogent_PAIR then "PAIR" else
    if r == cogent_NOTHING then "NOTHING" else
    "Invalid"
\end{verbatim}

\begin{verbatim}
main.cogent:
  #include "cards-incl.cogent"
  #include "rank-incl.cogent"

  cogent_main : () -> U32
  cogent_main () =
    cogent_puts("Just a test:");
    cogent_print_card(cogent_card_from_num(42));
    cogent_puts("  is card no 42");
    cogent_print_card(cogent_card_from_letters('Q', 'd'));
    cogent_puts("  is diamonds queen");
    0
\end{verbatim}

Then compile and postprocess the Cogent program (\code{make part-cogent-c}):
\begin{verbatim}
  cogent -o part-gen -g part.cogent \
     --cogent-pp-args="-I$GENCOT_HOME/include" \
     --infer-c-funcs="part-externs.ac main-entry.ac rank-entry.ac"
  auxcog unit part.unit
\end{verbatim}

Compile the resulting C program \code{part.c} with the C compiler to yield \code{part.o},
compile the original \code{cards.c} to yield \code{cards.o}, and link both files to the binary
\code{part-cogent-cards} (\code{make part-cogent-binary}). When executing this binary it should
behave like the original C program.

\chapter{Item Properties}

\chapter{Preprocessor Directives}

\end{document}
 
