#! /bin/csh -f

# Substitute constant names in constant replacement bodies.
# This is a filter from stdin to stdout.

awk \
'function mapname(nam) { \
   if (nam ~ /^MBEDTLS_/) res = "se" nam \
   else if (nam ~ /^mbedtls_/) res = "se" nam \
   else res = "cogent_" nam \
   return res \
} \
BEGIN { \
   lnr = 0 \
   cont = 0 \
   print "# 1 \"<mappings>\"" \
 } \
 { lnr++ \
   if ($1 == "#define") { \
     print "#define " $2 " " mapname($2) \
     if ($0 ~ /\\$/) cont = 1 \
     else cont = 0 \
     masked = "_" $1 " GENCOT_" $2 \
     for (i = 3; i <= NF; i++) masked = masked " " $i \
     if (cont) masked = masked "\\" \
     buf[lnr] = masked \
   } \
   else if (cont) { \
     if ($0 ~ /\\$/) { cont = 1; buf[lnr] = $0 "\\" } \
     else { cont = 0; buf[lnr] = $0 } \
   } \
   else if ($1 == "#") buf[lnr] = $0 \
   else buf[lnr] = "" \
 } \
END { \
  lnrb = 0 \
  while (lnrb < lnr) print buf[++lnrb] \
}' | cpp -nostdinc

# documentation:
# 
# The output contains the masked constant definitions with line directives specifying the origin file and the 
# line offset in that file. Constant names in replacement bodies have been substituted by cpp.
#
# Implementation in awk:
# - Function mapname maps a macro name to a Cogent variable name, always starting with a lowercase letter.
# - lnr is a variable for counting line numbers. These are actual line numbers in the input, line directives
#   are not reflected. The variable is only used for indexing the buf array.
# - cont is a boolean variable which tells whether the next line is a continuation line for the
#   same directive. It is set according to whether there is a backslash at the end of the previous line.
#   This is detected by matching the line with the regular expression /\\$/.
# - Line directives are recognized by the first field being "#". Since directives are normalized, in all
#   other cases the directive keyword must be part of the first field.
# - In the line rule two processing phases are combined. For every processed definition a mapping definition
#   is immediately output and a masked definition is added to the array buf, indexed by line numbers counted
#   in lnr. Continuation lines and line directives are only transferred to buf. Since all lines are counted
#   and empty lines are added to buf, the line position of the masked definitions in buf exactly correspond 
#   to their position in the input.
# - The mapping definitions are preceded by a line directive for the dummy file name "<mappings>" so that
#   their lines appear as included in the output and do not count to the content of "<stdin>".
# - In the END rule all masked definitions in buf are output.

