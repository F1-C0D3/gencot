\subsection{Modularization and Interfacing to C Parts}
\label{design-modular}

Every C compilation unit produces
a set of global variables and a set of defined functions. Data of the same type may be used in
different compilation units, e.g. by passing it as parameter to an invoked function. In this case type compatibility in C is
only guaranteed by including the \code{.h} file with the type definition in both compilation units. In the compiled
units no type information is present any more. 

This organisation makes it possible to use different \code{.h} files in different compilation units. Even the type definitions
in the included files may be different, as long as they are binary compatible, i.e., have the same memory layout.

We exploit this organisation for an incremental translation from C to Cogent as follows. At every stage we replace some 
C compilation units by Cogent sources. All C data types used both in C units and in Cogent units are mapped to binary compatible
Cogent types. Compiling the Cogent sources produces again C code which together with the remaining C units are linked to
the target program. The C code resulting from Cogent compilation is completely separated from the code of the remaining C units,
no common include files are used.

All interfacing between C compilation units is done by name. All names of C objects with external linkage can be referred
from other compilation units. This is possible for functions and for global variables. Interfacing from and to Cogent works
in the same way. 

\subsubsection{Interfacing to Functions}

Cogent functions always take a single parameter, the same is true for the C functions generated by the Cogent compiler. Hence
for interfacing from or to an arbitrary C function, wrapper functions are needed which convert between arbitrary many parameters
and a single structured parameter. These wrapper functions are implemented in C. 

The ``entry wrapper'' for invoking a Cogent function 
from C has the same name as the original C function, so it can be invoked transparently. Thus the Cogent implementation of
the function must have a different name so that it does not conflict with the name of the wrapper. This is guaranteed by the 
Gencot renaming scheme as described in Section~\ref{design-names}.

The Cogent implementation of a C function generated by Gencot is never polymorphic. This implies that the Cogent compiler
will always translate it to a single C function of the same name.

The ``exit wrapper'' for invoking a C function from Cogent invokes the C function by its original name, hence the wrapper
must have a different name. We use the same renaming scheme for these wrappers as for the defined Cogent functions.
This implies that every exit wrapper
can be replaced by a Cogent implementation without modifying the invocations in existing Cogent code. Note that for every
function either the exit wrapper or the Cogent implementation must be present, but not both, since they have the same name.

To use the exit wrapper from Cogent, a corresponding abstract function definition must be present in Cogent.

Note that if the C function has only one parameter, a wrapper is not required. For consistency reasons we generate and use
the wrappers also for these functions.

Cogent translates all function definitions to C definitions with internal linkage. To make them accessible the entry wrappers
must have external linkage. They are defined in an antiquoted C (.ac) file which includes the complete code generated from 
Cogent, there all functions translated from Cogent are accessible from the entry wrappers. The exit wrappers are only invoked 
from code generated from Cogent. They are defined with internal linkage in an included antiquoted C file.

\subsubsection{Interfacing to Global Variables}

Accessing an existing global C variable from Cogent is not possible in a direct way, since there are no ``abstract constants'' in 
Cogent. Access may either be implemented with the help of abstract functions which are implemented externally in additional C code and
access the global variable from there. Or it may be implemented by passing a pointer as (part of) a ``system state'' to the
Cogent function which performs the access.

Accessing a Cogent object definition from C is not possible, since the Cogent compiler does not generate a definition for them, it
simply substitutes all uses of the object name by the corresponding value. Hence, all global variable definitions need to remain 
in C code to be accessible there.

The way how global state is treated in a Cogent program is crucial for proving program properties. Gencot does not 
provide any automatic support for accessing global C variables from Cogent, this must always be implemented manually. 
However, to inform the developer about the variable and its type, Gencot translates it to an abstract function
from unit type to the type of the variable, without providing an implementation. It can be used to manually implement 
read access to the variable, write access must be handled completely manually. The name of the abstract function is
the mapped name of the variable.

\subsubsection{Cogent Compilation Unit}

As of December 2018, Cogent does not support modularization by using separate compilation units. A Cogent program may be distributed
across several source files, however, these must be integrated on the source level by including them in a single compilation unit.
It would be possible to interface between several Cogent compilation units in the same way as we interface from C units to Cogent
units, however this will probably result in problems when generating proofs. 

Therefore Gencot always generates a single Cogent compilation unit for the <package>. 
At every intermediate stage of the incremental translation the package consists of one Cogent compilation unit 
together with all remaining original C compilation units and optionally additional C compilation units (e.g., for implementing 
Cogent abstract data types).

Conflicts for names with internal linkage originating in different C compilation units are avoided by Gencot's name mapping scheme
as described in Section~\ref{design-names}.

It would be possible to translate only some include files used by the Cogent compilation unit to Cogent and access the content
of the others through abstract Cogent types and functions which are mapped in antiquoted C to the original C definitions. 
However, for checking the refinement proof of the Cogent compilation unit, the Isabelle C parser reads the complete C program
which results from translating the Cogent code to C. The Isabelle C parser only supports a C subset and normally the original
<package> include files will not be restricted to this subset. Therefore we do not use any of them for the Cogent compilation
unit. Gencot always assumes that \textit{all} include files used (transitively) by the Cogent compilation unit are also translated
to Cogent and included in this form.

The only exception are the system include files. Their content typically needs specific treatment anyways. Gencot replaces every 
reference to a function declared in a system include file by an abstract function, whithout providing an implementation. 
It must be added manually by the developer. Referenced types defined in system include files are translated as usual.

\subsubsection{External Name References}
\label{design-modular-extref}

To successfully compile the Cogent compilation unit all referenced identifiers must be declared in the C code. 
Those references which are
used in the generated Cogent code must additionally be defined in Cogent. A non-local reference in a C source file is every
identifier which is used in the file but not defined or declared in the same file.

In the original C source for every non-local reference there must be a declaration or definition present in one of the included
files (its ``origin file''). If the origin file of a non-local reference is a file which has already been translated by 
Gencot, the required information about the identifier is already present in the Cogent compilation unit. As described above, 
all used include files which belong to the <package> must have been translated. If the origin file
of a non-local reference is not a part of the <package> (which normally is the case for all
system includes), we call it an ``external reference''. For external references additional information must be created and 
made available in the Cogent compilation unit.

A non-local reference is external relative to a given set of C source files, if its definition does not belong to the content
of the set. For a name without linkage (mainly type names and struct/union/enum tags) its definition must be present for every
reference, i.e. contained in the included origin file. Thus a reference to such a name is external, if its origin file does 
not belong to the set. For a name with linkage (mainly names of functions and variables) it depends on the kind of linkage.
If it has internal linkage, its definition must also be present for every reference. Then the origin file is that containing the
(single) definition, not a file containing a declaration. An external reference of a name with internal linkage occurs if
the definition is contained in an include file which does not belong to the <packge>.

If the name has external linkage, however, the definition need not be present. In this case the origin file only contains a declaration
of the name and even needs not be unique. Then it is not possible to decide whether a non-local reference is external by simply 
looking at the content of all included files. Instead, all the files in the given set must be inspected, whether they contain
the name's definition. Note that this is only necessary for deciding whether a reference is external. The information necessary
for processing it is always present as part of the declaration in the included origin file.

On the C level the information for external name references with internal linkage must always be provided manually,
since they are not defined in the <package>. The information for external references with no linkage (type and tag names) is
not required since Gencot fully translates the corresponding definitions to Cogent as usual. The information for variable references 
with external linkage must also be provided manually. The information for function references with external linkage is 
generated automatically by Gencot in the form of the exit wrapper functions defined in antiquoted C. 

On the Cogent level the information is provided as follows.
\begin{itemize}
\item If the external reference is a type name or a struct/union/enum tag, a Cogent type definition is generated for the mapped name.
The defined Cogent type is determined
from the C type referenced by the type name as described in Section~\ref{design-types}. The only difference is that all C type
names used directly or indirectly by the C type are resolved, if they are not already external references. This is done to avoid 
introducing type names which are never referenced from any other place in the generated Cogent program. 
\item If the external reference is a function name, an exit wrapper and the corresponding Cogent abstract function 
definition is generated.
\item If the external reference is the name of a global variable, the abstract access function is generated in the same 
form as when translating a variable defined in the Cogent compilation unit.
\item If the external reference is the name of an enum constant or a preprocessor defined constant, a Cogent constant definition 
is generated.
\item An external reference may be the name of a member in a struct or union. In this case also the struct or union tag must
be externally referenced and the corresponding Cogent type definition is generated, as described above. Note that for a union
member this will always be an abstract type which does not provide access to the member in Cogent.
\end{itemize}
