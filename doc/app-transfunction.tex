The manual part of the translation is mainly required for the bodies of all C functions defined in the C source file.
A \code{.h} file normally does not contain function or object definitions, then it may be the case that no manual actions 
are necessary. But some \code{.h} files define functions, typically as \code{static inline}, then also their bodies
must be translated manually.

The manual translation is done by modifying the \code{.cogent} file generated by the automatic translation in an 
editor. As described in Section~\ref{design-fundefs-body}, the result of automatically translating a function
definition has the form
\begin{verbatim}
  <name> :: (<ptype1>, ..., <ptypen>) -> <restype>
  <name> (<pname1>, ..., <pnamen>) = <dummy result>
  {- <compound statement> -}
\end{verbatim}
where the \code{<compound statement>} is plain C code with global names mapped to Cogent. The task of the manual
translation is to replace the \code{<dummy result>} by a Cogent expression equivalent to the \code{<compound statement>}.

In the following sections we provide some rules and patterns how to translate typical C constructs occurring in a
\code{<compound statement>}. These rules and patterns are not exhaustive but try to cover most of the common cases.

\subsection{General}
\label{app-transfunction-general}

The basic building blocks of C function bodies are declarations and statements. Here we only cover declarations of 
local variables. Such a declaration specifies a name for the local variable and optionally an initial value.

A C statement causes modifications in its context. Cogent, as a functional language, does not support this concept,
in particular, it does not support modifying the value of a variable. Cogent only supports expressions which functionally
depend on their input, and it supports introducing immutable variables by binding them to a value. 
The main task of translating function bodies is to translate C statements to Cogent expressions.

The main idea of the translation is to translate a C variable which is modified to a sequence of bindings of Cogent
variables to the values stored in the C variable over time. Everytime when a C statement modifies a variable, a new
variable is introduced in Cogent and bound to the new value. A major difference of both approaches is that in Cogent 
the old variable and its value are still available after the modification. To prevent this, we use the same name for
both variables. Then the new variable ``shadows'' the old one in its scope, making the old value unaccessible there.
For example the C code
\begin{verbatim}
  int i = 0; i = i+1; ...
\end{verbatim}
is translated to
\begin{verbatim}
  let i = 0 in let i = i+1 in ...
\end{verbatim}
where the single C variable \code{i} is translated to two Cogent variables which are both named \code{i}.

\subsubsection{Statements}

A C statement in a function can modify several of the following:
\begin{itemize}
\item function parameters
\item local variables
\item global variables
\end{itemize}
All of them are specified by an identifier which is unique at the position of the statement. The modification
may replace the value as a whole or only modify one or more parts in the case of a structured value.

As a first step modifications of global variables must be eliminated by passing all such variables as additional 
parameters to the function and returning them as additional component in the result. Then a modification of a
global variable becomes a modification of a function parameter and only the first two cases remain.

After this step the effect of the modification caused by a C statement can be described by a set of identifiers 
of all modified parameters and local variables together with the new values for them. Syntactically this corresponds
to a Cogent \textit{binding} of the form
\begin{verbatim}
  (id1,...,idn) = expr
\end{verbatim}
where \code{expr} is a Cogent expression for the tuple of new values for the identifiers.

\subsubsection{Pointers}

Cogent treats C pointers in a special way as values of ``linear type'' and guarantees that no memory is shared
among different values of these types. More general, all values which may contain pointers (such as a struct with
some pointer members) have this property. All other values are of ``nonlinear type'' and never have common parts 
in C.

If a C program uses sharing between values of linear type, it cannot be translated directly to Cogent. We use 
the following approach for a translation of such cases. 

If several parameters of a function may share common memory, they are grouped together to a Cogent record or
abstract data type and treated as a single parameter. All functions which operate on one of the values are
changed to operate on the group value. Then no sharing occurs between the remaining function parameters.

If several local variables share common memory they can be treated in the same way. 

If a variable shares memory with a parameter this solution is not applicable. In this case the variable must be
eliminated. This is easy if the variable is only used as a shortcut to a part of the parameter value, then it
can be replaced by explicit access to the part of the parameter. For example, in the C function
\begin{verbatim}
  void f (struct{int i; x *p;} p1) {
    x *v = p1.p; ...
  }
\end{verbatim}
the occurrences of variable \code{v} can be replaced by accesses to \code{p1.p}. 
In other cases individual solutions must be found. Note that parameters and variables of nonlinear type never
cause such problems.

After these steps no sharing occurs among the parameters and local variables in the function. This implies that 
a C statement can only modify parameters and variables for which the identifiers occur literally in the statement
source code text. Thus it is possible to determine the effect of the modification caused by a C statement
syntactically from the statement.

\subsubsection{Variable Declarations}

An initializer \code{init} in a variable declaration \code{t v = init;} is either an expression or an initializer for
a struct or an array. The C declaration can be rewritten as
\begin{verbatim}
  t v;
  v = init;
\end{verbatim}
with a separate statement for initializing the variable. If \code{init} is an expression this is valid C code. Otherwise,
if \code{init} is an initializer for a struct or array, the statement is not valid in C, but we will translate it 
according to the intended semantics. For a struct type Cogent provides
corresponding expressions for unboxed records. For other types Gencot provides its initialization functions 
described in Section~\ref{design-operations-init} and~\ref{design-operations-array},
or the initialization can be done by several applications of operation \code{set} (see Section~\ref{design-operations-parts}).

A declaration without an initializer should always be followed by an assignment to it before it is accessed. If not
we insert an assignment of a default value before the first access.

Then the declarations need not be translated to Cogent, since in Cogent a new variable is introduced whenever
the C variable is modified by a statement. Therefore, only the C statements need to be translated to Cogent.

\subsection{Expressions}
\label{app-transfunction-expr}

C statements usually have C expressions as syntactic parts. For translating C statements the contained C expressions must be 
translated. C expressions have a value but may also cause modifications as side effects. Especially, in C an assignment
is syntactically an expression. C expressions are translated depending on whether they have side effects or not.

\subsubsection{Expressions without Side Effects}

C expressions without side effects are literals, variable references, member accesses of the form \code{s.m} or 
\code{s->m}, index
expressions of the form \code{a[e]}, applications of binary operators of the form \code{e1 op e2}, 
applications of the unary operators \code{+,-,!,~} of the form \code{op e}, and function 
call expressions of the form \code{f(e1,...,en)}, if all subexpressions
\code{s,a,e,f,e1,...,en} have no side effects and function \code{f} does not modify its parameter values. 

These expressions are translated to Cogent expressions in a straightforward way with the same or a similar syntax.
A member access \code{s->m} is translated as \code{s.m}. An index expression \code{a[e]} is translated as function 
call \code{getArr(a,e)}. Note, that some C operators have a different form in Cogent:
\begin{verbatim}
  C  Cogent
  !=   /=
  ^    .^.
  &    .&.
  |    .|.
  !    not
  ~    complement
\end{verbatim}

Member accesses of the form \code{s->m} (or written \code{(*s).m}) and index expressions \code{a[e]} can only be 
translated in this way if the
container value \code{s} or \code{a}, respectively, is translated to a readonly value in Cogent. If it is a parameter,
variable, or record field, it may have been defined as readonly. Otherwise, it can be made readonly in the expression's
context by applying the bang operator \code{!} to it at the end of the context:
\begin{verbatim}
  ... s.m ...  !s
\end{verbatim}
The resulting expressions are also of readonly type. For expressions of nonlinear type this is irrelevant, for expressions
of linear type it implies that they cannot be modified. If they are used in C by modifying them, they must be translated
in a different way. For example in the C code fragment
\begin{verbatim}
  *(s->p) = 5
\end{verbatim}
the expression \code{s->p} denotes a pointer which is modified, therefore it cannot be translated to \code{s.m} where 
s is readonly.

For resultig expressions of linear types, using the bang operator \code{!} also means that the readonly result cannot
escape from the banged context, it can only be used inside the context.

Translation of expressions using the address operator \code{\&} are described in Section~\ref{app-transfunction-addrop}.

Dereferencing (application of the indirection operator \code{*} to) a pointer is translated depending on the type of value referenced by 
the pointer. If it points to a function, \code{*p} is translated as \code{fromFunPtr(p)} 
(See Section~\ref{design-operations-function}). 

If it points to a primitive type, an enum type, or again a pointer type, 
\code{*p} is translated as \code{getPtr(p)} (See Section~\ref{design-operations-pointer}). In this case \code{p} 
must be readonly as above, and the result is readonly. If it should be modified it must be translated differently.

Otherwise it points to a type which is mapped to Cogent as a record or abstract type. Then \code{*p} is translated as \code{p}. 

Expressions using the C operators \code{sizeof} or \code{\_Alignof} cannot be translated to Cogent. Usually, an abstract
function implemented in C is required here.

\subsubsection{Expressions with Side Effects}

We translate an expression with side effects to a Cogent binding of the form \code{pattern = expr}. Here, the
\code{pattern} is a tuple of variables \code{(v,v1,...,vn)}. The variable \code{v} is a
new variable which is not already bound in the context of the expression, it is used to bind the result value of the
expression. The other variables are the identifiers of all parameters and local 
variables modified by the expression. Since we presume that the C expression has side effects, there is at least one
such variable.
The \code{expr} is a Cogent expression for a corresponding tuple consisting of the result value of the C expression and the new values
of the identifiers modified by the C expression.

Expressions with side effects are applications of the increment and decrement operators \code{++,-{}-}, assignments,
and invocations of functions which modify one or more parameter values.

Applications of increment and decrement prefix operators must be rewritten in C using assignments. Assignments using assignment
operators other than \code{=} must be rewritten in C using the \code{=} operator. After these steps the only 
remaining expressions with side effects are assignments using \code{=}, increment and decrement postfix operators, 
and invocations of functions which modify parameter values.

If for such an expression all subexpressions are without side effects, they are translated as follows. 

The translation of an assignment expression of the form \code{lhs = e} depends on the form of \code{lhs}. If it is
a single identifier \code{v1} (name of a parameter or local variable), it is translated as
\begin{verbatim}
  (v,v1) = let v = expr in (v,v)
\end{verbatim}
where \code{expr} is the translation of \code{e}.

Note that this code is illegal in Cogent, if \code{expr} has a linear type, since it uses the result value twice. However, this
is a natural property of C code, where an assignment is an expression and the assigned value can be used in the context. For example,
the C code fragment \code{f(p = q)} assigns the value of \code{q} to \code{p} and also passes it as argument to function \code{f}.

There are several ways how to cope with this situation. In the simplest case, the outer variable \code{v} is never used in its
scope, then the double use of the value can be eliminated by simplifying the Cogent binding to the form
\begin{verbatim}
  v1 = expr
\end{verbatim}
This is typically the case if the assignment is used as a simple statement, where its result value is discarded. Most assignments
in C are used in this way.

Otherwise it depends on how the variable \code{v} is used in its scope. In some cases it may be possible to replace its use by 
using \code{v1} instead, then it can be eliminated in the same way as above. If that is not possible, the C program uses true
sharing of pointers, then the code cannot be translated to Cogent and must be translated using abstract functions.

If \code{lhs} is a logical chain of \code{n} member access, index, and dereferencing expressions starting with identifier \code{v1} 
(name of a parameter or local variable), the most general translation is
\begin{verbatim}
  (v,v1) =
    let v = expr
    in (v,fst(modify1(v1,(modify2,(...(modifyn-1,(set,v))...)))))
\end{verbatim}
where \code{expr} is the translation of \code{e} and the sequence of \code{modifyi} functions is determined by the chain of access
expressions and \code{set} is an 
instance of the operation \code{set} (see Section~\ref{design-operations-parts}). Again, the result of \code{expr} is used twice,
the same considerations as above apply if it has a linear type.

For example the C assignment expression
\begin{verbatim}
  s->a[i]->x = 5
\end{verbatim}
is translated according to this rule to the Cogent binding
\begin{verbatim}
  (v,s) = let v = 5
    in (v,fst(modrefFldA(s,(modifyArr,(i,exchngFldX,v)))))
\end{verbatim}
where \code{modrefFldA} and \code{exchngFldX} are abstract modification functions for the fields \code{a} and \code{x},
respectively, as described in Section~\ref{design-operations-record}. \code{exchngFldX} is used instead of \code{setFldX}
because \code{modifyArr} expects a modification function where the additional input and result have the same type.

No other cases for \code{lhs} are valid in a C assignment.

If \code{lhs} logically starts with a chain of member accesses \code{v1->m1->...->mn...} an alternative translation using the Cogent
take and put operations is the binding
\begin{verbatim}
  (v,v1) = 
    let v1{m1=m1{m2=...mn-1{mn}...}}
    and (v,mn) = expr
    in (v,v1{m1=m1{m2=...mn-1{mn=mn}...}})
\end{verbatim}
where \code{(v,mn) = expr} is the binding to which \code{mn... = e} is translated, if \code{mn} is assumed to be a local variable. 
For example, a corresponding translation of \code{*(s->m1->m2) = 5} is
\begin{verbatim}
  (v,s) = 
    let s{m1=m1{m2}}
    and (v,m2) = let v = 5 in (v,setPtr(m2,v))
    in (v,s{m1=m1{m2=m2}})
\end{verbatim}
This approach avoids the need to manually define and implement the functions \code{modifyFldM}.

An application of an increment/decrement postfix operator \code{ss} where \code{s} is \code{+} or \code{-} has the form
\code{lhs ss}. If \code{lhs} is a single identifier \code{v1} this identifier must have a numerical type and the expression 
is translated to the binding
\begin{verbatim}
  (v,v1) = (v1,v1 s 1)
\end{verbatim}
Using \code{v1} twice is always possible here since it has nonlinear type. As an example, \code{i++} is translated to
\begin{verbatim}
  (v,i) = (i,i+1)
\end{verbatim}

If \code{lhs} is a logical chain of \code{n} member access, index, and dereferencing expressions starting with identifier \code{v1}
this identifier must have linear type and the most general translation is the binding
\begin{verbatim}
  (v,v1) = 
    let v = tlhs !v1
    in (v, fst(modify1(v1,(modify2,(...(modifyn-1,(set,v s 1))...))))
\end{verbatim}
where \code{tlhs} is the translation of \code{lhs} when \code{v1} is readonly and \code{modifyi} and \code{set} are as 
for the assignment. Here \code{v1} is needed twice, first for retrieving the old
numerical value \code{v} and afterwards to set it to the incremented/decremented value. Since \code{v1} is linear the old
value must be retrieved in a readonly context and the modification must be done seperately. The double use of \code{v}
is always possible since it has numeraical type.

If \code{lhs} logically starts with a chain of member accesses \code{v1->m1->...->mn...} an alternative translation using the Cogent
take and put operations is the binding
\begin{verbatim}
  (v,v1) =
    let v = tlhs !v1
    and v1{m1=m1{m2=...mn-1{mn}...}} 
    in (v, v1{m1=m1{m2=...mn-1{mn=expr}...}})
\end{verbatim}
where \code{expr} is as above for the assignment using \code{(v s 1)} as the new value.

For example, a corresponding translation of \code{(*(s->m1->m2))++} is
\begin{verbatim}
  (v,s) =
    let v = getPtr(s.m1.m2) !s
    and s{m1=m1{m2}}
    in (v,s{m1=m1{m2=setPtr(m2,v+1)}})
\end{verbatim}

A C function which modifies parameter values is translated by Gencot to a Cogent function returning the tuple \code{(y,p1,...,pn)}
of the original function result \code{y} and the modified parameter values \code{p1,...,pn} (which must be pointers). 
A C function call \code{f(...)} is
translated depending on the form of the actual arguments passed to \code{f} for the modified parameters.

If all such arguments are identifiers (names of parameters and local variables) the function call is translated to
the binding
\begin{verbatim}
  (v,v1,...,vn) = f(...)
\end{verbatim}
where \code{v1,...,vn} are the identifiers passed to the parameters modified by \code{f} in the order returned by \code{f}.

If some of the arguments are member access chains of the form \code{vi->mi1->...->miki} they must be translated using the 
Cogent take and put operations as above to a binding of the form
\begin{verbatim}
  (v,v1,...,vn) = 
  let v1{m11=...{m1k1}...}
  and ... 
  and vn{mn1=...{mnkn}...}
  and (v,m1k1,...,mnkn)=f(...)
  in (v,v1{m11=...{m1k1=m1k1}...},
       ...
        vn{mn1=...{mnkn=mnkn}...})
\end{verbatim}
where in the arguments of \code{f} the chains are replaced by their last member name \code{miki}.

For example, the function call \code{f(5,s->m,t->n,z)} where \code{f} modifies its second and third parameter, is translated
to the binding
\begin{verbatim}
  (v,s,t) = 
  let s{m}
  and t{n}
  and (v,m,n)=f(5,m,n,z)
  in (v,s{m=m},t{n=n})
\end{verbatim}

If function \code{f} modifies only one parameter \code{p} of Cogent type \code{P} its standard type generated by
Gencot can be changed to the form of a modification function
\begin{verbatim}
  f: ModFun P (...) Res
\end{verbatim}
where \code{(...)} is the tuple of types of the other parameters and \code{Res} is the result type. Then for an arbitrary
chain of member access, index, and dereferencing expressions used as actual argument for \code{p} the function call 
can be translated to a binding of the form
\begin{verbatim}
  (v,v1) = let (v1,v) = 
    modify1(v1,(modify2,(...(modifyn,(f,(a1,...,an)))...)))
    in (v,v1)
\end{verbatim}
where the sequence of \code{modifyi} functions is determined by the chain of access expressions. Note
that the order of the variables must be exchanged since the original result of \code{f} is the second component in 
the inner tuple pattern due to the way \code{ModFun} is defined.

For example, the function call \code{f(5,s->a[i]->x,z)} can be translated by first modifying the translation of 
\code{f} so that it takes as parameters instead of the tuple \code{(a,b,c)} the pair \code{(b,(a,c))}. Then a translation
for the function call is
\begin{verbatim}
  (v,s) = let (s,v) = 
    modrefFldA(s,(modifyArrDflt,(i,modifyFldX,(f,(5,z)))))
    in (v,s)
\end{verbatim}
Here function \code{modifyArrDflt} must be used since the additional input and output of \code{f} have different types.
If index \code{i} is invalid \code{f} is never applied and a default value is used instead of its result.

Again, if the chain logically starts with member accesses, that part of the chain can be translated using take and put operations.

In all other cases the function \code{f} must be modified so that it takes the starting identifiers of the chains as
arguments instead of the chains, then it can be translated as in the first case where all actual arguments are identifiers.
Note that different translations of the function to Cogent may be required for translating different function calls.

\subsubsection{Nested Expressions with Side Effects}

If an expression contains subexpressions with side effects, these must be translated separately. 

Let \code{e1,...,en} be the expressions with side effects directly contained in the expression \code{e} and
let \code{p1 = expr1, ..., pn = exprn} their translations to Cogent bindings. Since in C the order of evaluation 
of the \code{e1,...,en} is undefined, we can only translate \code{e} if the subexpressions
modify pairwise different sets of identifiers, i.e., the \code{p1,...,pn} are pairwise disjunct tuples.
Let \code{x1,...,xn} be the
first variables of the patterns \code{p1,...,pn} and let \code{w1,...,wm} be the union of all other variables
in \code{p1,...,pn} in some arbitrary order. Let \code{e'} be \code{e} with every \code{ei}
substituted by \code{xi}. Then \code{e'} contains no nested expressions with side effects and can be translated
to Cogent according to the previous sections.

If \code{e'} has no side effects, let \code{expr} be its translation to a Cogent expression. Then the translation 
of \code{e} is the binding
\begin{verbatim}
  (v,w1,...,wm) = 
    let p1 = expr1 and ...
    and pn = exprn 
    in (expr,w1,...,wm)
\end{verbatim}
For example the expression \code{a[i++]} is translated according to this rule to
\begin{verbatim}
  (v,i) = 
    let (v,i) = (i,i+1)
    in (getArr(a,v),i)
\end{verbatim}

If \code{e'} has side effects, let \code{(v,v1,...,vk) = expr} be its translation to a Cogent binding. Then
the translation of \code{e} is the binding
\begin{verbatim}
  (v,v1,...,vk,w1,...,wm) = 
    let p1 = expr1 and ...
    and pn = exprn 
    and (v,v1,...,vk) = expr
    in (v,v1,...,vk,w1,...,wm)
\end{verbatim}
For example the expression \code{a[i++] = 5} is translated according to this rule to
\begin{verbatim}
  (v,a,i) = 
    let (v,i) = (i,i+1)
    and (w,a) = let w = 5 in (w,setArr(a,v,w))
    in (w,a,i)
\end{verbatim}
which can be simplified in Cogent to the binding
\begin{verbatim}
  (v,a,i) = (5,setArr(a,i,5),i+1)
\end{verbatim}

\subsubsection{Readonly Access and Modification of the Same Value}

If a C expression uses and modifies parts of a linear value at the same time, a special translation approach is required.
An example is the expression \code{r->sum = r->n1 + r->n2}. According to the rules above, translating the right hand side
requires to make \code{r} readonly by applying the bang operator \code{!} which then prevents translating the expression
as a whole, modifying \code{r}. There are three cases how to deal with this situation.

If all used parts of the value are nonlinear, they can be retrieved in a separate step using \code{!}, bound to Cogent 
variables and then used in the modification step. The translation of an expression \code{e} then has the general form
\begin{verbatim}
  (v,v1,...,vn) = 
    let (w1,...,wm) = ... !r1 ... !rk
    in expr
\end{verbatim}
where \code{w1,...,wm} are auxiliary Cogent variables for binding the used values, \code{r1,...,rk} are all linear values
from which parts are used in \code{e} and \code{(v,v1,...,vn) = expr} is the 
normal translation of \code{e} with all used parts replaced by the corresponding \code{wi}.

We used this approach for translating applications of postfix increment/decrement operations to complex expression,
such as \code{(*(s->m1->m2))++}.

If the used values are themselves linear, such as in \code{r->p = f(r->p)} where \code{p} is a pointer, this approach
cannot be used since in Cogent the binding \code{w = r.p !r} is illegal, \code{r.p} has a readonly linear type and
is not allowed to escape from the banged context so that it can be bound to \code{w}.

If the used linear value is replaced by the modification, as in the example, it is possible to use the take and put
operations. In a first step the used values are taken from the linear containers \code{r1,...,rk}, in the modification
step they are put back in. The translation of \code{e} then has the general form
\begin{verbatim}
  (v,v1,...,vn) = 
    let r1{... = w1 ...} ...
    and rk{... = wk ...}
    in expr
\end{verbatim}
where \code{expr} contains the necessary put operations for all \code{r1,...,rk}.

It may also be the case that the modification cannot be implemented by a combination of take and put operations, either 
because data types like arrays and pointers are involved, which are not translated to Cogent records, or because
the modification causes sharing or discarding linear values. In both cases the modification cannot be implemented in
Cogent, it must be translated by introducing an abstract function \code{fexpr} which implements the expression \code{e}
as a whole. Then the translation has the form
\begin{verbatim}
  (v,v1,...,vn) = 
    fexpr(v1,...,vn,x1,...,xm)
\end{verbatim}
where \code{x1,...,xm} are additional nonlinear values used by the expression.

\subsubsection{Comma Operator}

In C the expression \code{e1,e2} first evaluates \code{e1}, discarding its result and then evaluates \code{e2} for which
the result is the result of the expression as a whole. Thus, the comma operator only makes sense if \code{e1} has side
effects. Let \code{(v,v1,...,vn) = expr1} be the translation of \code{e1} to a Cogent binding.

If \code{e2} has no side effects and is translated to the Coent expression \code{expr2}, the expression \code{e1,e2}
is translated to the Cogent binding
\begin{verbatim}
  (v,v1,...,vn) = 
    let (_,v1,...,vn) = expr1
    in (expr2,v1,...,vn) 
\end{verbatim}
Note that the translation is only valid if the result value of \code{e1} is not linear, since it is discarded. If 
\code{expr1} is a tuple, this can be simplified by omitting the first component. This avoids the discarding and 
may even remove a double use of a linear value in \code{expr2}.

If \code{e2} has side effects let \code{(w,w1,...,wm) = expr2} be the translations of \code{e2}. Then the translation of 
\code{e1,e2} is 
\begin{verbatim}
  (v,u1,...,uk) = 
    let (_,v1,...,vn) = expr1
    and (w,w1,...,wm) = expr2
    in (w,u1,...,uk) 
\end{verbatim}
where \code{u1,...,uk} is the union of \code{v1,...,vn} and \code{w1,...,wm}. 

\subsubsection{Conditional Expression}

A conditional expression \code{e0 ? e1 : e2} is translated as follows. Let \code{(x,x1,...,xn) = expr0}, 
\code{(y,y1,...,ym) = expr1}, \code{(z,z1,...,zp) = expr2} be the translations of 
\code{e0}, \code{e1}, \code{e2}, respectively.
If \code{e0} evaluates to a value of numerical type the translation of the conditional expression is 
\begin{verbatim}
  (v,v1,...,vk) = 
    let (x,x1,...,xn) = expr0
    and (v,u1,...,uq) =
      if x /= 0 then 
        let (y,y1,...,ym) = expr1 
        in (y,u1,...,uq)
      else
        let (z,z1,...,zp) = expr2
        in (z,u1,...,uq)
    in (v,v1,...,vk) 
\end{verbatim}
where \code{u1,...,uq} is the union of \code{y1,...,ym} and \code{z1,...,zp} in some order, and 
\code{v1,...,vk} is the union of \code{y1,...,ym} and \code{x1,...,xn} in some order.

If the outermost operator of \code{e0} is a ``logical'' operator (one of \code{<, <=, >, >=, ==, !=, \&\&, ||})
it can be translated in a way that the first component in the result of \code{expr0} is of type Bool.
Then, instead of \code{if x /= 0 then} the condition is written as \code{if x then}.

In C the value used for testing the condition may be of any scalar type, i.e., a numerical or pointer type.
In case of a pointer type the condition corresponds to testing the pointer for being not \code{NULL}.
The translated expression \code{expr0} will return a value of linear type as first component. Since it
may be null (otherwise the conditional expression could be replaced by \code{e1}) it must be translated
so that \code{expr0} returns a value of type \code{MayNull a} (see Section~\ref{design-operations-null})
as its first component. Since the use as condition in Cogent would discard the value, it must be readonly,
i.e., of type \code{(MayNull a)!}. Then, instead of \code{if x /= 0 then} the condition must be written as
\begin{verbatim}
      if not isNull(x) then 
\end{verbatim}
using function \code{isNull} as described in Section~\ref{design-operations-null}. If the first component
of the result of \code{expr0} is not already of readonly type it must be made readonly in the condition:
\begin{verbatim}
      if not isNull(x) !x then 
\end{verbatim}
In the following patterns we only show the form \code{if x /= 0 then}, it must be replaced as needed.

Usually, the condition \code{e0} has no side effects, the the translation can be simplified to
\begin{verbatim}
  (v,u1,...,uq) = 
    if expr0 /= 0 then 
      let (y,y1,...,ym) = expr1 
      in (y,u1,...,uq)
    else
      let (z,z1,...,zp) = expr2
      in (z,u1,...,uq)
\end{verbatim}

If also \code{e1} and \code{e2} have no side effects the translation can be further simplified to
the Cogent expression
\begin{verbatim}
  if expr0 /= 0 then expr1 else expr2
\end{verbatim}

As an example the C expression \code{i == 0? a = 5 : b++} is translated to
\begin{verbatim}
  (v,a,b) = 
    if i == 0 then 
      let a = 5
      in (a,a,b)
    else
      let (v,b) = (b,b+1)
      in (v,a,b)
\end{verbatim}

For these translations the way how the Cogent compiler is used is relevant. When it translates the Cogent code back to 
C it translates an expression of the form
\begin{verbatim}
  let v = if a then b else c
  in rest
\end{verbatim}
to a C statement of the form
\begin{verbatim}
  if a { v = b; rest}
  else { v = c; rest}
\end{verbatim}
duplicating the translated code for \code{rest} (which is called ``a-normal form'' in Cogent). 
The same happens for all bindings and expressions after
the binding of \code{v} in the context of the \code{let} expression. If several such bindings to a 
conditional expressions are used this leads to an exponential growth in size of the C code.

To prevent this the Cogent compiler must be used with the flag \code{--fnormalisation=knf}
which translates to ``k-normal form''
\begin{verbatim}
  if a { v = b}
  else { v = c}
  rest
\end{verbatim}

Alternatively, the conditional expression can be wrapped in a lambda expression in the form
\begin{verbatim}
  let v = (\(x1,...,xn) => if a then b else c) 
    (x1,...,xn)
  in rest
\end{verbatim}
where \code{x1,...,xn} are all Cogent variables used in the expressions \code{a, b, c}.
Cogent translates this code to C without duplicating \code{rest}, even if a-normal form is used.

\subsection{Statements}
\label{app-transfunction-stat}

A C statement has no result value, it is only used for its side effects. Therefore we basically translate every
statement to a Cogent binding of the form \code{pattern = expr} where pattern is a tuple of all identifiers
modified by the statement.

However, a C statement can also alter the control flow in its environment, which is the case for 
\code{return} statements, \code{goto} statements etc. We treat this by adding a 
component to the \code{pattern}, so that the translation becomes
\begin{verbatim}
  (c,v1,...,vn) = expr
\end{verbatim}
The variable \code{c} is a
new variable which is not already bound in the context of the expression, it is used to bind the information about 
control flow modification by the statement. The other variables are the identifiers of all parameters and local 
variables modified by the statement. Since a statement need not modify variables, the pattern may also be
a single variable \code{c}. In the following descriptions we always use a pattern of the form \code{(c,v1,...,vn)}
with the meaning that for \code{n=0} it is the single variable \code{c}.

The value bound to \code{c} is a tuple of type 
\begin{verbatim}
  (Bool, Bool, Option T)
\end{verbatim}
where \code{T} is the original result type of the surrounding function. In a value \code{(cc,cb,res)} the component
\code{cc} is true if the statement contains a \code{return}, \code{break}, or \code{continue} statement outside
of a \code{switch} or loop statement. The component \code{cb} is true if the statement contains a \code{return}
or \code{break} statement outside of a \code{switch} or loop statement. The component \code{res} is the value 
\code{None} if the statement contains no \code{return} statement, otherwise it is the value \code{Some v} where
\code{v} is the value to be returned by the function.

The translation of \code{goto} statement and labels is not supported, this must be done manually.

\subsubsection{Simple Statements}

A simple C statement consists of a C expression, where the result is discarded. Therefore it makes only sense
if the C expression has side effects. Simple statements cannot modify the control flow, they always bind the 
variable \code{c} to the value \code{(False,False,None)} which we abbreviate as \code{ffn} in the following.

The binding in the translation of a simple C statement \code{e;} is mainly the binding resulting from the translation 
of the expression \code{e}, as described in Section~\ref{app-transfunction-expr}. Let its translation
be \code{(v,v1,...,vn) = expr}.
Then the binding for the statement \code{e;} is
\begin{verbatim}
  (c,v1,...,vn) = 
    let (v,v1,...,vn) = expr
    in (ffn,v1,...,vn)
\end{verbatim}

The result \code{v} of \code{e} is discarded, the same considerations apply here as described for expressions using
the comma operator in Section~\ref{app-transfunction-expr}. 

If \code{expr} is a tuple 
\code{(e0,e1,...,en)} the binding can further be simplified to
\begin{verbatim}
  (c,v1,...,vn) = (ffn,e1,...,en)
\end{verbatim}

As an example, the translation of the simple statement \code{i++;} is
\begin{verbatim}
  (c,i) = let (v,i) = (i,i+1) in (ffn,i)
\end{verbatim}
which can be simplified to
\begin{verbatim}
  (c,i) = (ffn,i+1)
\end{verbatim}

The empty C statement \code{;} is translated as
\begin{verbatim}
  c = ffn
\end{verbatim}

\subsubsection{Jump Statements}

A jump statement is a \code{return} statement, \code{break} statement, or \code{continue} statement.

A C return statement has the form \code{return;} or \code{return e;}. It always ends the control flow in the surrounding
function body. The first form can only be used in functions returning \code{void}, these are translated to Cogent as returning 
\code{()} or a tuple of only the modified parameters. 

The translation of a return statement of the form \code{return;} is the binding
\begin{verbatim}
  c = (True,True,Some ())
\end{verbatim}
If \code{e} has no
side effects, the translation of statement \code{return e;} is
\begin{verbatim}
  c = (True,True,Some expr)
\end{verbatim}
where \code{expr} is
the translation of \code{e}. 

Otherwise, let \code{(v,v1,...,vn) = expr} be the translation of \code{e}. Then 
the translation of \code{return e;} is
\begin{verbatim}
  (c,v1,...,vn) = 
    let (v,v1,...,vn) = expr
    in ((True,True,Some v), v1,...,vn)
\end{verbatim}
which can be simplified if \code{expr} is the tuple \code{(e0,e1,...,en)} to
\begin{verbatim}
  (c,v1,...,vn) = ((True,True,Some e0),e1,...,en)
\end{verbatim}

A C \code{break} statement has the form \code{break;}. It ends the next surrounding \code{switch} or loop statement,
otherwise it may not be used. It is translated to
\begin{verbatim}
  c = (True,True,None)
\end{verbatim}

A C \code{continue} statement has the form \code{continue;}. It ends the body of the next surrounding loop statement,
otherwise it may not be used. It is translated to
\begin{verbatim}
  c = (True,False,None)
\end{verbatim}

\subsubsection{Conditional Statements}

A conditional C statement has the form \code{if (e) s1} or \code{if (e) s1 else s2} where \code{e} is an expression
and \code{s1} and \code{s2} are statements. Let \code{(c1,v1,...,vn) = expr1} be the translation 
of \code{s1} and \code{(c2,w1,...,wm) = expr2} be the translation of \code{s2}.
If \code{e} has no side effects and translates to the Cogent expression \code{expr} we translate
the second form of the conditional statement to the binding
\begin{verbatim}
  (c,u1,...,uk) =
    if expr /= 0 then 
      let (c1,v1,...,vn) = expr1
      in (c1,u1,...,uk)
    else
      let (c2,w1,...,wm) = expr2
      in (c2,u1,...,uk)
\end{verbatim}
where \code{u1,...,uk} is the union of \code{v1,...,vn} and \code{w1,...,wm} in some order. 
Note that this closely corresponds to the translation 
of the conditional expression in Section~\ref{app-transfunction-expr}. In particular, the condition test 
\code{if expr /= 0 then} must be replaced by \code{if expr then} or \code{if not isNull(expr) then} as needed.

The first form of the conditional statement is translated as
\begin{verbatim}
  (c,v1,...vn) =
    if expr /= 0 then expr1
    else ((False,False,None),v1,...vn)
\end{verbatim}

If expression \code{e} has side effects the translation is extended as for the conditional expression.

As an example the translation of the conditional statement \code{if (i==0) return a; else a++;} is the binding
\begin{verbatim}
  (c,a) =
    if i==0 then 
      let c = (True,True,Some a)
      in (c,a)
    else
      let (c,a) = ((False,False,None),a+1)
      in (c,a)
\end{verbatim}
which can be simplified to
\begin{verbatim}
  (c,a) =
    if i==0 then ((True,True,Some a),a)
    else ((False,False,None),a+1)
\end{verbatim}

\subsubsection{Compound Statements}

A compound statement is a block of the form \code{\{ s1 ... sn \}} where every \code{si} is a statement or a declaration.
Declarations of local variables are treated as described in Section~\ref{app-transfunction-general}: if they contain an
initializer they are translated as a statement, otherwise they are omitted. This reduces the translation of a compound
statement to the translation of a sequence of statements.

We provide the translation for the simplest case \code{\{ s1 s2 \}} where \code{s1} and \code{s2} are statements.
The general case can be translated by rewriting the compound statement as a sequence of nested blocks, associating
from the right.

Let \code{(c,v1,...,vn) = expr1} be the translation of statement \code{s1} and \code{(c,w1,...,wm) = expr2} 
be the translation of statement \code{s2}. Then the translation of
\code{\{ s1 s2 \}} is
\begin{verbatim}
  (c,u1,...,uk) =
    let ((cc,cb,res),v1,...,vn) = expr1
    in if cc then ((cc,cb,res),u1,...,uk)
    else let (c,w1,...,wm) = expr2
    in (c,u1,...,uk)
\end{verbatim}
where \code{u1,...,uk} is the union of \code{v1,...,vn} and \code{w1,...,wm} in some order without the local variables 
declared in the block.

The values of local variables declared in the block are discarded. If such variables have linear type, they must
be allocated on the heap and disposed at the end of the block, as described in Section~\ref{app-transfunction-addrop}.

As an example, the compound statement \code{\{ if (i==0) return a; else a++; b = a; \}} is translated to the binding
\begin{verbatim}
  (c,a,b) =
    let ((cc,cb,res),a) = 
      if i==0 then ((True,True,Some a),a)
      else ((False,False,None),a+1)
    in if cc then ((cc,cb,res),a,b)
    else let (c,b) = ((False,False,None),a)
    in (c,a,b)
\end{verbatim}

If \code{s1} contains no jump statement the variable \code{cc} is bound to \code{False} and the translation
can be simplified to the binding
\begin{verbatim}
  (c,u1,...,uk) =
    let (c,v1,...,vn) = expr1
    and (c,w1,...,wm) = expr2
    in (c,u1,...,uk)
\end{verbatim}

As an example, the compound statement \code{\{ int i = 0; a[i++] = 5; b = i + 3; \}} is translated to the 
simplified binding
\begin{verbatim}
  (c,a,b) =
    let (c,i) = (ffn,0)
    and (c,i,a) = (ffn,i+1,setArr(a,i,5))
    and (c,b) = (ffn,i+3)
    in (c,a,b)
\end{verbatim}
which can be further simplified to
\begin{verbatim}
  (c,a,b) =
    let i = 0
    and (i,a) = (i+1,setArr(a,i,5))
    and b = i+3
    in (ffn,a,b)
\end{verbatim}

A compound statement used as the body of a C function is translated to a Cogent expression instead of a Cogent binding.
If the C function has result type \code{void} and modifies its parameters \code{pm1,...,pmn}, its translation is 
a Cogent function returning the tuple \code{(pm1,...,pmk)}. If the translation of the compound statement 
used as function body is the binding \code{(c,v1,...,vn) = expr}, the body is translated to the expression
\begin{verbatim}
  let (c,v1,...,vn) = expr
  in (pm1,...,pmn)
\end{verbatim}
If the function modifies no parameters
it returns the unit value \code{()}. Note that if the C function is correct, \code{c} contains the value \code{Some ()}.

Here all local variables and the unmodified parameters are discarded. If local variables have linear type, they must
be allocated on the heap and disposed at the end of the function, as described in Section~\ref{app-transfunction-addrop}.
If an unmodified parameter has linear type, it must be disposed at the end of the function.

If the C function returns a value its translation is a Cogent function returning the tuple \code{(v,pm1,...,pmk)}
where \code{v} is the original result value of the C function. Then the body is translated to the expression
\begin{verbatim}
  let ((_,_,res),v1,...,vn) = expr
  in res | None -> (defaultVal(),pm1,...,pmn)
         | Some v -> (v,pm1,...,pmn)
\end{verbatim}
where \code{defaultVal()} is as defined in Section~\ref{design-operations-default}. If the type of the original function
result \code{v} is not regular (in C: contains a pointer) \code{defaultVal} cannot be used, in this case a different
expression for the \code{None} alternative must be specified manually. Note that in this case the \code{None} alternative
is never used, if the C program is correct. Nevertheless, for Cogent to be correct some result value must be specified 
also for this case, it is irrelevant which value is used.

\subsubsection{Switch Statements}

\subsubsection{For Loops}

A \code{for} loop has the form \code{for (ee1; ee2; ee3) s} with optional expressions \code{eei} and a statement \code{s}. 
The first expression \code{ee1} can also be a declaration. The \code{for} loop can always be transformed to a \code{while}
loop of the form
\begin{verbatim}
  ee1;
  while (ee2) { s ee3; }
\end{verbatim}
therefore \code{e2} must evaluate to a scalar value, as for the condition in a conditional expression or statement.

Since \code{while} loops are not directly supported by Cogent and need additional work for proofs when translated by using
an abstract function, we do not use this transformation in general, instead, for certain forms of \code{for} loops we
translate them using functions from the Cogent standard library. This is possible, whenever a \code{for} loop is a 
``counted'' loop of the form
\begin{verbatim}must either
  for ( w=e1; w<e2; w=e3) s
\end{verbatim}
with a counting variable \code{w} of an unsigned integer type. The only free variable in \code{e3} must be \code{w} and
\code{w} must not occur free in \code{e2}. The \code{e1, e2, e3} must not have side effects.

If a \code{for} loop is not of this form it may be possible to rewrite it in C to that form. Specifically, this can be done 
if it is possible to rewrite the expressions \code{eei} as follows:
\begin{verbatim}
  ee1: ee1', w=e1
  ee2: w<e2 && ee2'
  ee3: ee3', w=e3
\end{verbatim}
Then the loop \code{for (ee1; ee2; ee3) s} can be rewritten as the counted loop
\begin{verbatim}
  ee1';
  for (w=e1; w<e2; w=e3) {
    if (!ee2') break;
    s ee3'
  }
\end{verbatim}
In other cases, especially if some of the \code{eei} are empty, it may still be possible to rewrite the loop as counted by
moving parts from before the loop or from the loop body into the \code{ei}.

Let \code{expri} be the translation of the \code{ei} and let \code{(c,v1,...,vn) = expr} be the translation of 
statement \code{s}. Let \code{w1,...,wm} be the variables occurring free in \code{expr} other than \code{w} and the \code{vi}.
Then the translation of the counted loop 
\begin{verbatim}
  for (w=e1; w<e2; w=e3) s
\end{verbatim}
is
\begin{verbatim}
  (c, v1,...,vn) = 
  let ((v1,...,vn),lr) = 
    seq32_stepf #{
      frm = expr1, to = expr2, 
      stepf = \w => expr3, 
      acc = (v1,...,vn), obsv = (w1,...,wm), 
      f = \#{acc = (v1,...,vn), obsv = (w1,...,wm), 
             idx = w} => 
        let ((cc,cb,res),v1,...,vn) = expr
        in ((v1,...,vn),
            if cb then Break (res) else Iterate ())
      }
  in lr | Iterate () -> ((False,False,None), v1,...,vn)
        | Break (None) -> ((False,False,None), v1,...,vn)
        | Break (res) -> ((True,True,res), v1,...,vn)
\end{verbatim}

The function \code{seq32\_stepf} is defined in the Cogent standard library in \code{gum/common/common.cogent}.

The variables \code{w,w1,...,wm,v1,...,vn} either occur free in the loop body or are modified in the loop body.
In both cases they must be declared in C before the counted loop, so they are defined in Cogent and can be used
when \code{acc} and \code{obsv} are set. The \code{w1,...,wm} must not be of linear type. Since they are used
in the loop body, depending on how often the body is executed they could either be used several times or not at all.
If a \code{wi} is of linear type the loop cannot be translated in this way and must be handled manually.

Since all \code{w1,...,wm} have a regular or readonly type the tuple \code{(w1,...,wm)} is a valid value for 
both \code{obsv} fields which have the readonly type \code{obsv!}.

The translation correctly handles all \code{return}, \code{break}, and \code{continue} statements which may occur 
in the body. 

Note that the translation is only possible if the type of the counting variable \code{w} can be represented in 
Cogent by the type \code{U32}.

If the expression \code{w=e3} can be rewritten as \code{w+=e3'} where \code{w} does not occur free in \code{e3'}
the counted loop can be translated using 
function \code{seq32} instead of \code{seq32\_stepf}. The translation has the same form as above, with the line 
setting \code{stepf} replaced by
\begin{verbatim}
      step = expr3', 
\end{verbatim}
where \code{expr3'} is the translation of \code{e3'}. Here, arbitrary other variables may occur free in \code{expr3'}.

In this case the counting variable \code{w} may also have a type which can be represented in Cogent by the type \code{U64}.
Then the translation has the same form but uses the function \code{seq64} instead of \code{seq32}.

If the expression \code{w=e3} can be rewritten as \code{w-=e3'} where \code{w} does not occur free in \code{e3'}
the counted loop can be translated as for \code{w+=e3'} using the function \code{seq32\_rev} instead of \code{seq32}.

If the translation can be done using \code{seq32} and the body does not contain any \code{break} or \code{return} statement 
the translation can be simplified using the function \code{seq32\_simpl} in the form
\begin{verbatim}
  (c, v1,...,vn) = 
  let w = expr1
  and (v1,...,vn,w1,...,wm,w) = 
    seq32_simple #{
      frm = w, to = expr2, step = expr3', 
      acc = (v1,...,vn,w1,...,wm,w), 
      f = \(v1,...,vn,w1,...,wm,w) => 
        let (_,v1,...,vn) = expr
        in (v1,...,vn,w1,...,wm,w)
      }
  in ((False,False,None), v1,...,vn)
\end{verbatim}
If the counting variable \code{w} is not used in the body (does not occur free in \code{expr}) this can further be simplified to
\begin{verbatim}
  (c, v1,...,vn) = 
  let (v1,...,vn,w1,...,wm) = 
    seq32_simple #{
      frm = expr1, to = expr2, step = expr3', 
      acc = (v1,...,vn,w1,...,wm), 
      f = \(v1,...,vn,w1,...,wm) => 
        let (_,v1,...,vn) = expr
        in (v1,...,vn,w1,...,wm)
      }
  in ((False,False,None), v1,...,vn)
\end{verbatim}

As an example, the counted loop
\begin{verbatim}
  for (i=0; i<size; i++) { 
    sum += a[i];
  }
\end{verbatim}
is translated to
\begin{verbatim}
  (c, sum) = 
  let i = 0
  and (sum,a,i) = 
    seq32_simple #{
      frm = i, to = size, step = 1, 
      acc = (sum,a,i), 
      f = \(sum,a,i) => 
        let sum = sum + getArr(a,i)
        in (sum,a,i)
      }
  in ((False,False,None), sum)
\end{verbatim}
where \code{a} must have a readonly Gencot array type. 

For the counted loop
\begin{verbatim}
  for (i=0; i<size; i++) { 
    if (a[i] == trg) return i;
  }
\end{verbatim}
the body translates to 
\begin{verbatim}
  c = if getArr(a,i) == trg 
      then (True,True,Some i)
      else (False,False,None)
\end{verbatim}
where again \code{a} must be of a readonly Gencot array type. The translation of the loop is
\begin{verbatim}
  c = 
  let ((),lr) = 
    seq32 #{
      frm = 0, to = size, step = 1, 
      acc = (), obsv = (a,trg), 
      f = \#{acc = (), obsv = (a,trg), idx = i} => 
        let (cc,cb,res) =
          if getArr(a,i) == trg 
          then (True,True,Some i)
          else (False,False,None)
        in ((),if cb then Break (res) else Iterate ())
      }
  in lr | Iterate () -> (False,False,None)
        | Break (None) -> (False,False,None)
        | Break (res) -> (True,True,res)
\end{verbatim}
which can be simplified to
\begin{verbatim}
  c = 
  let ((),lr) = 
    seq32 #{
      frm = 0, to = size, step = 1, 
      acc = (), obsv = (a,trg), 
      f = \#{obsv = (a,trg), idx = i} => 
        ((),if getArr(a,i) == trg 
            then Break (Some i) 
            else Iterate ())
      }
  in lr | Iterate () -> (False,False,None)
        | Break (None) -> (False,False,None)
        | Break (res) -> (True,True,res)
\end{verbatim}

\subsubsection{While Loops}

A \code{while} loop has the form \code{while (e) s} or \code{do s while (e);}. Since Cogent does not support recursive 
function definitions these loops cannot be translated in a natural way to Cogent.

To translate a \code{while} loop it may be rewritten in C as a counted \code{for} loop which can then be translated 
as described in the previous section. If that is not possible the loop must be put in an abstract function which is 
defined in C using the original \code{while} loop.

\subsection{Function Pointer Invocation}
\label{app-transfunction-pointer}

When a function pointer \code{fptr} shall be invoked in Cogent, it must be converted to the corresponding Cogent function
using \code{fromFunPtr[...](fptr)} or the macro \code{FROMFUNPTR(<enc>)(fptr)} where \code{<enc>} is the encoding of the 
corresponding function type (see Section~\ref{design-operations-function}).

In C a function pointer may be \code{NULL}, therefore it is typically tested for being valid before the
referenced function is invoked, such as in 
\begin{verbatim}
  if( fptr == NULL ) ...
  else fptr( params );
\end{verbatim}
The conversion function \code{fromFunPtr} returns a result of the variant type \code{Result fun ()} where \code{fun} is the 
Cogent function type. So the corresponding invocation in Cogent has the form
\begin{verbatim}
  FROMFUNPTR(<enc>)(fptr)
  | Error () -> ...
  | Success f -> f( params )
\end{verbatim}

In Cogent the \code{Error} case does not only cover the case where the function pointer is \code{NULL}, it covers
all cases where the function referenced by the pointer is not known by Cogent. A function is only known by Cogent
if there is a Cogent definition for it, either as a Cogent function or as an abstract function.

Function pointers are not needed for Cogent functions which are only invoked from Cogent, then the Cogent function can 
be assigned and stored directly. Function pointers are only relevant if they are also used in C code external to
the Cogent compilation unit. So there are two application cases:
\begin{itemize}
\item A function which is defined in C and is passed as a function pointer to Cogent for invocation there. As
described in Section~\ref{design-modular}, this invocation requires an exit wrapper. The function \code{fromFunPtr}
converts the function pointer to the exit wrapper function. If there is no exit wrapper, \code{fromFunPtr}
returns an error. To be consistent, function \code{toFunPtr} converts every exit wrapper to a pointer to the
wrapped external function.
\item A function which is defined in Cogent and is passed as a function pointer to C for invocation there. As
described in Section~\ref{design-modular}, this invocation requires an entry wrapper. Entry wrappers are automatically
generated for all translated functions which had external linkage in C. For all these functions \code{toFunPtr}
converts them to a pointer to the entry wrapper. To be consistent, function \code{fromFunPtr} converts pointers
to entry wrappers to the corresponding Cogent functions. For translations of functions with internal linkage
\code{toFunPtr} converts to a pointer to the Cogent function. If such a pointer is invoked from C the invocation
will normally fail, because of different parameter and result types. In the current version of Gencot this must
be handled manually.
\end{itemize}

Exit wrappers are automatically generated by Gencot for functions which are invoked from the Cogent compilation
unit (see Section~\ref{impl-ccomps-externs}), determined with the help of the call graph (see 
Section~\ref{impl-ccode-callgraph}). However, functions which are \textit{only} invoked through function pointers
are not detected by the call graph (the invoked function pointer is detected but not which actual functions
may have been assigned to the function pointer), so no exit wrapper will be generated and \code{fromFunPtr}
will return an error for the corresponding function pointer. Moreover, if there are no other Cogent functions
of the same function type, the Cogent program will be translated to inconsistent C code: the invocation of the 
converted function pointer will be translated using a dispatcher function which does not exist.

Gencot supports forcing exit wrapper generation for functions not detected by the call graph, by specifying them
explicitly in the file \code{<package>.gencot-externs} when generating the unit files by executing \code{gencot unit}
(see Section~\ref{impl-all-gencot}). The following additional steps are
required when forcing an exit wrapper for an external C function \code{f} which is not detected by the call graph:
\begin{itemize}
\item To generate the correct type for the exit wrapper a parameter modification description is required for 
\code{f}. Since the required descriptions are also determined using the call graph, \code{f} must additionally
be specified explicitly when generating descriptions for external functions using \code{parmod externs}. The
\code{parmod} script reads the same file \code{<package>.gencot-externs} (see Section~\ref{impl-all-parmod}),
so this happens automatically. However, \code{parmod externs} does not generate the descriptions, it only selects 
them from a file given as input. Therefore the file containing the definition of \code{f} must be processed 
by \code{parmod init} in addition to the files processed as described in Section~\ref{app-parmod-extern} and the 
resulting descriptions must be added to the file input to \code{parmod externs}.
\item Even if explicitly specified, \code{gencot unit} generates exit wrappers only for functions which are declared
in one of the source files belonging to the Cogent compilation unit (usually the declaration will be in a \code{.h}
file included by a source file). If \code{f} is only invoked through a function pointer it may be the case that
the declaration of \code{f} is not present in either Cogent compilation unit source file. In this case a ``pseudo
source'' must be added to the Cogent compilation unit which only includes the \code{.h} file where \code{f}
is declared. More generally, it should include all \code{.h} files with declarations of functions for which an
exit wrapper shall be forced and which are not included by regular sources in the Cogent compilation unit.
\end{itemize}

\subsection{The Null Pointer}
\label{app-transfunction-null}

Translating C code which uses the null pointer is supported by the abstract data type \code{MayNull} defined
in \code{include/gencot/MayNull.cogent} (see Section~\ref{design-operations-null}).

A typical pattern in C is a guarded access to a member of a struct referenced by a pointer:
\begin{verbatim}
  if (p != NULL) res = p->m;
\end{verbatim}
In Cogent the value \code{p} has type \code{MayNull R} where \code{R} is the record type with field \code{m}. 
Then a translation to Cogent is
\begin{verbatim}
  let res = roNotNull p 
            | None -> dflt
            | Some s -> s.m
      !p
\end{verbatim}
Note that a value \code{dflt} must be selected here to bind it to res if the pointer is \code{NULL}. Also note that the access is
done in a banged context for p. Therefore it is only possible if the type of \code{m} is not linear, since otherwise the result
cannot escape from the context.

Another typical pattern in C is a guarded modification of the referenced structure:
\begin{verbatim}
  if (p != NULL) p->m = v;
\end{verbatim}
A translation to Cogent is
\begin{verbatim}
  let p = notNull p 
          | None -> null ()
          | Some s -> mayNull s{m = v}
\end{verbatim}
where the reference to the modified structure is bound to a new variable with the same name \code{p}. 
Note that in the None-case the result cannot be specified as 
\code{p} since this would be a second use of the linear value \code{p} which is prevented by Cogent.

Alternatively this can be translated using the function \code{modifyNullDflt}:
\begin{verbatim}
  let p = fst (modifyNullDflt (p, (setFldM, v)))
\end{verbatim}
using a function \code{setFldM} for modifying the structure.

\subsection{The Address Operator \code{\&}}
\label{app-transfunction-addrop}

The address operator \code{\&} is used in C to determine a pointer to data which is not yet accessed through a 
pointer. The main use cases are
\begin{itemize}
\item determine a pointer to a local or global variable as in the example
\begin{verbatim}
  int i = 5;
  int *ptr = &i;
\end{verbatim}

\item determine a pointer to a member in a struct as in the example
\begin{verbatim}
  struct ii { int i1; int i2; } s = {17,4};
  int *ptr = &(s.i2);
\end{verbatim}

\item determine a pointer to an array elemnt as in the example
\begin{verbatim}
  int arr[20];
  int *ptr = &(arr[5]);
\end{verbatim}

determine a pointer to a function as in the example
\begin{verbatim}
  int f(int p) { return p+1; }
  ...
  int *ptr = &f;
\end{verbatim}
\end{itemize}

In all these cases the pointer is typically used as reference to pass it to other functions or store it
in a data structure.

The binary compatible Cogent equivalent of the pointer is a value of a linear type. However, there is
no Cogent functionality to create such values. Hence it must be implemented by an abstract function.

\subsubsection{Address of Variable}

In the first use case there are several problems with this approach. First, there is no true equivalent
for C variables in Cogent. Second, it is not possible to pass the variable to the implementation of the
abstract function, without first determining its address using the address operator. Third, if the address
operator is applied to the variable in the implementation of the abstract function, the Isabelle c-parser
will not be able to process the abstract function, since it only supports the address operator when 
the result is a heap address.

All these problems can be solved by allocating the variable on the heap instead. Then the variable definition
must be replaced by a call to the polymorphic function \code{create} (see Section~\ref{design-operations-pointer}) and 
at the end of its scope a call to the polymorphic function \code{dispose} must be added. Then the address
operator need not be translated, since \code{create} already returns the linear value which can be 
used for the same purposes. The resulting Cogent code for a variable of type \code{int} initialized to \code{5}
would be
\begin{verbatim}
  create[EVT(CPtr U32)] heap
  | Success (ptr,heap) ->
    fst INIT(Full,CPtr U32) (ptr,#{cont=5})
    | Success ptr ->
      let  ... use ptr ...
      in dispose (fst CLEAR(Simp,CPtr U32) (ptr,()),heap)
    | Error eptr -> dispose (eptr,heap)
  | Error heap -> heap
\end{verbatim}
where \code{INIT(Full,CPtr U32)} is used to initialize the referenced value. Here, the result of the expression is
only the heap, in more realistic cases it would be a tuple with additional result values.

The drawback of this solution is that it is less efficient to allocate the variable on the heap, than to use a 
stack allocated variable. If it is only used for a short time, a better solution should be created manually.

\subsubsection{Address of Struct Member}

The second use case cannot be translated in this way, since the referenced data is a part of a larger structure.
If it is separated from the structure and allocated on the heap, the structure is not binary compatible any more.

If the overall structure is not allocated on the heap, the same three problems apply as in the first use case.
This can be solved in the same way, by moving the overall structure to the heap. Then it can be represented
by the linear Cogent type
\begin{verbatim}
  type Struct_Cogent_ii = { i1: U32, i2: U32 }
\end{verbatim}

If the overall structure in Cogent is readonly an abstract polymorphic function \code{getrefFldI2}
can be used to access the Cogent field through a pointer. This is an instance of the general \code{getref} operation
for records as described in Section~\ref{design-operations-record}.

If the overall structure is modifyable, determining a pointer to the field would introduce sharing for the
field, since it can be modified through the pointer or by modifying the structure. A safe solution is to use 
an abstract polymorphic function \code{modrefFldI2} which is an instance of the general \code{modref} operation
for records as described in Section~\ref{design-operations-record}.

\subsubsection{Address of Array Element}

The third use case is similar to the second. It often occurs if the array itself is represented by a pointer to its first
element (see Section~\ref{app-transtype-arrpoint}). This case could simply be replaced by using the element index instead of a 
pointer to the element. The array index is nonlinear and thus easier to work with. However, this solution is not binary
compatible, if the element pointer is also accessed outside the Cogent compilation unit.

A binary compatible solution can be achieved in a similar way as for struct members. The first prerequisite for it is
to allocate the array on the heap.

Then the polymorphic functions \code{getrefArr}, \code{getrefArrChk}, \code{modrefArr}, and \code{modrefArrDflt}
(see Section~\ref{design-operations-array}) can be used for working with pointers to elements.

\subsubsection{Address of Function}

The last use case is translated in a specific way for function pointers, using the translation function
\code{toFunPtr} (see Section~\ref{design-operations-function}), which is generated by Gencot for all function
pointer types. The resulting Cogent code has the form
\begin{verbatim}
  Cogent_f : U32 -> U32
  Cogent_f p = p+1
  ...
  let ptr = TOFUNPTR(FXU32X_U32) Cogent_f
  in ...
\end{verbatim}
In this case \code{ptr} has the nonlinear type \code{\#CFunPtr\_FXU32X\_U32} in Cogent and may freely be copied and
discarded in its scope.

