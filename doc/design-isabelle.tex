After Gencot has translated C code to Cogent, the Cogent compiler will generate a logic
based representation of the code and a proof that the generated C code refines that representation.
Both the representation (``shallow embedding'') and the proofs are generated in Isabelle notation. 

However, the abstract types and functions used in the Cogent code are not covered by this Isabelle 
code. Since Gencot uses several specific abstract types and functions to represent the C types (as 
described in Sections~\ref{design-types} and~\ref{design-operations}), the corresponding representations
and refinement proofs must be added to the Isabelle code to fully cover a C program translated by 
Gencot. Since the semantics of these types and functions is defined by Gencot, Gencot is able to 
automatically generate these parts of the Isabelle code.

\subsection{Representing Gencot Types}
\label{design-isabelle-types}

Specific treatment is necessary whenever Gencot uses abstract types to represent a C type in Cogent.
Most C types are mapped to Cogent using the normal Cogent types in specific ways. In these cases the 
Cogent compiler already generates corresponding Isabelle code. However, also in some of these cases 
Gencot modifies that code.

\subsubsection{Isabelle Types Generated by Cogent}

The Isabelle code for representing all Cogent types is generated by Cogent in a file \code{X\_ShallowShared\_Tuples.thy}
where \code{X} is a program specific prefix. The code consists of
\begin{itemize}

\item a type declaration for every abstract Cogent type, using the same type name as in Cogent.

\item a record definition for every equivalence class of record types occurring in the Cogent program. Two record
types are equivalent, if they have the same field names in the same order. If there is a type synonym defined
for the record type in Cogent (one of) the synonym name is used for the record, otherwise a generated name of
the form \code{T<nr>} is used. For every Cogent field name \code{x} the name $\code{x}_\code{\small{f}}$ is used in Isabelle.

Additionally, Cogent tuple types are represented by records with field names
\code{p1}, \code{p2}, ... and the corresponding records are defined. The record for pairs always has the name
\code{RR}, the names for the other tuple records are determined as described above.

\item a datatype definition for every variant type occurring in the Cogent program. The type name is determined 
as for the records. As names for the alternative constructors the Cogent tag names are used.

\item a type synonym definition for every Cogent type definition. For every Cogent type name \code{X} the
type synonym $\code{X}_\code{\small{T}}$ is defined in Isabelle.

\end{itemize}

Since Gencot uses tuple types in its predefined operations, it is necessary to know the names of the records for
representing tuples in Isabelle in advance, so that Isabelle specifications can be defined by Gencot for these 
operations. Gencot uses the include file \code{Tuples.cogent} which contains type synonyms \code{Tup<nr>} for 
the tuple types from 3 to 9 components. Whenever another Gencot include file uses tuple types with more than 
two components it includes this file, so that the tuple records in Isabelle are named accordingly.

\subsubsection{Gencot Array Types}

As described in Section~\ref{design-types-array} Gencot represents every C array type \code{<el>[<size>]} in 
Cogent with the help of type
\begin{verbatim}
  type CArr<size> el = {arr<size>: el#[<size>]}
\end{verbatim}
as \code{CArr<size> <el>}. For every \code{<size>} occurring in the program a separate generic type of this form 
is defined. Cogent translates this type definition to Isabelle as\\[1ex]
\hspace*{2ex}\code{record 'a CArr<size> =} $\code{arr<size>}_\code{\small{f}}$ \code{:: 'a}\\
\hspace*{2ex}$\code{type\_synonym 'el CArr<size>}_\code{\small{T}}$ \code{= "'el list CArr<size>"}\\[1ex]
As in Cogent the array is wrapped in a single-field record, but it is represented by a list of arbitrary length.

Gencot takes a slightly different approach where the lists are restricted to the fixed length \code{<size>}.
To achieve this, the last line of every array type definition as above is modified to\\[1ex]
\hspace*{2ex} $\code{type\_synonym 'el CArr<size>}_\code{\small{T}}$ \code{= "(<size>, 'el) FixedList CArr<size>"}\\[1ex]
where the type \code{FixedList} is defined for all array types by the Isabelle type definition
\begin{verbatim}
  typedef (overloaded) ('n::len, 'a) FixedList =  
    "{x::'a list. length x = LENGTH('n)}"
\end{verbatim}
so that it includes the fixed length specified by parameter \code{'n}.

\subsubsection{Type \code{MayNull}}

\subsection{Specifying Gencot Operations}
\label{design-isabelle-operations}

\subsubsection{Gencot Array Operations}

The Gencot array operations as specified in Section~\ref{design-operations-array} are generic in three aspects
\begin{itemize}
\item the array size
\item the array element type
\item the index type
\end{itemize}
The second and third aspect are handled by usual polymorphism in Isabelle. The first aspect could be handled in the 
same way due to the definition of \code{FixedList} which takes the size as a type parameter. However, every size 
uses an own wrapper record. Since the size is syntactically coded into the field name, all these wrapper records
are different defined types and cannot be covered by polymorphism.

The solution taken by Gencot is to use a locale \code{CArrFuns} to handle the wrapper records in a common way. It
is defined as
\begin{verbatim}
  locale CArrFuns = fixes 
    fld :: "'arr => ('n::len, 'el) FixedList" and 
    wrp :: "('n, 'el) FixedList => 'arr"
    ...
\end{verbatim}
where the locale parameters \code{fld} and \code{wrp} correspond to the field access function and the constructor 
function of the wrapper record. The type \code{'arr} is the type of the wrapper record which is used to actually
represent the C array type in Isabelle.

For every size used in the program Gencot creates an interpretation of the locale:\\[1ex]
\hspace*{2ex}\code{interpretation CArrFuns<size>:}\\
\hspace*{4ex}$\code{CArrFuns arr<size>}_\code{\small{f}}$ \code{CArr<size>.make}\\[1ex]
using the actual field access function and constructor of the wrapper record as arguments.

As for all abstract functions Cogent generates for every Gencot array function such as \code{getArr} a constant declaration:
\begin{verbatim}
  consts getArr :: "'arr x 'idx => 'el"
\end{verbatim}

Gencot adds the definition for every such function in three steps. The first step is to define a corresponding function
for type \code{FixedList}:
\begin{verbatim}
  definition getArr' :: 
    "('n::len, 'el) FixedList => 'idx::len word => 'el"
  where ...
\end{verbatim}
This function is generic in all three aspects: the array size \code{'n}, the index bitlength \code{'idx}, and the 
element type \code{'el}.

The second step is to define a corresponding function for the wrapper record in the locale \code{CArrFuns}:
\begin{verbatim}
  definition getArrFxd :: "'arr x ('idx::len) word => 'el"
  where "getArrFxd x == let (a,i) = x in getArr' (fld a) i"
\end{verbatim}
It simply uses the locale parameter \code{fld} to lift \code{getArr'} to the wrapper record.

The third step uses ad hoc overloading to link this function to the constant generated by Cogent:
\begin{verbatim}
  adhoc_overloading getArr CArrFuns<size>.getArrFxd
\end{verbatim}
This is done for every \code{<size>} after the corresponding locale interpretation.

Note that the actual array size is not specified in the locale interpretation, it still remains generic.
Only when an array function is invoked for an actual array value, the type of the array includes the array 
size and makes it available to the function definition where it can be used to check whether the index value
is valid.

\subsubsection{Operations for Type \code{MayNull}}

\subsection{Specifying Cogent Operations}
\label{design-isabelle-cogentops}

Cogent defines several abstract function in its standard library. However, as of February 2021 the Cogent distribution
does not contain Isabelle specifications for them. Therefore Gencot provides Isabelle specifications for all such
functions which are used by Gencot.

\subsubsection{Iteration Functions}

The following Cogent iteration functions are used and supported by Gencot: \code{seq32}, \code{seq32\_simple}. They 
correspond to counted for-loops in C, where the counter is a 32 bit word. With \code{seq32} the loop can be terminated 
early by a break statement. In all cases the loop body is passed as a function argument to the loop function, making
the loop functions higher-order.

The iteration functions support arbitrary step amounts for the counter. If the step amount is greater than 1 even a 
for-loop with a specified end value for the counter may not terminate due to overflow of the counter. This happens if
the last counter value \code{i} is lower than the end value and \code{i+step} is expected to be greater than the end
value but overflows the 32 bit arithmetics and restarts with a value again lower than the end value. This may lead to
counting several times to the end value and then stop, or even run the loop forever.

This behavior is always expected to be a programming error and should not occur. To prove termination Gencot uses an
additional guard \code{seq32\_term to step} which excludes this behavior depending on end value \code{to} and step
amount \code{step} by
$$ \code{step} > 0 \wedge \code{(unat to)} + \code{(unat step)} \le 2^32$$
It also excludes the case \code{step = 0} which would also lead to non-termination. The guard guarantees that as 
long as the loop has not terminated, so that the counter is still lower than \code{to}, adding the \code{step} will 
not cause an overflow. That a bit stronger than necessary but this way it becomes much simpler. Note that the guard 
is always satisfied if \code{step = 1}.

Every iteration function \code{seq} is specified in two parts. The core specification is a recursive function 
\code{seq\_imp} which counts with natural numbers from zero in steps of one, so termination and induction are 
straightforward. The function \code{seq} is then specified by an axiom which takes the guard as a premise and 
calculates the number of iterations from start, step, and end values of the counter with the help of a function 
\code{seq32\_cnt} and invokes \code{seq\_imp} accordingly.

\subsection{Reasoning Support for Gencot Operations}
\label{design-isabelle-gencotrul}

Gencot provides some rules for reasoning about Cogent functions which use Gencot operations. These rules can be used
to support a higher level reasoning instead of unfolding the actual definitions given for the Gencot operations.

\subsubsection{Gencot Array Operations}

Gencot provides a simple abstract data type for arrays of arbitrary size. It consists of the four functions
\begin{verbatim}
  siz :: 'arr => nat
  vld :: 'arr => nat => bool
  elm :: 'arr => nat => 'el
  upd :: 'arr => nat => 'el => 'arr
\end{verbatim}
where \code{'arr} is the array type (actually the type of the wrapper record) and \code{'el} is the array element type.
Function \code{siz} returns the number of elements, \code{vld} tests whether an index value is valid for an array (i.e.,
it is lower that the number of elements), \code{elm} accesses an element by an index counting from zero, and \code{upd}
updates the array at the specified index. These functions are overloaded for all array sizes used in the actual Cogent 
program.

The abstract data type is specified by the following rules which hide the underlying fixed list and wrapper record and
thus simplify resoning about arrays:\\[1ex]
  \hspace*{2ex}\code{sizArr: siz a = <size according to type of a>}\\
  \hspace*{2ex}\code{vldArr: vld a n = n < <size according to type of a>}\\
  \hspace*{2ex}\code{updArr: vld a i ==> elm (upd a i e) i = e}\\
  \hspace*{2ex}$\code{updArrFrame: vld a i} \wedge \code{vld a j} \wedge \code{i} \neq \code{j ==> elm (upd a i e) j = elm a j}$\\[1ex]
The first two are registered as simplifier rules so that \code{siz} and \code{vld} are automatically eliminated. The last
two rules are also intended for simplification, however they introduce additional goals for the premises and must be
applied explicitly with the \code{subst} method.

Next, for every Gecot array operation \code{op} two rules \code{opValid} and \code{opInvalid} are provided which 
reduce the operation to the abstract data type functions. The first rule covers the case of valid index values, the second
the case of invalid index values. Since they also have premises they must also be applied with the \code{subst} method.

Finally, the rule\\[1ex]
  \hspace*{2ex}$\code{eqArr: (a1 = a2) =} \forall \code{i. (vld a1 i) ==> ((elm a1 i) = (elm a2 i))}$\\[1ex]
defines extensional array equality if the elements are equal for all valid indices. 

\subsection{Reasoning Support for Cogent Operations}
\label{design-isabelle-cogentrul}

Gencot also provides some rules for reasoning about Cogent functions which use the Cogent abstract functions described in
Section~\ref{design-isabelle-cogentops}.

\subsubsection{Iteration Functions}

Gencot provides induction rules for the Cogent iteration functions \code{seq32} and \code{seq32\_simple}. They have in common
that they prove a predicate for the loop result by proving that it holds before the loop starts and is preserved by every 
single iteration. As third premise the rules take the termination condition \code{seq32\_term} (see 
Section~\ref{design-isabelle-cogentops}).

For function \code{seq32\_simple} the body function takes as input and output a single accumulator value. Thus we can prove
predicates which only depend on this accumulator value and not on the number of iterations performed. The induction rule
\code{seq32\_simple\_induct\_f} can be used to prove such predicates of the form
\begin{verbatim}
  (P acc)
\end{verbatim}
for accumulator values \code{acc}. Here the induction step goes from \code{(P acc)} to \code{(P (f acc))} where \code{f} is
the body function.

The accumulator value property may additionally depend on the number of iterations performed. That is often the case when the loop 
iterates through an array, processing one element in every iteration. The induction rule \code{seq32\_simple\_induct} can be used
to prove such predicates of the form
\begin{verbatim}
  (P n acc)
\end{verbatim}
where \code{n} is the natural number of iterations performed. Here the induction step goes from \code{(P n acc)} to 
\code{(P (Suc n) (f acc))}. It has as additional assumption that the iteration counter \code{n} is bounded by the number
of iterations performed by the loop in the conclusion. This can be useful for proving the induction step, e.g. if the loop
counter is used an an array index to prove that all accesses are valid.

Function \code{seq32} is more complex in two aspects. First, the body function takes as argument a record \code{\{acc,idx,obsv\}}
with the current loop counter value \code{idx} and an ``observed'' value \code{obsv} which is not modified, in addition to the 
accumulator value. Second, it returns a pair \code{(acc,res)} which together with the new accumulator value \code{acc} contains 
a variant value \code{res} which is either \code{Iterate ()} or \code{Break r} with some value \code{r}. In the second case
the loop is terminated, as when using a \code{break} statement in C. The pair returned by the last iteration is also the result 
of the loop as a whole.

Since the loop counter is always passed explicitly to the body function, Gencot provides only the induction rule \code{seq32\_induct}
which can be used to prove predicates of the form
\begin{verbatim}
  (P n (acc,res) obsv)
\end{verbatim}
which may depend on the loop counter value, the pair \code{(acc,res)} returned by the body function, and the observed value \code{obsv}.
Here the induction step must handle the two cases for \code{res}: If it is \code{Iterate ()} the step goes from \code{(P n (acc,res) obsv)}
to \code{(P (Suc n) (f \{acc,idx,obsv\}) obsv)} where \code{idx} is the loop counter value calculated from \code{n}. If \code{res} is
\code{Break r} the body function is not applied anymore, hence the step goes from \code{(P n (acc,res) obsv)} to 
\code{(P (Suc n) (acc,res) obsv)} where only the iteration counter is increased, so that the rule can conclude \code{P} for the 
number of iterations calculated by \code{seq32\_cnt} without taking the early termination into account. As for \code{seq32\_simple\_induct}
the step has the additional assumption that the iteration counter \code{n} is bounded by the number
of iterations performed by the loop in the conclusion.

\subsection{Refinement Proof for Gencot Operations}
\label{design-isabelle-gencotprf}

\subsection{Refinement Proof for Cogent Operations}
\label{design-isabelle-cogentprf}
