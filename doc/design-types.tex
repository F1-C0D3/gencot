
Here we define rules how to map common C types to binary compatible Cogent types. Since the usefulness of a mapping
also depends on the way how values of the type are processed in the C program, the resulting types may require manual 
modification.

\subsection{Item Properties}
\label{design-types-itemprops}

The Cogent type system reflects more and other data properties than the C type system, e.g., linear types
and readonly types. Instead of simply determining these properties automatically, Gencot supports declaring 
them by the developer. Before translating a C program to Cogent, the developer may specify properties
for several ``items'' in the C program. Gencot reads these declarations in addition to the C source code
and uses them when determining the Cogent type for the translated item.

\subsubsection{Items}

An item for which properties can be declared for Gencot may be every entity in the C program which has a declared type.
An item may also be ``virtual'' in the sense that it is not an entity in the C program, but Gencot introduces 
a corresponding translation in the Cogent program. An example are additional function parameters introduced 
wih the help of virtual items.

Items may be global, such as global variables and functions, or they may be sub-items of other items, such as a
struct member or a function parameter. Sub-items are determined by the type of the main item. If that type is
specified by a common identifier (typedef name or tag name) for several main items together, properties for
a sub-item may not be declared individually anymore, instead, they must be declared for the corresponding sub-item
of all main items together. Such sub-items are called ``collective items'' here.

Items may also be local variables defined in a function body. Gencot identifies local items by their C identifier.
The C identifier need not be unique, not even in the same function, due to the block structure of C function bodies
with the possibility to define variables in every block. Therefore the identifiers of local items are not 
unique in the current Gencot version and thus it does not make sense to declare properties for local items. 

There are two kinds of global items: C variables (also called ``objects'' in the C standard) and C functions, which
are defined on toplevel (called an ``external definition'' in the C standard), i.e., not locally in a function. Note that
these two kinds only differ in their types: functions have a derived function type, objects may have all other types.

Global items are always named by a C identifier. Depending on the linkage, the identifier may be unique (external linkage)
or it may only be unique for the compilation unit (internal linkage). Gencot uses the C identifier to identify global 
items. In the case of internal linkage the file name of the compilation unit is used for disambiguation.

Gencot supports property declarations for the following kinds of sub-items:
\begin{itemize}
\item the members of a struct or union
\item the elements of an array
\item the data referenced by a pointer
\item the parameters and the result of a function
\end{itemize}
Members are identified by their name. Parameters are identified by their name or by their position. The other
sub-items are identified using specific mechanism.

Depending on their type, sub-items may again have sub-items. Gencot supports property declarations for arbitrary
deep sub-item nesting.

Global items are always individual. A sub-item is individual only if
\begin{itemize}
\item the containing item is individual
\item the containing item's type is not specified by a defined type identifier.
\end{itemize}
This means that the containing item's type must be an expression for a derived type.

If a struct or union declares a tag, all members can only be used as collective items, since the tag makes it possible
to assign the type to different items so that a member declaration may be shared by several sub-items. Gencot does
not check whether a tagged struct or union is only used for a single item, it always treats its members as collective.

A tagless struct or union can only be used at the place where it syntactically occurs, this may suggest that it may 
only be the type of one item and thus its sub-items cannot be shared. However, a tagless struct or union can be used as 
base type for several different declarators which may declare different items having this base type. It may even be
used in a typedef to define one or more typedef names for it which may then be used to define any number of items
with these types. Therefore Gencot also treats sub-items of tagless struct and unions always as collective.

In a similar way sub-items are collective, if the containing item's type is specified by a defined type identifier
(a ``typedef name''). As an example, if two function pointers are defined by
\begin{verbatim}
  int (*fp1)(int i, char* p);
  int (*fp2)(int i, char* p);
\end{verbatim}
the parameter \code{p} occurs as individual sub-items of the individual items \code{fp1} and \code{fp2}
and may have different properties for both. If the function pointers are instead defined by
\begin{verbatim}
  typedef int (*fptyp)(int i, char* p);
  fptyp fp1, fp2;
\end{verbatim}
using a typedef name for the common function pointer type, the parameter \code{p} occurs only once, as collective sub-item of
the collective item \code{fptyp} and its properties may not be different for \code{fp1} and \code{fp2}.
The reason is that also in the Cogent code a common type is defined and used for the definition of both pointers. This implies,
that no different properties can be applied to their function parameters, since there is only one common translation of the 
function type.

If, however, these definitions are extern to the Cogent compilation unit and the name \code{fptyp} is not used elsewhere
in the Cogent compilation unit, it is resolved as described in Section~\ref{design-modular} and never used in the Cogent code. 
There every function pointer is defined using a separate copy of the translated function type. In this case
Gencot again uses two individual sub-items \code{p} for the individual items \code{fp1} and \code{fp2}, which implies, that different
properties could be defined for them. This is ok, since the function type can be translated differently for both
items.

Basically, collective items are identified by their type. If a property is declared for a type, it applies to 
all items which are declared to have this type. Additionally, for a collective item its sub-items can be determined
in the same way as for an individual item. 

Gencot does not support all kinds of C types to identify collective items. Only the following kinds are supported:
\begin{itemize}
\item typedef names,
\item tag names and generated names for tagless struct/union types,
\item derived pointer types with a supported base type.
\end{itemize}
Note that collective items have the form of a generalization hierarchy, where a collective item may include one or 
more other collective items which are more specific. This hierarchy is built by using typedef names.

For example, if the C program contains the type name definition 
\begin{verbatim}
  typedef struct str { int m1,m2; } str_t;
\end{verbatim}
the collective item identified by \code{struct str} corresponds to all items declared to have the type \code{struct str},
whereas the collective subitem \code{m1} of \code{str} corresponds to all members \code{m1} of such items. The collective
item identified by the type \code{struct str*} corresponds to all items declared as pointers to \code{str} structs.
The collective item identified by the type \code{str\_t} identifies all items declared to have this type. In general 
this is semantically a subset of all items declared to have the type \code{struct str}, therefore \code{str\_t} corresponds
to a more specific collective item than \code{struct str}. Properties declared for \code{struct str} also apply to items
with declared type \code{str\_t} but not vice versa.

Gencot does not support primitive types for item identification, because (currently) there are no properties supported
for them and they have no sub-items. Moreover, it seems not useful to declare a property for \textit{all} items of
a primitive type. Gencot also does not support derived array types for item identification because (currently) the only 
property supported for them is Read-only and it does not seem useful to declare this for all items of a certain array 
type. It could be useful to declare properties for the elements of all such items, but Gencot does not realize that.
For derived function types or their parameters and results it could be useful to declare properties, but this is not
implemented by Gencot either. The main reason for not supporting derived array and function types is the difficulty
for defining a unique syntactical representation which is needed for the current implementation of the item property
mechanism as described in Section~\ref{impl-itemprops}.

\subsubsection{Properties}

The properties which can be declared for an item are usually specific for the item's type. If a property is declared
for an item for which its type does not support the property, the property is silently ignored by Gencot.

Gencot supports declaring the following item properties.

\begin{description}
\item[Read-Only]

The Read-Only property is supported for items of arbitrary type. If declared, the type of the translated item is
made readonly by applying the Cogent bang operator \code{!} to it.

Note, that for several types the Cogent bang operator has no effect, these cases are equivalent
to ignoring the property.

Note also that semantically the Read-Only property does not apply to the item itself, but to the item’s possible 
values. The item’s value can still be replaced although the item has been declared as Read-Only.

\item[Const-Val]

The Const-Val property is only supported for global variables, i.e. for toplevel items which are neither types nor 
functions. Semantically it means that the variable value never changes, the variable always has its initial value. 
In this case Gencot translates the variable to a parameterless access function which returns the variable value. 

The Const-Val property implies the Read-Only property but is stronger. If a global variable has a pointer type, 
the Read-Only property means that the data referenced by the pointer cannot be modified, whereas the Const-Val 
property means that additionally the variable value itself cannot be modified.

\item[Not-Null]

The Not-Null property is only supported for items of pointer type. If declared, the type of the translated item
is not wrapped by the generic \code{MayNull} type (see Section~\ref{design-types-pointer}). 

Although Gencot translates array types in the same way as pointer types, it never wraps them by \code{MayNull}.
This has the same effect as specifying the Not-Null property for all items of array type, therefore it is ignored
for items of array type.

\item[No-String]

The No-String property is only supported for items of type \code{const char *}. If declared, Gencot uses the  
type \code{(CPtr U8)!} instead of \code{String} for the translated item (see Section~\ref{design-types-pointer}).

\item[Heap-Use]

The Heap-Use property is only supported for items of function type. If declared, the parameters and
result of the translated function are extended by a component of type \code{Heap} (see Section~\ref{design-types-function}).
In the body of the function definition the name \code{heap} is used for this additional component. If there
is already another parameter named \code{heap} it is named \code{globheap<n>} where \code{<n>} is the lowest
number starting with 1 so that there is no other parameter with this name.

\item[Add-Result]

The Add-Result property is only supported for parameter items. If declared, a component of the same type
is added to the result, intended for returning a modified value of the parameter (see Section~\ref{design-types-function}). 
The Add-Result property is ignored, if it is combined with the Read-Only property.

If the function has a non-void result and at least one parameter has the Add-Result property the result type is changed
to a tuple type with the original result as first component followed by components for all parameters with the Add-Result
property in the parameter order. If the function result is void the result tuple contains only the parameters with 
Add-Result property. If there is only one such parameter the result consists only of the corresponding component.

\item[Global-State]

The Global-State property has an additional argument which must be an integer value greater or equal to zero.
Every argument represents a distinct global variable in the C program. The property is supported for global 
variables and for virtual parameter items. 

A Global-State property declared for a global variable introduces an association between the variable and the 
numerical argument of the property. If more than one Global-State property is declared for a global variable, only
the first one is used, all others are ignored.

If a Global-State property is declared for a parameter item, it must be a virtual item, i.e., the parameter may not 
exist in the C program. A corresponding parameter is introduced by Gencot in the Cogent program for passing a pointer
to the global variable to the function. The parameter type is determined from the type of the global variable 
associated with the Global-State property according to its numerical argument.

If two virtual parameters of the same function have a Global-State property declared, the properties must use different 
numerical arguments. Two parameters with the same argument would correspond to two parameters for pointers to the 
same global variable. This would introduce sharing for parameters of linear type and is forbidden in Cogent.

The Global-State property implicitly includes the Add-Result property. A parameter introduced 
by a Global-State property always has a linear type in Cogent. Since the global variable cannot be deallocated the parameter
must never be discarded and always be returned as part of the function result. Thus Gencot automatically treats the 
virtual parameter in the same way as a parameter with the Add-Result property.

The Global-State property for virtual parameters can be combined with the Read-Only property. In this case the 
parameter type is made readonly and the implicit effect of the Add-Result property is omitted.

If a global variable has the Read-Only property it can still have a Global-State property for introducing virtual
function parameters for it. Semantically, all these function parameters must have readonly type. This is not 
guaranteed by Gencot, the parameter types are only made readonly if a Read-Only property is declared for them.

\item[Modification-Function]

The Modification-Function property is only supported for parameter items of pointer type. If declared, the parameters and
result of the translated function are rearranged to the form of a modification function (see 
Section~\ref{design-types-function}) where the modified parameter is the first one for which the Modification-Function 
property has been declared. Note that, although the property is declared for a parameter, the function is affected
by it as a whole.

The parameter type of the function is constructed as a pair consisting of the modified parameter and a tuple of all 
other parameters in the same order as in C. If the modified parameter also has the Add-Result property the result type 
of the function is constructed as a pair consisting of the modified parameter and a tuple of the original function result
and all other parameters with the Add-Result property. If the modified parameter does not have the Add-Result property
it is assumed that the original result returns the modified parameter value and the function result type is constructed 
as the pair consisting of the original result and the tuple of all parameters with the Add-Result property (which may 
be the unit type if there are no such parameters).

The Read-Only property is ignored, if it is combined with the Modification-Function property.

\end{description}

\subsection{Numerical Types}
\label{design-types-prim}

The Cogent primitive types are mapped to C types in \code{cogent/lib/cogent-defns.h} which is included by the Cogent compiler
in every generated C file with \code{\#include <cogent-defns.h>}. The mappings are: 
\begin{verbatim}
  U8 -> unsigned char
  U16 -> unsigned short 
  U32 -> unsigned int
  U64 -> unsigned long long
  Bool -> struct bool_t { unsigned char boolean }
  String -> char*
\end{verbatim}
The inverse mapping can directly be used for the unsigned C types. For the corresponding signed C types to be binary
compatible, the same mapping is used. Differences only occur when negative values are actually used, this must be handled by using specific functions for numerical operations in Cogent.

In C all primitive types are numeric and are mapped by Gencot to a primitive type in Cogent. Note that in C the representation 
of numeric types may depend on the C version and target system architecture. However, the main goal of Gencot is only to generate
Cogent types which are, after translation to C, binary compatible with the original C types. Hence it is sufficient for the numerical 
types to simply invert the Mapping used by the Cogent compiler.

Together we have the following mappings:
\begin{verbatim}
char, unsigned/signed char -> U8
short, unsigned/signed short -> U16
int, unsigned/signed int -> U32
long int, unsigned/signed long int -> U64
long long int, unsigned/signed long long int -> U64
\end{verbatim}

The only mapping not determined by the Cogent compiler mapping is that for \code{long int}. For the gcc C version 
it depends on the architecture and is either the same as \code{int} (on 32 bit systems) or \code{long long int}
(on 64 bit systems). Gencot assumes a 64 bit system and maps it like \code{long long int}.

\subsection{Enumeration Types}
\label{design-types-enum}

A C enumeration type of the form \code{enum e} is a subset of type \code{int} and declares enumeration 
constants which have type \code{int}. According to the C99 standard, an enumeration type may be implemented
by type \code{char} or any integer type large enough to hold all its enumeration constants.

A natural mapping for C enumeration types would be Cogent variant types. However, the C implementation
of a Cogent variant type is never binary compatible with an integer type (see below). 

Therefore C enumeration types must be mapped to a primitive integer type in Cogent. Depending on the C
implementation, this may always be type \code{U32} or it may depend on the value of the last enumeration
constant and be either \code{U8}, \code{U16}, \code{U32}, or maybe even \code{U64}. Under Linux, both cc
and gcc always use type \code{int}, independent of the value of the last enumeration constant. 
Therefore Gencot always maps enumeration types to Cogent type \code{U32}.

If an enumeration type has a tag, Gencot preserves the tag information for the programmer and uses
a type name of the form \code{Enum\_tag}, as described in Section~\ref{design-names}. For tagless enums
no type names are introduced, they are directly mapped to type \code{U32}.

The rules for mapping enumeration types are
\begin{verbatim}
  enum { ... } -> U32
  enum e { ... } -> Enum_e
  enum e -> Enum_e
\end{verbatim}

The enumeration constants must be mapped to Cogent constant definitions of the corresponding type. In 
C the value for an enumeration constant may be explicitly specified, this can easily be mapped to
the Cogent constant definitions.

An enumeration declaration of the form \code{enum e \{C1, C2, C3=5, C4\}} is translated as
\begin{verbatim}
  cogent_C1: U32
  cogent_C1 = 0
  cogent_C2: U32
  cogent_C2 = 1
  cogent_C3: U32
  cogent_C3 = 5
  cogent_C4: U32
  cogent_C4 = 6
\end{verbatim}
Note that the C constant names are mapped to Cogent names as described in Section~\ref{design-names}.

\subsection{Structure and Union Types}
\label{design-types-struct}

A C structure type of the form \code{struct \{ ... \}} is equivalent to a Cogent unboxed record type \code{\#\{ ... \}}.
The Cogent compiler translates the unboxed record type to the C struct. In a former version it reordered the fields 
lexicographically, but in the current version the fields are mapped in the same order as specified in Cogent.
Thus, if every C field type is mapped to a binary compatible Cogent field type both types are binary compatible as a whole.

\subsubsection{Mapping Struct and Union Types}
A C structure may contain bit-fields where the number of bits used for storing the field is explicitly specified.
Gencot maps every consecutive sequence of bit-fields to a single Cogent field with a primitive Cogent type.
The Cogent type is determined by the sum of the bits of the bit-fields in the sequence. It is the smallest 
type chosen from \code{U8, U16, U32, U64} which is large enough to hold this number of bits. 
***--> test whether this is correct.
The name of the
Cogent field is \code{cogent\_bitfield}<n> where <n> is the number of the bit-field sequence in the C structure.
Gencot does not generate Cogent code for accessing the single bit-fields. If needed this must be done manually in Cogent.
However, Gencot adds comments after the Cogent bitfield showing the original C bit-field declarations.

A C union type of the form \code{union \{ ... \}} is not binary compatible to any type generated by the Cogent compiler.
The semantic equivalent would be a Cogent variant type. However, the Cogent compiler translates every variant type
to a \code{struct} with a field for an \code{enum} covering the variants, and one field for every variant. Even if a variant
is empty (has no additional fields), in the C \code{struct} it is present with type \code{unit\_t} which
has the size of an \code{int}. Therefore Gencot maps every union type to an unboxed abstract Cogent type.

Another semantic equivalent would be a Cogent record type, where always all fields but one are taken. However,
this type is not binary compatible either, it is translated to a normal struct where every member has another
offset. Even if the translated type in C is manually changed to a union, the Cogent take and put operations cannot
be used since they respect the field offsets. 

Together we have the mapping rules:
\begin{verbatim}
  struct s -> #Struct_s
  union s -> #Union_s
\end{verbatim}
where \code{Struct\_s} is the Cogent name of a record type corresponding to \code{struct s} and \code{Union\_s} is the
name of the abstract type introduced for \code{union s}.

As explained in Section~\ref{design-names}, Gencot always introduces a Cogent type name for each struct and union,
even if no tag is present in C. Since the tag name is either defined to name a Cogent record or an abstract type,
it is always linear and names a boxed type which corresponds to a pointer. Hence, the type name generated for a struct
is always used to refer to the type ``pointer to struct'', the struct type itself is translated to the type name 
with the unbox operator applied. The same holds for union types.

\subsection{Array Types}
\label{design-types-array}

A C array type \code{t[n]} has the semantics of a consecutive sequence of n instances of type \code{t}. A value
of type \code{t[n]} is a pointer to the first element and therefore compatible to type \code{t*}.

%Basically, Cogent does not support accessing elements by an index value in an array, if 
%the index value is computed at runtime. This is an important security feature since the index value cannot be statically 
%compared to the array length by the compiler. Therefore, a C array type can only be mapped to an abstract type 
%in Cogent, which prevents accessing its elements in Cogent code. Element access must be implemented externally 
%with the help of abstract functions.

As of June 2020 there is an experimental Cogent builtin array type written \code{T[n]}. It is binary compatible 
with the C array type \code{t[n]} and is thus a good candidate for mapping C array types. However, it
is still under development. Its compilation to C is not yet stable and the refinement proof has
not yet been covered. Anyways, we expect it to become stable and use it for
mapping C array types.

The Cogent standard library includes three abstract data types for arrays (\code{Wordarray, Array, UArray}). 
However, they cannot be used as a binary compatible replacement for C arrays, because they are implemented by 
pointers to a \code{struct} containing the array length together with the pointer to the array elements. 
Only if the C array pointer is contained in such a struct, it is possible to use the abstract data types. 
In existing C code the array length is often present somewhere at runtime, but not necessarily in a single \code{struct}
directly before the array pointer.

In C the incomplete type \code{t[]} can be used in certain places. It may be completed statically, e.g. 
when initialized. Then the number of elements is statically known and the type can be mapped like \code{t[n]}.
If the number of elements is not statically known the type cannot be mapped to a Cogent array, it must be mapped 
to an abstract type.

The Cogent builtin array type has the form \code{El[n]} for the boxed (linear) case and \code{El\#[n]} for the unboxed
case. The unboxed case can alternatively be written as \code{\#(El[n])}, i.e., by applying the unbox type
operator to the linear case. The array size \code{n} must be a constant expression of type \code{U32} which can be
evaluated at compile time. As usual for \code{U32} modulo arithmetics is used so the result is never negative.
The array size must not be \code{0}.

Let \code{el} be the translation of the element type \code{El} to C. Cogent directly translates every occurrence
of type \code{El[n]} to the C type \code{el*} and it translates every occurrence of type \code{El\#[n]} to the 
C struct type \code{struct \{el data[n];\}} with the array as single member. This way values of the type can be 
assigned and passed as parameter by copying the whole array.

%The builtin arrays are mainly treated similar to records where all fields have the same type. Elements can be 
%``taken'', resulting in a different type where the taken elements are specified by their index values. The 
%corresponding type operator is \code{@take(i1,...,in)}. Unboxed arrays can be constructed using an expression 
%of the form \code{[e1,...,en]} and they can be matched to patterns of the same form. For boxed arrays there 
%are put expressions and take patterns where elements can be specified by their index. 

%The major drawback is that it seems that all element indices must be specified as constant expressions which 
%can be evaluated at compile time so that their validity can be checked. This excludes many array use cases occurring
%in C programs. However, this can be alleviated by providing additional abstract functions which implement a 
%(guarded) access to array elements for arbitrary index values.

\subsubsection{Mapping Array Types}

A C array type \code{t[n]} has two slightly different meanings. When it is used for allocating space in memory,
it is used to determine the required space as \code{n * sizeof(t)}. When it is used as declared type for an 
identifier, it means that the identifier names a (constant) value of type \code{t*}, since in expressions C arrays are 
always represented by a pointer to the first element. The builtin array types support both cases in Cogent:
The unboxed form can be used for allocating space in memory, the boxed form can be used when an array is
referenced by a pointer. Thus, C array types could normally be mapped to boxed array types, if they occur in 
the unboxed form the unbox operator can be applied.

As described in Section~\ref{design-operations-create} Gencot provides for every mapped linear type a separate type
for ``empty'' values. For a record type \code{R} the type \code{R take (..)} is used. For an array type
the empty-value type must be constructed in a different way, instead of the operator \code{take (..)} 
an operator of the form \code{@take (0,1,2,n-1)} must be used (an operator of the form \code{@take (..)} seems
to be intended but not yet implemented). Therefore it is not possible to define a common \code{EVT} macro for
array and non-array types.

Moreover, in the case of boxed array types \code{El[n]} the information about the array size \code{n} is not 
preserved by the translation to C. As described in Section~\ref{impl-operations} the Genops mechanism for arrays 
depends on the possibility to determine the array size from the C type. 

For both reasons Gencot wrap builtin array types in Cogent records. The resulting form is
\begin{verbatim}
  type CArr<size> el = {arr<size>: el#[<size>]}
\end{verbatim}
This approach has the following consequences:
\begin{itemize}
\item Only one Cogent type name is required for every array size.
\item Type \code{\#(CArr<size> el)} is considered to be linear if the element type \code{el} is linear,
because in this case the Cogent type checker recognizes the builtin array type \code{el\#[<size>]} as linear.
\item Since the unboxed array is translated by Cogent to a struct type with a singe array member, together this
approach results in a double wrapping of the array.
\item The unboxed array can be accessed through take and put operations. Cogent translates take and put operations for unboxed arrays
in a record as loops for assigning the single elements instead of the array as a whole (which would be possible, since it is
wrapped in a struct). Note, that an assignment of the wrapped array may be more efficient, but this should be a decision for the 
implementation of the builtin array types.
\item Since only unboxed builtin array types are used, the information about the array size is always preserved
by the translation to C and can be used by Genops.
\end{itemize}

The \code{<size>} specification is made a part of the component name \code{name<size>} to force the records on the 
right hand side to be different. This is not necessary, however, as of December 2020, Cogent otherwise considers the record types
to be equivalent for all sizes. When it generates the shallow embedding it selects one of them and uses the corresponding 
identifier \code{CArr<size>} for all array sizes. Since the size is ignored in the shallow embedding this is correct, but it
is more readable if distinct identifiers are used.

Multidimensional C array types could now be translated using a multidimensional Cogent array type, such as 
\code{el\#[<s1>]\#[<s2>]} (note that all dimensions must be unboxed). Cogent translates such types back
to an array of wrapped arrays, which is binary compatible to the multidimensional C array type. However, 
this form does not correspond to the form \code{CArr<s1> \#(CArr<s2> el)}
where both dimensions are wrapped twice. For consistency reasons the latter form is used by Gencot.

If the \code{<size>} is specified by a preprocessor identifier the identifier is resolved by Cogent when it translates the builtin
array type and the actual size value is specified in the C array type where it can directly be retrieved by Genops.

\subsubsection{Specifying Array Types}

For constructing an array type from a given size and element type Gencot provides the preprocessor macro
\begin{verbatim}
  CARR(<size>,<ek>,el)
\end{verbatim}
defined in \code{include/gencot/CArray.cogent}. The parameter \code{<ek>} can be used to specify an unbox
operator for the element type, it may be \code{U} or empty. The form \code{CARR(<size>,U,el)} is equivalent
to \code{CARR(<size>,,\#el)}. The main reason for this parameter is compatibility to the macro \code{CPTR}
defined in Section~\ref{design-types-pointer}, so that it is possible to construct an array type and the 
pointer-to-element type from the same input. Both macros are mainly intended to be used for defining other
macros.

The unboxed type \code{\#(Carr<size> El)} is binary compatible with the C array type.
It is a usual Cogent unboxed record and can be used freely. 
If another Cogent record has a field of an unboxed array type, the take and put operations can be applied
in the usual way, assigning the array content as a whole.

If the element type \code{El} is again an array type, the meaning in C is a multidimensional array.
This case is mapped to Cogent in the straightforward way, using an unboxed inner array type as element type
for the outer array type. For example, the C type \code{int[2][7]} is mapped to the Cogent type
\begin{verbatim}
  CArr2 #(CArr7 U32)
\end{verbatim}
which in C is a doubly wrapped array of doubly wrapped elements which should nevertheless be binary compatible 
to \code{int[2][7]}. Using the macro \code{CARR} it can be specified as \code{CARR(2,U,CARR(7,,U32))}.

As described in Section~\ref{design-names} the form \code{CArrX<size>X}
is used if the size is specified by an identifier and the single predefined generic abstract type \code{CArrXX} is used for all other
size specifications and for array types without size specification. In the latter case C type definitions for instances must be provided 
manually. The type \code{CArrXX} is defined in \code{include/gencot/CArray.cogent}.

To specify the \code{<size>} of an array type by an identifier, the identifier must be a preprocessor constant
defined in the Cogent source code. The expansion of the identifier must be a valid C expression. In simple cases,
where the expansion is a single integer literal or an expression built from literals and the operators \code{+ - * /}
the expansion is both valid C and Cogent code, then the identifier can also be used at other places in the Cogent
source code. An example usage is
\begin{verbatim}
  #ifdef LARGE
  #define SECT 20
  #else 
  #define SECT 5
  #endif
  #define SIZE 3*SECT
  type CArrXSIZEX el = {arrXSIZEX: el#[SIZE]; }
\end{verbatim}
It defines the generic type \code{CArrXSIZEX} to have either 60 or 15 elements, depending on the preprocessor flag \code{LARGE}.
For additional information on possibilities how to specify the identifier see Section~\ref{impl-ocomps-cogent}.

Whether a C array type is mapped to the boxed or unboxed form depends on its usage context.
A C array type cannot be used as result type of a function. Thus, the remaining possible uses of a C array type are
\begin{itemize}
\item as type of a global variable. This is translated to function parameters for passing a pointer to the variable 
and to an antiquoted C definition of the variable itself. The function parameters use the boxed type 
\code{CArr<size> El}. The definition uses the unboxed type \code{\#(CArr<size> El)}.
\item as type of a function parameter. In C this is ``adjusted'' to the pointer-to-element type. Since this
is binary compatible with type \code{CArr<size> El}, this type is used as parameter type in Cogent. Alternatively 
the adjusted type could be mapped, resulting in type \code{CPtr El} or \code{El} (in case of elements of unboxed 
record or array type). The type \code{CArr<size> El} is preferred here by Gencot since it preserves more information.
Although technically \code{NULL} may be passed as parameter value, the type is not wrapped by \code{MayNull} 
(see~\ref{design-types-pointer}), thus always requiring a non-null pointer as argument.
\item as type of a member in a struct type. Here the size of the array is relevant, therefore the unboxed type
\code{\#(CArr<size> El)} is used as type for the corresponding Cogent record field.
\item as element type of another array, resulting in a multidimensional array. Again the size of the array 
is relevant here, the unboxed type \code{\#(CArr<size> El)} is used as element type.
\item as base type of a derived pointer type. Here the binary compatible type is the boxed type \code{CArr<size> El}
since it corresponds to a pointer to the array. Since the derived pointer type includes the \code{NULL} value
it is wrapped by \code{MayNull} (see~\ref{design-types-pointer}).
\item as defining type for a typedef name. Here the type to be used depends on the context where the typedef
name is used. As described in Section~\ref{design-types-typedef}, Gencot defines the mapped 
typedef name always as an alias for the boxed type \code{CArr<size> El}. Then applying the unbox operator to the typedef name 
is equivalent to applying it to \code{CArr<size> El}.
\end{itemize}

Together we have the following mapping rules for C arrays with element type \code{el} and size 
specification \code{<size>}. Depending on the context of the C array type, additionally the unbox operator must be applied.
\begin{verbatim}
  el[<literal size>] -> CArr<literal size> El
  el[<size id>] -> CArrX<size id>X El
  el[<complex size>] -> CArrXX El
  el[] -> CArrXX El
  el[*] -> CArrXX El
\end{verbatim}
where El is the result of mapping the element type \code{el} to a Cogent type. If the size specification
is too complex (not a literal or single identifier) it is omitted and the type must be handled manually.

In Cogent linear types (pointers) are not supported if they point to data on the stack. Otherwise the Isabelle 
C parser will not accept the C code generated by Cogent. Therefore, whenever the boxed form is used for an array
(i.e., whenever it is passed as parameter to a function or defined as a global variable) it must not be allocated
on the stack. If it is stack allocated in the C program this must be adapted manually by allocating and deallocating
it on the heap in the Cogent program or by any other solution.

\subsubsection{Mapping Arrays to Abstract Types}

Before the builtin array types have been considered for Gencot, C array types were mapped to abstract Cogent types.
The corresponding concept is documented here to allow for comparing it to the use of builtin array types.

As a C derived type, every array type depends on its base type, which is the element type. The element type must be defined in
the C source before the array type can be used. The Cogent compiler can only respect this ordering requirement if
it knows that the abstract type to which the array type is mapped depends on the type to which the element type
is mapped. The only way to make this known to the Cogent compiler is to use a generic type for the array with
a single type parameter for the element type. 

When a C array type is used for a field in a record, after translation from Cogent to C a type
must be used which includes the array size. To be able to specify a corresponding C typedef for the 
Cogent abstract type name, array types with different size specifications must be mapped to different 
Cogent abstract type names. This is the reason why the size specification is encoded into the type name,
as described in Section~\ref{design-names}. So a different type name is required for every array size 
occurring in the C program.

An abstract type is always boxed. The unboxed form can be constructed by applying the unbox operator. However, if
the array type is mapped to an abstract type which corresponds to C type \code{t*} then the unboxed form
corresponds to C type \code{t} and not to the array type, as required.

If the unboxed case is implemented as a struct with the array as its only member, the
boxed case can be implemented by a pointer to this struct which corresponds in Cogent to the same type
with the unbox operator omitted. The pointer to the struct is binary compatible with the pointer to its
only member which is binary compatible with the pointer to the first array element. 
This solution depends on the property, that a C struct with a single array as member has the same memory
layout as the array itself. If the C implementation adds padding after the array (it
cannot add it before the array according to the C specification), another solution must be used.

Together, this way the C array type can be mapped for literal size specifications using a single generic abstract Cogent type
\begin{verbatim}
  type UArr<size> el
\end{verbatim}
whith an antiquoted C type definition 
\begin{verbatim}
typedef struct $id:(UArr<size> el) {
  $ty:el arr[<size>];
} $id:(UArr<size> el);
\end{verbatim}

A drawback of this approach is that the type \code{\#(UArr<size> el)} is not considered to be linear if the element 
type \code{el} is linear. For an abstract parameterized type Cogent considers the unboxed type always as unboxed,
independent of the actual type parameters. Thus an unboxed array of linear values could be shared or discarded 
without being detected by the Cogent type checker.

For the empty-value type we again seek a solution which is the same as for record types. However, the 
\code{take} operator can normally not be applied to an abstract type. There are three possible approaches if
array types are mapped to abstract types.

The first approach uses the Cogent compiler flag \code{--flax-take-put} which allows the \code{take} operator to
be applied to abstract types (including abstract generic types). However, as of October 2019 the Cogent type checker 
is instable for such types and cannot process all applications. Therefore this approach is not used by Gencot.

The second approach uses a wrapper struct in the same way as for the builtin array solution:
\begin{verbatim}
  type CArr<size> el = {arr<size>: #(UArr<size> el)}
  type UArr<size> el
\end{verbatim}
This makes it possible to use the Cogent take type operator for modelling empty-value array types.
The drawback is that two different Cogent type names are required and that arrays are wrapped twice as struct.
Also, the type \code{\#(CArr<size> el)} is still considered nonlinear for a linear element type, as above.

The double wrapping could be avoided if type \code{UArr<size>} is directly implemented by the array type
in C as in
\begin{verbatim}
  typedef $ty:el $id:(UArr<size> el)[<size>];
\end{verbatim}
However, there are two problems with this approach. First, the Cogent compiler does not support antiquoted
type definitions for generating this form (the type parameter \code{\$ty:el} is only known in a struct type
with the generic type as tag name). Second, Cogent translates take and put operations for a record field 
to an assignment in C. Therefore, if field \code{arr} in a value of type \code{CArr<size> El} is put or taken, 
the C code generated by Cogent will be wrong, since arrays cannot be assigned in C. 

The third approach uses a second generic abstract type 
\begin{verbatim}
  type UEArr<size> el
\end{verbatim}
for every \code{<size>} to represent the empty-value array type. It is defined in C in the same way as type \code{UArr<size>}.
This also avoids the double wrapping. It does not use the \code{take} operator to construct the empty-value type
for array types, so there is no relation between both which is known to Cogent. However, the only situation where this
relation would be useful is for type variables, but the \code{take} operator cannot be applied to type variables since
it is not possible in Cogent to restrict a type variable to record types. 

The drawback of the third approach is that the empty-value 
type is constructed in different ways for mapped arrays and for mapped structs. This makes it impossible to define 
a single common macro \code{EVT} for this type construction in Section~\ref{design-operations-create}. This further 
implies that no single macro is possible if it uses \code{EVT}, and, in particular, since the type for pointers to
an unboxed array is the boxed array type (see Section~\ref{design-types-pointer}) this case must be distinguished 
in Macros which apply \code{EVT} to a constructed pointer type.

Therefore the decision in early versions of Gencot was to use the second approach. For every array \code{<size>} used in the C 
program the two generic Cogent types \code{CArr<size>} and \code{UArr<size>} were used where the latter is
abstract and is defined in antiquoted C as described above.

If the \code{<size>} is specified by a preprocessor identifier there is another subtle difference to the approach 
with builtin array types: the size information is only encoded in the abstract type name, 
there the identifier is used. To access the actual size value Genops needs the preprocessor definition of that
identifier. When using builtin array types the actual size value is specified in the C array type where it can 
directly be retrieved by Genops.

\subsection{Function Types}
\label{design-types-function}

C function types of the form \code{t (...)} are used in C only for declaring or defining functions or
when a typedef name is defined for a function type. In all other
places they are either not allowed or automatically adjusted to the corresponding function pointer type
of the form \code{t (*)(...)}. 

\subsubsection{Mapping Function Parameters}

In Cogent every function
has only one parameter. To be mapped to Cogent, the parameters of a C function with more than one parameter must
be aggregated in a tuple or in a record. A C function type \code{t (void)} which has no parameters is mapped
to the Cogent function type \code{() -> T} with a parameter of unit type.

The difference between using a tuple or record for the function parameters is that the fields in a 
record are named, in a tuple they are not. In 
a C function definition the parameters may be omitted, otherwise they are specified with names in a prototype.
In C function types the names of some or all parameters may be omitted, specifying only the parameter type.

It would be tempting to map C function types to Cogent functions with a record as parameter, whenever parameter 
names are available in C, and use a tuple as parameter otherwise. However, in C it is possible to assign a 
pointer to a function which has been defined 
with parameter names to a variable where the type does not provide parameter names such as in 
\begin{verbatim}
  int add (int x, int y) {...}
  int (*fun)(int,int);
  fun = &add;
\end{verbatim}
This case would result in Cogent code with incompatible function types.

For this reason we always use a tuple as parameter type in Cogent. Cogent tuple types are equivalent, if they
have the same number of fields in the same order and the fields have equivalent types. To preserve the C parameter names in 
a function definition, the parameter is matched with a tuple pattern containing variables of these
names as fields.

C function types where a variable number of
parameters is specified such as in \code{t (...)} (``variadic function type'') must 
be treated manually in specific ways. Gencot maps variadic function types
with an additional last parameter type \code{VariadicCogentParameters}. This pseudo type is intended 
to inform the developer that manual action is required. The bang operator is applied as a hint
that no modifications are returned. For a function pointer, the corresponding Cogent type has
the form \code{\#(CFun ((...,VariadicCogentParameters!) -> <result type>))}.

C function types where the parameters are omitted, such as in \code{t ()} (``incomplete function type'') 
cannot be mapped to a Cogent function type in this way. 
They can only be mapped using an abstract type as parameter type. This can again lead to incompatible 
Cogent types if a function pointer is assigned where parameters have been specified, these cases must 
be treated manually in specific ways. Note that incomplete function types cannot be used for function
definitions, only for function pointers and for declarations of external functions. 
Gencot does not translate declarations of functions with incomplete types, these must be added manually.
This behavior of Gencot is also exploited to handle manually translated macros, as described in 
Section~\ref{impl-ccomps-externs}.

Together the rules for mapping function types are
\begin{verbatim}
  t(t1, ..., tn) -> (T1, ..., Tn) -> T
  t(void) -> () -> T
  t(t1,...,tn,...) -> (T1, ..., Tn, Variadic_Cogent_Parameters!) -> T
\end{verbatim}

\subsubsection{Item Properties Affecting Function Type Mapping}

Like every other type, the type of a function parameter may be readonly because the Read-Only property
has been declared for the parameter, as described in Section~\ref{design-types-itemprops}.

\paragraph{Add-Result}

For a parameter with linear type, the function can only be defined in Cogent if the parameter is not discarded,
i.e. it must be part of the result. This can be achieved by specifying the Add-Result property for the 
parameter (see Section~\ref{design-types-itemprops}). Gencot assumes the most simple handling of this case, where the result
is a tuple consisting of the original result of the C function together with a component for every parameter
with the Add-Result property. 

A parameter of linear type may not be discarded in Cogent, but it may be passed to an abstract function which discards
it. In this case the parameter must not be returned, although it has linear type. This can be specified by the 
developer by omitting the Add-Result property for the parameter.

Gencot uses the parameter types and declared properties to make parameter types readonly or
add parameters to the function result, according to the following rules:
\begin{itemize}
\item If a parameter neither has the Read-Only property, nor the Add-Result property, it is translated as described before.
\item Otherwise, if the parameter has the Read-Only property
its translated type is made readonly by applying the
bang operator \code{!}. For a single such parameter of type \code{r} the translation rule becomes
\begin{verbatim}
  t(t1, ... r, ... tn) -> (T1, ... R!, ... Tn) -> T
\end{verbatim}
\item Otherwise, if the parameter has the Add-Result property, the function result is changed to a tuple and the 
parameter is added as component to that tuple.
For a single parameter of type \code{l} with the Add-Result property the translation rule becomes
\begin{verbatim}
  t(t1, ... l, ... tn) -> (T1, ... L, ... Tn) -> (T,L)
\end{verbatim}
\end{itemize}

If the result is modified to a tuple, the first component is the original function result and the remaining components
are the parameters of linear type in their order as they occur in the parameter tuple.

\paragraph{Modification-Function}

If the Modification-Function property has been declared for a parameter (see Section~\ref{design-types-itemprops}), 
the function type is translated according to the rule
\begin{verbatim}
  t(t1, ... l1, ... tn) -> (L1,(T1, ... ... Tn)) -> (L1,(L2,...,Lm))
\end{verbatim}
where \code{l1} is the type of the first parameter for which the Modification-Function parameter has been declared, \code{L1}
is its translation, and \code{L2,...,Lm} are the mapped types of all parameters with the Add-Result
property. If the parameter with the Modification-Function property also has the Add-Result property the result type 
of the Cogent function becomes \code{(L1,(T,L2,...,Lm))} where \code{T} is the translation of the original result type \code{t}.

The parameter type of
the translated function is a pair where the second component is the tuple of all other parameter types with \code{L1}
omitted and the result type is a pair where the second component is the tuple of all 
parameters with the Add-Result property and possibly the original result. If there are no parameters \code{L2,...,Lm} the result type 
has the form \code{(L1,())} or \code{(L1,T)}. If there
are only two parameters the parameter tuple has the form \code{(L1,T1)}. If \code{l1} is the only parameter the parameter tuple
has the form \code{(L1,())}. 

\paragraph{Heap-Use}

If the Heap-Use property has been declared for a function, its type is translated according to the rule
\begin{verbatim}
  t(t1, ..., tn) -> (T1, ..., Tn,Heap) -> (T,Heap)
\end{verbatim}
i.e., the heap is appended to the parameter and result tuple. If the C result type is void the result type is \code{Heap}.
If \code{n = 0} the parameter type is \code{Heap}. Parameters with the Add-Result property are inserted before the \code{Heap}
component.

If additionally the Modification-Function property has been declared for a parameter the heap is added as last components \code{Tn} and
and \code{Lm} in the additional tuple of the parameter and result pairs.

\paragraph{Global-State}

If the Global-State property has been declared for a (virtual) parameter of the function, the function type is translated 
according to the rule
\begin{verbatim}
  t(t1, ..., tn) -> (T1, ..., Tn,TG) -> (T,TG)
\end{verbatim}
where \code{TG} is the translated type of a pointer to the global variable associated with the Global-State property
(see Section~\ref{design-types-itemprops}). It is added to the result in the same way is if the Add-Result property 
had been declared for the parameter. If several virtual parameters are present with a declared Global-State property 
they are ordered according to the numerical argument of the Global-State properties. 

The function type which is extended this way may occur in a different C source file than the associated global variable.
The additional parameter may even be used to only pass the global value through to other functions, then the global variable 
is actually never accessed in the function body and neither its definition nor a declaration needs to be visible for
the function. This implies that Gencot may not be able to determine the type of the global variable when it translates 
the function type, and thus may not be able to determine type \code{TG}. 

For this reason Gencot introduces for every global variable with a Global-State property a type synonym for the Cogent 
type corresponding to a pointer to the variable. These type synonyms have the form
\begin{verbatim}
  GlobState<i>
\end{verbatim}
where \code{<i>} is the numerical argument of the Global-State property associated with the global variable. For 
the numerical argument \code{0} it is omitted. Using the numerical argument, Gencot can always determine this type synonym
from the Global-State property and use it as the type \code{TG}. 

Gencot generates the type synonym definition in place of a translation of the global variable definition at the corresponding
position in the Cogent file.

If the function has the 
Heap-Use property the additional parameter and result component are added before the \code{Heap} parameter.

If additionally the Modification-Function property has been declared for a parameter the Global-State parameters are added 
as last components (before the heap, if present) in the additional tuple of the parameter and result pairs.

\subsection{Pointer Types}
\label{design-types-pointer}

In general, a C pointer type \code{t*} is the kind of types targeted by Cogent linear types. The linear type 
allows the Cogent compiler to statically guarantee that pointer values will neither be duplicated nor 
discarded by Cogent code, it will always be passed through. 

If a pointer points to a C \code{struct} there is additional support for field access available in Cogent by 
mapping the pointer to a Cogent boxed record type. For all other pointer types this support can be employed by
mapping the type to a Cogent record with a single field of the type referenced by the pointer.

In C, a pointer-to-array type is not the type of pointers to the array address, instead its values are array addresses.
The difference from the array type is only that when applying the index operator \code{[]}, the whole array is
selected instead of only the first element. In Cogent the corresponding type is a Cogent record with a single
field of the unboxed mapped array type. Note, that this is equivalent to the mapping of the array type itself, as defined
in Section~\ref{design-types-array}, so it is used by Gencot.

As described for the mapping of array types to abstract types in Section~\ref{design-types-array}, Cogent must know 
that a pointer type depends on 
its base type, which is the type of the referenced value. Therefore pointer types are mapped to generic types which
have the base type as single type parameter. Since there is no additional information to be encoded for a pointer
type other than its base type, a single generic type is sufficient for all pointer types. As described in 
Section~\ref{design-names} the type name \code{CPtr} is used for this purpose.

\subsubsection{Mapping Pointer Types}

A pointer type \code{t*} to a struct is mapped to the corresponding boxed type, 
that means, it is mapped like the struct type \code{t}, but the unbox operator is omitted.

A pointer type \code{t*} where \code{t} is a union type is mapped in the same way to the corresponding
boxed type, omitting the unbox operator from the mapped type \code{t}. Thus no support for accessing
the referenced union is provided. The reason is, that access to the union as a whole is mostly useless
and further access to the union members cannot be provided. For consistency, Gencot treats union types
in the same way as struct types.

A pointer type \code{t*} where \code{t} is a primitive type, an enum type, 
or again a pointer type is mapped to a boxed record with a single field \code{cont} of the type \code{T} to which \code{t} is 
mapped. For every such type the generic type \code{CPtr T} name is used. This makes the 
Cogent program slightly more readable. 

The resulting generic type can be completely defined in Cogent as
\begin{verbatim}
  type CPtr ref = { cont: ref }
\end{verbatim}
it is predefined in file \code{include/gencot/CPointer.cogent}.

Values of such types are binary compatible to the C pointer type and they can be dereferenced with the help of
the Cogent take and put operations, thus supporting the full functionality of the C pointer.

A pointer type \code{t*} where \code{t} is an array type is mapped to the mapped (boxed) array type 
\begin{verbatim}
  CArr<size> El
\end{verbatim}
This approach is similar as for struct and union types: the pointer type is mapped to the plain boxed type,
the base type is mapped to the corresponding unboxed type. The difference in case of array pointers is, that also the base
type is often ``adjusted'' to the boxed type, because in C a pointer is used instead. Other than in C, however, Gencot
represents adjusted arrays by a pointer to the array as a whole, instead of as a pointer to the first element, because
this preserves more information about the array.

Finally, a pointer to \code{void} is mapped to the abstract type
\begin{verbatim}
  CVoidPtr
\end{verbatim}
defined in \code{include/gencot/CPointer.cogent}.
It is intended as a placeholder. Here the type of the referenced data is unknown. In C it is typically used 
as a generic pointer type which is cast to specific types of referenced values. This cannot be transferred to
Cogent, to be used, the type must be replaced manually. No C type definition is provided for it by Gencot.

To make the construction of a pointer type for a given Cogent type more generic (in particular for its use 
in other preprocessor macros), Gencot provides in \code{include/gencot/CPointer.cogent} the preprocessor macro
\begin{verbatim}
  CPTR(<knd>,<type>)
\end{verbatim}
where \code{<type>} is a Cogent type and \code{<knd>} is \code{U} or empty. \code{CPTR(U,T)} expands to \code{T} and
must be used if the type to be pointed to is an unboxed type of the form \code{\#Struct\_s}, \code{\#Union\_s}, or
\code{\#(Carr<size> El)}. \code{CPTR(,T)} expands to \code{(CPtr T)} and must be used in all other cases.

For example, the C type \code{struct s*} is mapped to \code{CPTR(U,Struct\_s)} and the C type \code{int*} is mapped
to \code{CPTR(,U32)}.

\subsubsection{\code{NULL} Pointers}

A Cogent linear type has the additional property that its values are never \code{NULL}. For a boxed record type this
guarantees that the record fields can always be accessed without caring whether the pointer may be \code{NULL}.
A C pointer type, instead, may include the \code{NULL} value, so it cannot be mapped directly to the Cogent linear type.

This could be handled by replacing the \code{NULL} pointer by a valid pointer to dummy data which is never used.
The main problem here is that it must be possible to determine at runtime whether a value is null or not. So simply
allocating a ``dummy'' to get a valid non-null pointer is not sufficient, it must also be possible to recognize the 
dummy pointer.

One possibility for this is if there is a value referenced by the pointer which never occurs in normal execution,
it can be used to mark the pointer as dummy. 

Another possibility is to use a single dummy pointer for all values of a specific linear type which can be null and store it 
in a seperate place for comparing it. However, this cannot be done in Cogent since the dummy pointer would be a shared linear 
value. Even if implemened in C through abstract functions, to prove memory safety every access to such a value must 
be guarded with a test for the dummy pointer. Thus it is easier to actually use the null pointer instead of the dummy pointer,
in combination with a guard testing for the null pointer

Moreover using a dummy pointer is not binary compatible if the pointer is also accessed in external existing C code where 
it is set to \code{NULL} or tested for being \code{NULL}.

Since in Cogent the values of boxed record types must not be \code{NULL}, C pointer types must be mapped to other types, if 
they are used in a context where \code{NULL} values are allowed. Gencot uses the generic type \code{MayNull a} for this purpose
where \code{a} is the Cogent linear type for the same values without \code{NULL}.

Semantically, \code{MayNull} is a marker type, its values are the same as for type \code{a} with the exception that 
\code{NULL} is also allowed as value. The C implementation of \code{MayNull a} must be equivalent to that for \code{a}.

The simplest way would be to define \code{MayNull} as abstract, then its values can never be used to access the referenced
data, they can only be processed in specific abstract functions. However, this does not fit with the special Cogent type system.
If \code{T} is a linear type which is not escapeable (because it contains components of readonly type), the type \code{MayNull T}
is also linear, but escapeable, if \code{MayNull} is an abstract generic type. This could be used to store a value of readonly
type in a value of type \code{T} in a banged context, coerce the value of type \code{T} to type \code{MayNull T}, return it from
the banged context and then access the readonly value in it, thus bypassing the Cogent type checker guarantees. If \code{MayNull T}
instead is always defined as readonly it is not escapeable, but no more linear and could be shared and discarded, which also
violates Cogent type checker guarantees. 

Instead, Gencot uses the definition (in \code{include/gencot/MayNull.cogent})
\begin{verbatim}
  type MayNull a = { no_access: #a }
\end{verbatim}
Every instance \code{MayNull T} is linear and it is escapeable iff \code{a} is escapeable. Moreover, values of type \code{MayNull T}
can be consistently casted to type \code{T} in C implementations of abstract functions for processing these values. This is 
important because otherwise the C code generated by Cogent would not be accepted by the Isabelle C parser. The only
drawback of this approach is that the field \code{no\_access} could be accessed in Cogent which could cause a null pointer
derefence. However, this can be syntactically checked for a Cogent program so that it is easy to prove that no such null
pointer dereferences can occur for it.

A bug in the current version of Cogent prevents the correct processing of a type \code{\{no\_access: \#a\}!} for some linear types 
\code{a}. Therefore the type \code{MayNull} is temporarily defined as abstract.

In Cogent for a linear type \code{T} the type \code{\#(T!)} is equivalent to \code{\#T}. Therefore, \code{MayNull (T!)} is 
equivalent to \code{\{ no\_access: \#T \}} which is equivalent to \code{MayNull T}. Therefore, if a type \code{T} is readonly,
type \code{(MayNull T)!} must be used instead of \code{MayNull T}.

Whether a value may be \code{NULL} in C is not determined by its type, it depends on the way the value is used. It may be known
to the C developer that for a parameter of pointer type a function is never (intended to be) invoked with \code{NULL} as actual
parameter, but Gencot cannot determine that from the C program. Therefore Gencot maps pointer types to Cogent heuristically 
applying \code{MayNull} or not. Basically, pointer types are always mapped with \code{MayNull} applied, if they are not 
function pointers (for function pointers see the next section). Additionally, the item property Not-Null (see 
Section~\ref{design-types-itemprops}) is inspected, if it is declared for an item \code{MayNull} is omitted in the item's type. 

A C pointer type may also result from ``adjusting'' an array type used as type for a function parameter. In this case Gencot
assumes that the actual parameter is never \code{NULL} and omits \code{MayNull} in the mapped type of the parameter.
As described in Section~\ref{design-types-array} Gencot also translates an array type for a global variable to a linear
type of the form \code{CArr<size> El} and assumes that the array is allocated on the heap so that it is valid during all 
the global lifetime. Therefore Gencot also omits \code{MayNull} in this case. Together, whenever Gencot maps an array type
to the linear form \code{CArr<size> El} it omits \code{MayNull}. If, however, Gencot maps a pointer to an array to the 
same form, it applies \code{MayNull} if not prevented by the Not-Null item property.

So together we have the basic mapping rules for pointer types:
\begin{verbatim}
  void * -> MayNull CVoidPtr
  struct s * -> MayNull Struct_s = MayNull { ... }
  union s * -> MayNull Union_s
  (*el)[...] -> MayNull (CArr... El)
  otherwise: t * -> MayNull (CPtr T)
\end{verbatim}
where \code{Struct\_s} and \code{Union\_s} are the names introduced for the struct or union types and \code{El} 
and \code{T} are the Cogent types to which \code{el} and \code{t} are mapped, respectively. When property
Not-Null has been declared for the type's item the generic type \code{MayNull} is omitted.

\subsubsection{The \code{String} type}

Cogent supports the specific primitive type \code{String} which is translated by the Cogent compiler to \code{char*}.
It is the type of the Cogent string literals. In contrast to all other Cogent types which correspond to a C pointer
type it is neither linear nor readonly, it is a regular type for which no restrictions apply. This is motivated
by the property of C string literals that they cannot be modified and are neither allocated nor disposed.

String literals are not supported by the Isabelle C parser, therefore a Cogent program using string literals cannot
be processed and verified by Isabelle. However, string literals are useful during development time for debug 
output. Their use should be surrounded by conditional preprocessor directives so that they can be easily removed
from the program for verification and for the production version. 

Gencot supports using type \code{String} in Cogent by mapping string literals to values of this type.
Since it is not possible to distinguish C string literals by their C type, Gencot uses a heuristics and the item
properties No-String and Read-Only for this mapping.

Gencot basically maps the type \code{const char*} to type \code{String}. This type is often used in C as type
for values which may be string literals, since it reflects the property of string literals to be immutable.
The \code{String} type in Cogent has the additional property, that it is not possible to access the characters
which are elements of the string. Therefore the item property No-String (see Section~\ref{design-types-itemprops})
is used to modify the mapping. If it is declared for a C item of type \code{const char*} the item's type is
mapped as a normal pointer type, i.e. to the Cogent type \code{(CPtr U8)!}. The bang operator is applied because
the C type is intrinsically readonly according to Section~\ref{design-types-readonly}.

Gencot also maps the type \code{char*} to type \code{String} for all items for which the property Read-Only has
been declared. To prevent this, the property No-String can be added to the item.

\subsubsection{Mapping Function Pointers}

In Cogent the distinction between function types and function pointer types does not exist. 
A Cogent function type of the form \code{T1 -> T2} is used both when
defining functions and when binding functions to variables. If used in a function definition, it is mapped by
the Cogent compiler to the corresponding C function type, as described in Section~\ref{design-types-function}.

In other places, however, Cogent does not translate its function types to C function pointers. Instead, it uses 
a C enumeration type where every known function has an associated enumeration constant. Whenever a 
function is bound to a variable, passed as a parameter or is invoked through a function pointer, it is 
represented by this enumeration constant in C, i.e., by an integer value.
For function invocation Cogent generates dispatcher functions which receive the integer value as an argument
and invoke the corresponding C function. 

Binary compatibility is only relevant when a function is stored, then it is always represented by the enumeration
constant in C generated from Cogent. Thus, a C function pointer type cannot be mapped by Gencot to a Cogent function type,
since this will not be binary compatible. Instead, it must be mapped to a Cogent abstract type together with 
abstract functions which translate between the abstract type and the Cogent function type (needed when invoking 
the function in Cogent).

Together, Gencot treats C function types and C function pointer types in completely different ways. It maps
C function types to Cogent function types and it maps C function pointer types to Cogent abstract types.

These abstract types treat C function pointers in Cogent as fully opaque values. The only operation which can 
be applied to them is to translate them to the enumeration value used in Cogent. This is done by comparing the
actual pointer values for equality. Since this also works for the \code{NULL} pointer, no specific measures
are required for supporting \code{NULL} pointers for functions. In particular, the type \code{MayNull} is never
used for function pointers.

Since comparing pointer values can be done in C independent from the pointer's type, a single 
common C pointer type such as \code{void *} is sufficient. Accordingly, a single abstract type in Cogent is
sufficient to represent all C function pointers. In particular, no dependencies on the parameter or result types 
need to be known by Cogent to position their definitions before the first use of the type in C. 

However, for the developer the information about the parameter and result types are useful. Moreover, if different
Cogent types are used for different C function pointer types, the Cogent type checker can be used to find
mistakes. Since the full information about the parameter and result types is contained in the Cogent function types
the easiest way is to use a generic abstract type
\begin{verbatim}
  CFunPtr (P -> R)
\end{verbatim}
with a function type \code{P->R} as single type argument. It is used for complete function pointer types where the 
parameter types are specified or it is specified that the function has no parameters using the keyword \code{void}. 
This can be thought of as an ``annotated'' or ``wrapped'' function type, although the constraint that the argument
must be a function type cannot be specified or checked in Cogent.

For a complete C function pointer type its base type is mapped to a Cogent function type as described in
Section~\ref{design-types-function}. This includes the cases for variadic function types and the cases where
parameter types are converted to readonly types or cause additional components in the result type for returning 
modified parameters.

For incomplete C function pointer types, where only the result type
is specified but no parameter types, a second generic abstract type is used:
\begin{verbatim}
  CFunInc R
\end{verbatim}
where \code{R} is the result type. It may be an arbitrary 
mapped C type, only restricted by the C rules that it may not be a function or array type. Since however C array types
are always mapped by wrapping them in a record, the corresponding unboxed types of the form \code{\#(CArr<size> El)}
\textit{can} be used as function result types, although Gencot will never do so when translating a valid C program.

Both generic abstract types are defined in \code{include/gencot/CPointer.cogent}.

Although the C function pointer is a pointer, the pointer target value (the machine code implementing the function) 
normally cannot be modified through the pointer. Hence, semantically a function pointer type does not correspond to a linear type
in Cogent, it could be represented by a readonly type or by an unboxed type. Gencot uses an unboxed type
since values of readonly types cannot escape from banged contexts. Gencot automatically applies the 
unbox operator in the form \code{\#(CFunPtr (P->R))} whenever it uses one of the two generic function pointer types.

However, if a function pointer type of these forms occurs as type of a struct member, any direct or indirect reference of a
parameter or result type to the struct type will be detected by Cogent as a cyclic type dependency. Since 
these dependencies seem to be no problem for the validation, Gencot hides the parameter and result types from
Cogent by encoding the function type as an abstract type name (see next Section below). As a result, for 
every function type which is used as base type for a function pointer type there are now two forms: the Cogent
type expression of the form \code{P -> R} and the abstract type name. Semantically, both are equivalent, however,
this equivalence is deliberately hidden from the Cogent type checker. For incomplete function pointer types similar
abstract type names are required for arbitrary non-function types.

When generating the abstract type name the goal is to use the same name 
for every occurrence of a C function pointer type. Thus it is infeasible to generate the name from 
the occurrence position (file name and line number). If an arbitrarily generated name would be used, 
Gencot could not separately compile different C files. Therefore the name is generated by encoding the structure of the 
C function or result type. Gencot implements the encoding for all mapped C types. As described
below, the encoding also supports the type operators for unboxed and readonly types and for \code{MayNull} types.
Modified function parameters are not added to the result type, they are marked as parameter type instead.

Now both kinds of function pointer types are mapped to the forms
\begin{verbatim}
  CFunPtr Encfuntype
  CFunInc Encrestype
\end{verbatim}
with the abstract encodings as type arguments. Again, this constraint cannot be specified or checked in Cogent.

If a mapped function type and the corresponding mapped function pointer type are used in the same context it is useful to 
be able to syntactically generate both from a common specification with the help of a preprocessor macro. This can be
supported by using the abstract type name also to define a synonym for the function type using another parameterized
type of the form
\begin{verbatim}
  type CFun Encfuntype = P->R
\end{verbatim}
Note that this cannot be expressed in Cogent syntax or with the help of antiquoted C, since the type \code{P->R} must
correspond to the encoding used as type argument. The Gencot mechanism for defining instances of polymorphic types and
functions must be used here, as described in Section~\ref{impl-operations}.

Another possibility is to use monomorphic abstract types instead. They have the form
\begin{verbatim}
  CFunPtr_Encfuntype
  CFunInc_Encrestype
  type CFun_Encfuntype = P->R
\end{verbatim}
It has the advantage that the function type synonyms can be defined using the normal Cogent syntax.

Due to an error in the Cogent compiler which does not treat types of the form \code{\#(A B)} as unboxed, if \code{A}
and \code{B} are abstract, the current Gencot version uses this approach.

Together the rules for mapping a function pointer type are
\begin{verbatim}
  t (*)( ... ) -> #CFunPtr_encfuntype
  t (*)() -> #CFunInc_encrestype
\end{verbatim}
where \code{encfuntype} is the encoding of the function type \code{t( ... )} 
and \code{encrestype} is the encoding of the result type \code{t}.

As additional convenience, for every complete function pointer type a Cogent type name of the form \code{CFun\_encfuntype}
is introduced for the base function type. This makes it easy to generate both types from \code{encfuntype} in a preprocessor
macro.

For example, the C function pointer type \code{int (*)(int, int[10])} is mapped to the abstract type
\begin{verbatim}
  #CFunPtr_FXU32XA10_U32X_U32
\end{verbatim}
with generated type definitions
\begin{verbatim}
  type CFunPtr_FXU32XA10_U32X_U32
  type CFun_FXU32XA10_U32X_U32 =
    (U32,CArr10 U32) -> U32
\end{verbatim}

Note that the macro call \code{CPTR(,T)} expands to \code{(CPtr T)} also if \code{T} is a Cogent function type.
This corresponds to a pointer to the function enumeration value used by Cogent and is not related to the C
function pointer type. Therefore \code{CPTR} should not be used for function pointer types.

\subsubsection{Encoding C Function Types}

Gencot represents C function pointer types with the help of abstract Cogent types which encode C function types. These
function type names are constructed from encodings of all parameter types and the result type. Hence Gencot implements
a schema for encoding all C types as Cogent abstract type names.

A C type is either a primitive type, a derived type, a typedef name, or a struct/union/enum type. Gencot maps all
struct/union/enum types to a Cogent type name. Primitive types and typedef names are specified by a single identifier
in C and are also mapped to a Cogent type name by Gencot. These names are directly used as encoding. Thus only for the 
derived types (pointer, array, and function types) a nontrivial encoding must be defined.

Every derived type in C has a single base type from which it is derived. The base type of a derived
type is always either another derived type, or it is mapped by Gencot to a Cogent type name. Hence every derived 
type can be uniquely characterized by a sequence of derivation steps starting with a type name. The sequence of 
derivation steps is syntactically encoded in the generated name as follows.

A pointer derivation step is encoded by a single letter \code{"P"}. 

An array derivation step without size
specification is encoded by a single letter \code{"A"}. An array derivation step with a literal
as size specification is encoded in the form
\begin{verbatim}
  A<size>
\end{verbatim}
where \code{<size>} is the size specification. If the size is specified by a single identifier the 
step is encoded in the form
\begin{verbatim}
  AX<size>X
\end{verbatim}
where \code{X} is a letter not occurring in the identifier.
In all other cases an array derivation step is encoded by
\begin{verbatim}
  AXX
\end{verbatim}
which may lead to name conflicts in Cogent and must be handled manually. As described in 
Section~\ref{design-types-array}, a C array type may be mapped to an unboxed or boxed form, depending
on its usage context. The unboxed form is only relevant here, if the array type is the element type 
of another array. Then it is encoded by an additional pseudo derivation step encoded as \code{"U"}.

A function derivation step is encoded in the form
\begin{verbatim}
  FX<P1>X<P2>X...X<Pn>X
\end{verbatim}
where the \code{<Pi>} are the encodings of the parameter types and \code{X} is a letter not occurring in 
any of the parameter type encodings. A parameterless function type is encoded as \code{FXX}, whereas an
incomplete function type where no parameter types are specified is encoded as \code{F}.
If the function type is variadic, an additional pseudo parameter type \code{VariadicCogentParameters}
is added as last parameter type. 

In some cases Gencot maps a C pointer type to a boxed Cogent type and its base type to the corresponding
unboxed type by applying the unbox operator \code{\#} to the Cogent type. In these cases the pointer derivation
step is omitted in the encoding, and the base type is encoded by applying a pseudo derivation step 
of the form \code{"U"}.

C pointer types can be mapped as a linear type \code{P}, if the values are never \code{NULL}, otherwise they are mapped
as the specific type \code{MayNull P}. In a type encoding the application of \code{MayNull} is represented by
a pseudo derivation step of the form \code{"N"}.

Linear types may be mapped by Gencot as readonly or not (see Section~\ref{design-types-readonly}). 
This is encoded by pseudo derivation steps of the form \code{"R"} for readonly and \code{"M"} (``modifyable'')
otherwise. Nonlinear types are not marked by either of these steps. Parameters of linear type for 
which the item property Add-Result has not been declared are also not
marked by either of these steps.

For all derivation steps which are applied to a base type, their encodings are concatenated, beginning with the 
last derivation step, with an underscore \code{\_} as separator. For a derived pointer or 
function type the base type can be the pseudo type \code{void}. In these cases the identifier \code{Void} is
used as base type encoding.

Hence, for example for the C type
\begin{verbatim}
  int (* [5])(int, const short*)
\end{verbatim}
the encoding is
\begin{verbatim}
  A5_P_FXU32XR_N_P_U16X_U32
\end{verbatim}

These encodings are used for representing C function pointer types by prepending \code{CFunPtr\_} or \code{CFunInc\_}
to construct abstract Cogent type names. For example, the C function pointer type
\begin{verbatim}
  int (*)(int[16], struct str)
\end{verbatim}
is mapped to the abstract Cogent type defined as
\begin{verbatim}
  type CFunPtr_FXA16_U32XU_Struct_Cogent_strX_U32
\end{verbatim}

\subsection{Defined Type Names}
\label{design-types-typedef}

In C a typedef can be used to define a name for every possible type. In principle, it would be possible to
map a typedef name by resolving it to its type and then mapping this type as described above. However, the
typedef name often bears information for the programmer, hence the goal for Gencot is to preserve this information
and map the typedef name to the corresponding Cogent type name which is defined by translating the typedef
to a Cogent type definition.

Moreover, when a C type is derived from a typedef name, Gencot also maps the derived type using the mapped typedef name
as type argument in the corresponding parameterized type or type encoding. Since the mapped typedef name is defined to be a synonym 
for the mapped type definition, the resulting parameterized Cogent type is equivalent to the mapping of the derived 
type with the resolved typedef name as base type.

An exception from this rule are typedef names for struct, union, and array types. Mapping pointer types derived 
from such typedef names with the help of \code{CPtr} would result in the following situation:
\begin{verbatim}
  typedef struct s snam
  mapping: struct s -> #Struct_s
  mapping: struct s * -> Struct_s
  mapping: snam -> Cogent_snam
  mapping: snam * -> CPtr Cogent_snam
\end{verbatim}
where \code{Struct\_s} is the name of the Cogent record type corresponding to \code{struct s}. The problem here
is that for the mapped typedef name the pointer corresponds to a pointer to pointer to struct which is not binary 
compatible with the mapped struct pointer.

Therefore Gencot treats every typedef name resolving to a struct, union, or array type as if 
it would resolve to the corresponding pointer type. The plain name is mapped with the unbox operator 
applied (for arrays depending on the usage context), the pointer type derived from it is mapped without 
unbox operator applied. 

A similar approach is used for typedef names resolving to a C pointer type which is mapped to a Cogent type of the 
form \code{MayNull P} (see Section~\ref{design-types-pointer}). Since it may depend on the Not-Null property of the 
typed item whether its values may be \code{NULL} or not, it may be necessary to use the type \code{P} for some items.
To be able to do this also when a typedef name is defined for it, Gencot defines the typedef name as a synonym 
for the type \code{P} and translates its use by applying \code{MayNull} to the type synonym, if necessary.

Special treatment is also required for the abstract type names used for representing function pointer types, as
described in Section~\ref{design-types-pointer}. For them substitutability of contained type names (i.e. substituting
a Cogent type name by its definition results in an equivalent type) is no more automatic, if mapped typedef names 
are used in names constructed by the type encoding rules. To provide substitutability
for such types Gencot explicitly defines every occurring type encoding which contains mapped type names as a synonym for the
encoding of the fully resolved type. Through transitivity of the type equivalence relation this results in full
substitutability for all type encodings and makes it feasible to use mapped typedef names also in type encodings.

The form of the actual type synonym definitions depends on the approach used for constructing function pointer type 
mappings using type encodings (see Section~\ref{design-types-pointer}). If generic types are used which take the encoding
as type argument, only one synonym definition of the form 
\begin{verbatim}
  type Enctype = Encresolvtype
\end{verbatim}
is required for every occuring type encoding \code{Enctype} with embedded mapped typedef names. 

In particular, if the base type of a function pointer type is a typedef name for a function type, this makes the mapped
typedef name \code{Enctype} a synonym for the fully resolved function type \textit{encoding} instead of the function type itself.
However, this is not a problem: in C a typedef name for a function type cannot be used for defining a function of that type, 
since a definition must always include the parameter names. A C typedef name for a function type can only be used
for declaring functions and for constructing the corresponding C function pointer type, either explicitly or implicitly 
by adjustment. So for every use of the second kind it must be mapped to a (synonym for an) encoding anyways, and a synonym 
for the Cogent function type is never required. Function declarations are only translated to Cogent for external functions,
resulting in abstract function definitions for exit wrappers. Here the function type name is resolved to the function type.

If monomorphic types are
used, a synonym definition is required for every type constructed from such a type encoding:
\begin{verbatim}
  type CFunPtr_Encfuntype = CFunPtr_Encresolvfuntype
  type CFunInc_Encrestype = CFunInc_Encresolvrestype
\end{verbatim}
Here, if \code{Encfuntype} is a mapped function type name, no synonym is defined for it in isolation. Therefore it can 
be used as synonym for the corresponding Cogent function type. 

Names for function types are translated without unbox operator applied. It could be added to make apparent that it is
a nonlinear type, however, the current Cogent version detects a function type with unbox operator as not equivalent to
the function type without unbox operator.

The resulting mapping rules are for function type names:
\begin{verbatim}
  tn -> TN
  tn* -> #CFunPtr_TN
\end{verbatim}
for names of function pointer types:
\begin{verbatim}
  tn -> #TN
\end{verbatim}
for names of a struct or union type:
\begin{verbatim}
  tn -> #TN
  tn* -> MayNull TN
\end{verbatim}
for names of an array type:
\begin{verbatim}
  tn -> TN, #TN
  tn* -> Maynull TN
\end{verbatim}
depending on its usage context for \code{tn}, 
for names of a pointer type:
\begin{verbatim}
  tn -> MayNull TN
\end{verbatim}
and for all other type names:
\begin{verbatim}
  tn -> TN
\end{verbatim}
where \code{TN} is the name mapping of \code{tn}.

This implies, that also the Cogent type definitions generated from a C typedef have to be modified, if
the target type is a struct, union, or array type. In this case Gencot translates the typedef 
to a Cogent type definition which defines the mapped typedef name as a synonym 
for the corresponding boxed type in Cogent. If the target type is a pointer type Gencot omits the 
application of \code{MayNull} to the defining type.

\subsection{Linear and Readonly Types}
\label{design-types-readonly}

C types can be qualified as \code{const}. This means, the values of the type are immutable and could be stored in 
a readonly memory. A variable declared with a const qualified type is initialized with a value and cannot be modified 
afterwards. The immutability of an aggregate type also implies that values cannot be modified by modifying parts: 
for a struct the fields cannot be modified and for an array the elements cannot be modified. This behavior corresponds 
to the behavior of all primitive and unboxed types in Cogent. 

If a C type is not qualified as \code{const}, stored values of the type may be modified. This may have non-local
effects if the stored value is shared (part of several other values). In Cogent, values of primitive and unboxed types
cannot be shared (only copies can be part of other values). Therefore a modification of the C value always corresponds to
replacing the value bound to a variable in Cogent. This can be represented by binding the new value to a variable
of the same name which will shadow the previous binding. Together, this means that a \code{const} qualifier is
irrelevant whenever a C type is translated to a primitive or unboxed type in Cogent.

\subsubsection{Pointer Types}

The situation is different for C pointer types which are translated to linear types in Cogent. Values of linear types
may be modified using put and take operations in Cogent, but they are restricted in their use. Put and take operations
correspond to modifications of the value referenced by the pointer. Thus, a \code{const} qualification of the pointer
type is still irrelevant for them, however, a \code{const} qualification of the pointer's \textit{base type} means
that put and take operations are not possible. This case is supported by Cogent as readonly types, which are not
restricted in their use in the same way as linear types.

Note, however, that Cogent does not separate between pointers and their referenced values: the referenced value
is treated as part of the linear value. If the referenced value itself contains references, the values referenced
by them are also treated as part of the overall value. This implies, that a readonly type in Cogent corresponds to
a C pointer type with \code{const} qualified base type where all components with a pointer type transitively have
the same property.

It further implies, that a C type also corresponds to a linear type in Cogent, if it directly or indirectly 
\textit{contains} pointers where the base type is not \code{const} qualified. This may be the case for struct or union
types (members may have such pointer types) or for array types (the elements may have such a pointer type).

An exception are C pointers to functions. It is assumed that the function code cannot be modified, hence a C pointer 
to function is treated like a primitive type in Cogent.

Gencot tests every C type for being a pointer or containing a pointer. If this is the case, the translated Cogent 
type is known to be linear. The C type is then further tested whether all pointers have a \code{const} qualified
base type. If this is the case, the Read-Only property is set for the corresponding item (see Section~\ref{design-types-itemprops}). 
If the property is not removed by the developer the item's type is translated to a Cogent readonly type
by applying the bang operator \code{!} to the type after translating it as described in Section~\ref{design-types-pointer}.

In particular, the readonly property is valid for all pointer types where the base type is \code{const} qualified 
and contains no pointers, such as \code{const char*}.

If a C pointer type is translated to a type of the form \code{MayNull t} (see Section~\ref{design-types-pointer}) the bang operator
is applied after \code{MayNull} resulting in \code{(MayNull t)!}. If a typedef name is defined for such a type the
\code{MayNull} is removed as described in Section~\ref{design-types-typedef} and applied together with the bang operator
to every occurrence of the translated typedef name. Since the defined type can only be banged if it or the typedef name
has the Read-Only property the bang operator is still preserved for the defined type, other than the \code{MayNull}. 
The difference is that the bang operator is caused by the presence of the Read-Only property whereas the \code{MayNull}
is caused by the absence of the Not-Null property.

\subsubsection{Global Variables}

If a function accesses a global variable, a pointer to the variable is passed to the function, if specified using
a Global-State property (see Section~\ref{design-types-itemprops}). In this case a \code{const} qualifier for the 
variable's type becomes relevant, because it is now the base type of the function parameter. Moreover it means
that the variable value is never modified and always has its initial value.

Gencot exploits this as follows. If a global variable has a \code{const} qualified type and all contained pointers
have a \code{const} qualified base type, the Const-Val property is set for the global variable item (see 
Section~\ref{design-types-itemprops}). Note that in case of an array type a \code{const} qualified base type has the 
same meaning as if the array type itself is \code{const} qualified. If the property is not removed by the developer, 
Gencot translates the variable to a parameterless access function. The function's name is the mapped name of the variable.

If the variable's type is a primitive type, an enum type, or a pointer type (including function pointers) the access 
function returns a value of the mapped type (which is not banged). If the variable has a derived array type the 
function returns a value of the readonly boxed mapped type, if it has a struct or union type the function returns a 
value of the readonly corresponding boxed type. In both cases the result corresponds to a pointer to the variable.
The readonly type prevents modifying the variable through this pointer.

Additionally, a Global-State property can be declared for a variable with Const-Val property. Then function parameters
can be introduced for passing pointers to the variable to functions. All these parameters must explicitly be
declared Read-Only to prevent modifying the variable value through the pointer.

\subsubsection{The String Type}

As described in Section~\ref{design-types-pointer}, the type \code{char*} may be translated to the Cogent type \code{String}.
This is only done, if the Read-Only property is present for the corresponding item. Since \code{String} is not linear
Gencot always omits the bang operator for type \code{String}.

If a typedef name is defined in C for a type which is translated to type \code{String} the bang operator is also omitted
for the translated typedef name. This is consistent with the case where typedef names are defined for other C types which
are translated to Cogent nonlinear types, here the translated typedef name is also never banged.

\subsubsection{Array Types}

As described in Section~\ref{design-types-array}, the mapping of C array types depends on the type's context and may 
be a linear type or not. The properties Const-Val and Read-Only for items with array type must be treated accordingly.

An array type is mapped to a linear type if it is used as type of a global variable or a function parameter. In case of
a global variable with a Const-Val property, such as
\begin{verbatim}
  const int gvar[5];
\end{verbatim}
Gencot translates the variable to an access function returning a readonly pointer:
\begin{verbatim}
  cogent_gvar: () -> (Carr5 U32)!
\end{verbatim}
In case of a function parameter with Read-Only property, such as
\begin{verbatim}
  void f(const int p[5]);
\end{verbatim}
the parameter type is already ``adjusted'' to type \code{const int *p} in C and Gencot maps the parameter type 
accordingly. Here, the Read-Only property causes the parameter type to be readonly:
\begin{verbatim}
  cogent_f: (Carr5 U32)! -> ()
\end{verbatim}

If an array type is used as base type of a derived pointer type the pointer
type is mapped to a readonly type, as described above, if its referenced subitem has a Read-Only property declared.
The same applies if an array type is used as element type of another array type (multidimensional array) with
a Read-Only property for the inner array item.

If an array type is used as the type of a member of a composite type it is mapped to a record field with an unboxed type,
hence a Read-Only property for the member is irrelevant. Since the current Cogent version has problems when bang and unbox operators
are combined, Gencot omits the bang operator in this case. 

If a typedef name is defined for an array type in C, the mapped typedef name is defined for the linear type in Cogent. 
If the typedef name is used for a member of a composite type, the Cogent type must not be readonly, therefore it
cannot be made readonly in the definition, even if the typedef name has a Read-Only property.
Instead, the mapped typedef name must be banged whenever no unbox operator is applied. 

\subsubsection{Manual Readonly Types}

Values of a C type where not all pointer base types are const qualified may still be used in an immutable way in the 
C program, if the C programmer forgot to specify the const qualifier or did not care about it. In such cases the item
property Read-Only can be set manually to tell Gencot to apply the bang operator when it maps the type to Cogent.

For a \code{const} qualified array type used for a member of a compound type the Read-Only property is always ignored,
even if it has been set manually.

