After Gencot has translated C code to Cogent, the Cogent compiler will generate a logic
based representation of the code and a proof that the generated C code refines that representation.
Both the representation (``shallow embedding'') and the proofs are generated in Isabelle notation. 

However, the abstract types and functions used in the Cogent code are not covered by this Isabelle 
code. Since Gencot uses several specific abstract types and functions to represent the C types (as 
described in Sections~\ref{design-types} and~\ref{design-operations}), the corresponding representations
and refinement proofs must be added to the Isabelle code to fully cover a C program translated by 
Gencot. Since the semantics of these types and functions is defined by Gencot, Gencot is able to 
automatically generate these parts of the Isabelle code.

\subsection{Representing Gencot Types}
\label{design-isabelle-types}

Specific treatment is necessary whenever Gencot uses abstract types to represent a C type in Cogent.
Most C types are mapped to Cogent using the normal Cogent types in specific ways. In these cases the 
Cogent compiler already generates corresponding Isabelle code. However, also in some of these cases 
Gencot modifies that code.

\subsubsection{Isabelle Types Generated by Cogent}

The Isabelle code for representing all Cogent types is generated by Cogent in a file \code{X\_ShallowShared.thy}
where \code{X} is a program specific prefix. The code consists of
\begin{itemize}

\item a type declaration for every abstract Cogent type, using the same type name as in Cogent.

\item a record definition for every equivalence class of record types occurring in the Cogent program. Two record
types are equivalent, if they have the same field names in the same order. If there is a type synonym defined
for the record type in Cogent (one of) the synonym name is used for the record, otherwise a generated name of
the form \code{T<nr>} is used. For every Cogent field name \code{x} the name $\code{x}_\code{\small{f}}$ is used in Isabelle.

Additionally, Cogent tuple types are represented by records with field names
\code{p1}, \code{p2}, ... and the corresponding records are defined. The record for pairs always has the name
\code{RR}, the names for the other tuple records are determined as described above.

\item a datatype definition for every variant type occurring in the Cogent program. The type name is determined 
as for the records. As names for the alternative constructors the Cogent tag names are used.

\item a type synonym definition for every Cogent type definition. For every Cogent type name \code{X} the
type synonym $\code{X}_\code{\small{T}}$ is defined in Isabelle.

\end{itemize}

Since Gencot uses tuple types in its predefined operations, it is necessary to know the names of the records for
representing tuples in Isabelle in advance, so that Isabelle specifications can be defined by Gencot for these 
operations. Gencot uses the include file \code{Tuples.cogent} which contains type synonyms \code{Tup<nr>} for 
the tuple types from 3 to 9 components. Whenever another Gencot include file uses tuple types with more than 
two components it includes this file, so that the tuple records in Isabelle are named accordingly.

\subsubsection{Gencot Array Types}

\subsubsection{Type \code{MayNull}}

\subsection{Specifying Gencot Operations}
\label{design-isabelle-operations}

\subsubsection{Gencot Array Operations}

\subsubsection{Operations for Type \code{MayNull}}

\subsection{Specifying Cogent Operations}
\label{design-isabelle-cogentops}

Cogent defines several abstract function in its standard library. However, as of February 2021 the Cogent distribution
does not contain Isabelle specifications for them. Therefore Gencot provides Isabelle specifications for all such
functions which are used by Gencot.

\subsubsection{Iteration Funktions}

\subsection{Generating Refinement Proofs}
\label{design-isabelle-proofs}
