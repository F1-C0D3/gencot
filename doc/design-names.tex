\subsection{Mapping Names from C to Cogent}
\label{design-names}

Names used in the C code shall be translated to similar names in the Cogent code, since they usually are descriptive for the
programmer. Ideally, the same names would be used. However, this is not possible, since Cogent differentiates between 
uppercase and lowercase names and uses them for different purposes. Therefore, atleast the names in the ``wrong'' case
need to be mapped.

Additionally, when the Cogent compiler translates a Cogent program to C code, it transfers the names without changes to
the names for the corresponding C items. We will see below, that often these generated C items are needed additionally to
the original C item which has been translated to Cogent by Gencot. If Gencot uses the same name in Cogent, this would cause
a name conflict in the code generated by the Cogent compiler.

For this reason, Gencot uses name mapping schemas mapping all kinds of names which can cause such a conflict to a different, but 
similar name in Cogent. Generally, this is done by substituting a prefix of the name.

Often, a <package> uses one or more specific prefixes for its names, at least for names with external linkage. In this case
Gencot should be able to substitute these prefixes by other prefixes specific for the Cogent translation of the <package>.
Therefore, the Gencot name mapping is configurable. For every <package> a set of prefix mappings can be provided which is
used by Gencot. Two separate mappings are provided depending on whether the Cogent name must be uppercase or lowecase, so 
that the target prefixes can be specified in the correct case.

If a name must be mapped by Gencot which has neither of the prefixes in the provided mapping, it is mapped 
by prepending the prefix \code{cogent\_} or \code{Cogent\_}, depending on the target case.

\subsubsection{Name Kinds in C}

In C code the tags used for struct, union and enum declarations constitute an own namespace separate from the ``regular''
identifiers. These tags are mapped to Cogent type names by Gencot and could cause name conflicts with regular identifiers
mapped to Cogent type names. To avoid these conflicts Gencot maps tags by prepending the prefixes \code{Struct\_}, 
\code{Union\_}, or \code{Enum\_}, respectively, after the mapping described above. Since tags are always translated to Cogent 
type names, which must be uppercase, only one case variant is required.

Member names of C structs or unions are translated to Cogent record field names. Both in C and Cogent the scope of these
names is restricted to the surrounding structure. Therefore, Gencot normally does not map these names and uses them unmodified
in Cogent. However, since Cogent field names must be lowercase, Gencot applies the normal mapping for lowercase target 
names to all uppercase member names (which in practice are unusual in C). 

C function parameter names are translated to Cogent variable names bound in the Cogent function body expression. Hence, both
in C and Cogent the scope of these names is restricted to the function body. They are treated by Gencot in the same way as 
member names and are only mapped if they are uppercase in C, which is very unusual in practice.

The remaining names in C are type names, tags, function names, enum constant names, and names for global and local variables.
Additionally, there may be C constant names defined by preprocessor macro directives.
Local variables only occur in C function bodies which are not translated by Gencot. The other names are always mapped by
Gencot, irrespective whether they have the correct case or not. The reasons are explained in Section~\ref{design-modular}
below.

\subsubsection{Names with internal linkage}

In C a name may have external or internal linkage. A name with internal linkage is local to the compilation unit in which it
is defined, a name with external linkage denotes the same item in all compilation units. Since the result of Gencot's 
translation is always a Cogent program which is translated to a single compilation unit by the Cogent compiler, names 
with internal linkage could cause conflicts when they origin in different C compilation units.

To avoid these conflicts, Gencot uses a name mapping scheme for names with internal linkage which is based on the 
compilation unit's file name. Names with internal linkage are mapped by substituting a prefix by the prefix \code{local\_x\_}
where \code{x} is the basename of the file which contains the definition, which is usually a file \code{x.c}. The default
is to substitute the empty prefix, i.e., prepend the target prefix. The mapping can be configured by specifying prefixes
to be substituted. This is motivated by the C programming practice to sometimes also use a common prefix for names 
with internal linkage which can be removed in this way.

Name conflicts could also occur for type names and tags defined in a \code{.h} file. This would be the case if different
C compilation units include individual \code{.h} files which use the same identifier for different purposes. However, most
C packages avoid this to make include files more robust. Gencot assumes that all identifiers defined in a \code{.h} file
are unique in the <package> and does not apply a file-specific renaming scheme. If a <package> does not satisfy this assumption
Gencot will generate several Cogent type definitions with the same name, which will be detected and signaled by the Cogent 
compiler and must be handled manually.

\subsubsection{Introducing Type Names}

There are cases where in Cogent a type name must be introduced for an unnamed C type (directly specified by a C type 
expression). Then the Cogent type name cannot be generated by mapping the C type name.

Unnamed C types are tagless struct/union/enum types and all derived types, i.e., array types, pointer types and 
function types. Basically, an unnamed C type could be mapped to a corresponding Cogent type expression. However,
this is not always possible or feasible.

Tagless enum types
are always mapped to a primitive type in Cogent. Also, for some pointer types corresponding Cogent type expressions can
be defined. 

A tagless C struct could be mapped to a corresponding Cogent record type expression. However, the tagless struct
can be used in several declarators and several different types can be derived from it. In this case the Cogent record
expression would occur syntactically in several places, which is semantically correct, but may not be feasible for
large C structs. Therefore, Gencot introduces a Cogent type name for every tagless C struct.

In the remaining cases no corresponding binary compatible type can be defined for a C type in Cogent (see Section~\ref{design-types}). In these cases 
an abstract type is defined in Cogent which references the C type. The abstract type in Cogent is specified by its 
name only, hence a Cogent type name must be introduced.

To be able to process every source file independently from all other source files, Gencot uses a schema which generates
a unique name for every C type expression. 

Tagless structs and unions syntactically occur at only a single place in the source. The unique name is derived from 
that place, using the name of the corresponding source file and the line number where the struct/union begins
in that file (this is the line where the struct or enum keyword occurs).
The generated names have the forms
\begin{verbatim}
  <kind><lnr>_x_h
  <kind><lnr>_x_c
\end{verbatim}
where the suffix is constructed from the name \code{x.h} or \code{x.c} of the source file. \code{<kind>} is one of
\code{Struct} or \code{Union}, and \code{<lnr>} is the line number in the source file.

Derived types may syntactically occur at many places in a C program. The base type of a derived
type is always either another derived type, a typedef name, or a struct/union/enum type. Gencot maps all
struct/union/enum types to a Cogent type name. Hence every derived type can be uniquely characterized by a sequence
of derivation steps starting with a type name. The sequence of derivation steps is syntactically encoded in the 
generated name as follows.

A pointer derivation step is encoded by a single letter ``P''. 

An array derivation step without size
specification is encoded by a single letter ``A''. An array derivation step with a literal or a single identifier
as size specification is encoded in the form
\begin{verbatim}
  A'<size>'
\end{verbatim}
where \code{<size>} is the size specification (note, that the prime character is valid in Cogent identifiers). 
In all other cases an array derivation step is encoded by
\begin{verbatim}
  A''
\end{verbatim}
which may lead to name conflicts in Cogent and must be handled manually.

A function derivation step is encoded in the form
\begin{verbatim}
  F_'<P1>'<P2>'...'<Pn>'_
\end{verbatim}
where the \code{<Pi>} are the parameter types. If parameters are not specified or are varargs the function
derivation step is encoded by a single letter ``F'', which may lead to name conflicts in Cogent and must 
be handled manually.

If several derivation steps are applied to a base type, their encodings are concatenated, beginning with the 
last derivation step. The identifier for the base type is appended to the encoding for the first derivation step,
separated by an underscore, if the first step is not a function derivation step. For a derived pointer or 
function type the base type can be the pseudo type \code{void}. In these cases the identifier \code{Void} is
used for the base type in the Cogent type name.

Hence, for example for the C type
\begin{verbatim}
  int (* [5])(int, short)
\end{verbatim}
the generated name is
\begin{verbatim}
  A'5'PF_'U32'U16'_U32
\end{verbatim}

Note that the generated Cogent type names could still cause conflicts with mapped type names. These conflicts can be
avoided if no configured mapping prefix starts with one of the \code{<kind>} strings. 
or an possible encoding of a derivation step.
