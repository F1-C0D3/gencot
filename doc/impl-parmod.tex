As described in Section~\ref{design-parmod} Gencot uses a parameter modification description in JSON format 
to be filled in collaboration with the developer to determine which function parameters may be modified during
a function call. 

\subsection{Description Structure}
\label{impl-parmod-struct}

This
description is structured as follows. It is a list of JSON objects, where each object is an entry which describes a function using
the following attributes:
\begin{verbatim}
    { "f_name" : <string>
    , "f_comments" : <string>
    , "f_def_loc" : <string>
    , "f_num_params" : <int> or <string>
    , "f_result" : <string>
       <parameter descriptions>
    , "f_num_invocations" : <int>
    , "f_invocations" : <list of invocation descriptions>
    }
\end{verbatim}

The attribute \code{f\_name} specifies a unique identifier for the function, as described in Section~\ref{impl-parmod-ids}.
The attribute \code{f\_comments} is not used by Gencot, it can be used by the developer to add arbitrary textual
descriptions to the function entry. The attribute \code{f\_def\_loc} specifies the name of the C source file containing
the definition of the function or functionn pointer (or its declaration, when the function entry has been 
generated for closing the JSON description). 

The attribute \code{f\_num\_params} specifies the number of parameters. In the case of a variadic function or a function
with incomplete type (which may be the case if the entry has been generated from a declaration), it is specified
as \code{"variadic"} or \code{"unknown"}, respectively. The attribute \code{f\_result} specifies the identifier of
the parameter which is returned as function result (typically afer modifying it). If the result is not one of the 
function parameters, the attribute is not present. This attribute is never generated by Gencot, it must be added manually
by the developer. 

All known parameters of the function are described in the \code{<parameter descriptions>}. 
Every parameter description consists of a single attribute where the parameter identifier (see Section~\ref{impl-parmod-ids})
is the attribute name. The value is one of the following strings:
\begin{description}
\item[\code{"nonlinear"}] According to its type the parameter is not a pointer and its value does not contain pointers directly or
indirectly.
\item[\code{"readonly"}] The parameter is not \code{"nonlinear"} but according to its type all pointers in the parameter have a \code{const} qualified referenced type.
\item[\code{"yes"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"} and it is directly modified by the function.
\item[\code{"discarded"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"} and it is directly discarded 
(``freed'') by the function. 
\item[\code{"depends"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"}, it is neither modified 
or discarded directly, but it may be modified by an invoked function. 
\item[\code{"no"}] None of the previous cases applies to the parameter.
\item[\code{"?"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"}, but the remaining properties are unconfirmed.
\item[\code{"?depends"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"} and it may be modified by an invoked function,
but the remaining properties are unconfirmed.
\end{description}

Gencot only generates parameter descriptions with the values \code{"nonlinear"}, \code{"readonly"}, \code{"yes"}, \code{"?"}, and \code{"?depends"}.
The first two can be safely determined from the C type. If Gencot finds a direct modification, it sets the description to 
\code{"yes"}. Otherwise, if it finds a dependency on an invocation, it sets the description to \code{"?depends"}. Otherwise
it sets it to \code{"?"}.

The task for the developer is to check all unconfirmed parameter descriptions by inspecting the source code. If a local modification
is found, the value must be changed to \code{"yes"}. Otherwise, if the description was \code{"?depends"} it must be confirmed 
by changing it to \code{"depends"}. Otherwise, if a dependency is found, the value \code{"?"} must be changed to \code{"depends"},
otherwise it must be set to \code{"no"}.

Discarding a parameter is normally only possible by invoking the function ``free'' in the C standard library. No other function
can directly discard one of its parameters. However, a parameter may be discarded by invoking an external function which indirectly
invokes free. The task for the developer is to identify all these cases where an external function (where the entry has been
generated during closing the JSON description) discards one of its parameters and set its parameter description to \code{"discarded"}.

It may be the case that a C function modifies a value referenced by a parameter and returns the parameter as its result, such as 
the C standard function \code{memcpy}. In this case the parameter need not be added to the Cogent result tuple, since it already
is a part of it. To inform Gencot about this case the developer has to add a \code{f\_result} attribute to the function
description. As an example, the description for the C function \code{memcpy} should be
\begin{verbatim}
    { "f_name" : "memcpy"
    , "f_comments" : ""
    , "f_def_loc" : "string.h"
    , "f_num_params" :3
    , "f_result" :"1-__dest"
    , "1-__dest" :"yes" 
    , "2-__src" :"readonly" 
    , "3-__n" :"nonlinear" 
    }
\end{verbatim}
since it always returns its first parameter as result.

The attribute \code{f\_num\_invocations} specifies the number of function invocations found in the body of the described function.
If the same function is invoked several times, it is only counted once. The attribute \code{f\_invocations} specifies a list
of JSON objects where each object describes an invocation. If the function entry describes a function pointer or an external
function, no body is available, so no invocations can be found and both attributes are omitted. If no parameter depends on
any invocation, the second attribute (invocation list) is omitted, only the number of invocations is specified.

An entry in the list of invocations describes an invocation using the following attributes:
\begin{verbatim}
    { "name" : <string> 
    , "num_params" : <int> or <string>
      <argument descriptions>
    }
\end{verbatim}

The attribute \code{"name"} specifies the function identifier of the invoked function. The attribute \code{"num\_params"}
specifies the number of parameters according to the type of the invoked function, in the same way as the attribute
\code{"f\_num\_params}. If an invoked function has no parameters, no entry for it is added to the invocation list.

The \code{<argument descriptions>} describe all known arguments of invocations of the function. When Gencot creates an
invocation description, it inserts argument descriptions according to the maximal number of arguments found in an 
invocation of this function. Thus, also for invocations of incompletely defined or variadic functions, an argument
description is present for every actual argument used in an invocation.

Every argument description consists of a single attribute where the attribute name is the parameter identifier of the 
parameter corresponding to the argument. The value is one of the strings \code{"nonlinear"} or \code{"readonly"}
(according to the type of the parameter of the invoked function), or a list of parameter identifiers.

If the value is \code{"nonlinear"} or \code{"readonly"} parameter dependencies on this argument are irrelevant, since
the invoked function cannot modify or discard it. Otherwise, the list specifies parameters of the \textit{invoking}
function for which the modification or discarding depends on whether the invoked function modifies or discards this
argument.

The task for the developer is for all unconfirmed parameter descriptions of the invoking function to check whether
there are (additional) dependencies on arguments of invoked functions and add these dependencies to the argument 
descriptions.

\subsection{Identifiers for Functions and Parameters}
\label{impl-parmod-ids}

In the JSON description unique identifiers are needed for all described functions, so that they can be referenced by
invocations. Gencot uses the item identifiers as defined in Section~\ref{impl-itemprops-ids} as function identifiers.
An item identifier is a function identifier, if the item has a derived function type.

In the JSON description unique identifiers are also needed for all described function parameters, so that they can 
be referenced by argument descriptions. Since these references are always local in a function description, parameter
identifiers need only be unique per function. Therefore the C parameter name is usually sufficient as id in the 
JSON description.

However, the parameter name is not always available: If the function has an incomplete type no parameter names are
specified, if the function is variadic, only the names of the non-variadic parameters are specified. Therefore
Gencot always uses the position number as parameter id, where the first parameter has position 1. To make the JSON
description more readable for the developer, Gencot appends the parameter name whenever it is available. Together,
a parameter id is a string with one of the forms
\begin{verbatim}
    <pos>
    <pos>-<name>
\end{verbatim}
where \code{<pos>} is the position number and \code{<name>} is the declared parameter name.

Since all parameter identifiers are strings they can be used as JSON attribute names and since they always
start with a digit they can be recognized and do not conflict with other JSON attribute names. 

When Gencot reads and processes a JSON parameter modification description it removes the optional name from 
all parameter identifiers and uses only the position. Hence parameter identifiers are considered equal if they
begin with the same position.

\subsection{Example}

The following example illustrates the format of the parameter modification descriptions. It consists of two
function descriptions, one for a defined function with internal linkage and one for a function pointer parameter
invoked by that function.
\begin{verbatim}
[
    { "f_name" :"app:somefun" 
    , "f_comments" :"" 
    , "f_def_loc" :"app.c" 
    , "f_num_params" :5
    , "1-f_sort" :"nonlinear" 
    , "2-desc" :"readonly" 
    , "3-input" :"?depends" 
    , "4-size" :"nonlinear" 
    , "5-result" :"yes" 
    , "f_num_invocations" :2
    , "f_invocations" :
        [ 
            { "name" :"memcpy" 
            , "num_params" :3
            , "1-__dest" :[ "3-input" ]
            , "2-__src" :"readonly" 
            , "3-__n" :"nonlinear" 
            } 
        , 
            { "name" :"app:somefun/f_sort/*" 
            , "num_params" :3
            , "1-arr" :[ "3-input" ]
            , "2-h" :[]
            , "3-len" :"nonlinear" 
            } 
        ] 
    } 
, 
    { "f_name" :"app:somefun/f_sort/*"
    , "f_comments" :"" 
    , "f_def_loc" :"app.c" 
    , "f_num_params" :3
    , "1-arr" :"?" 
    , "2-h" :"?" 
    , "3-len" :"nonlinear" 
    } 
]
\end{verbatim}
The description is not closed, since it does not contain an entry for the invocation \code{memcpy}. This
invocation is required, since parameter \code{input} of \code{somefun} depends on its first argument
which is neither nonlinear nor readonly. If the description of parameter \code{input} is changed
to \code{"yes"}, the description is closed, since now the invocation \code{memcpy} is not required
anymore.

\subsection{Reading and Writing Json}
\label{impl-parmod-json}

Input and output of JSON data is done using the package \code{Text.Json}. There is another package \code{Data.Aeson} for
Json processing which supports a much more flexible conversion between JSON and Haskell types, but this is not
needed here.

The package \code{Text.Json} uses the type \code{JSValue} to represent an arbitrary JSON value. It provides the functions
\code{encode} and \code{decode} to convert between \code{JSValue} and the JSON string representation. Depending
on the kind of actual value, a \code{JSValue} can be converted from and to corresponding Haskell types using
the functions \code{readJSON} and \code{showJSON}. A JSON object is converted to the type \code{JSObject a} where
\code{a} is the type of attribute values, usually this is again \code{JSValue}. A \code{JSObject a} can be further
processed by converting it from and to an attribute-value list of type \code{[(String,a)]} using the functions
\code{fromJSobject} and \code{toJSObject}.

The Gencot parameter modification description is represented as a list of Json objects of type \code{[JSObject JSValue]}.
The same representatiom is used for the contained invocation description lists. For internal processing the objects
are converted to attribute-value lists. All processing of JSON data is directly performed on these lists.

A parameter modification description is read by applying the \code{decode} function to the input to yield a
list of \code{JSObject JSValue}. It is output by applying the \code{encode} function to such a list. 

Additionally,
the resulting string representation is formatted using the general prettyprint package \code{Text.Pretty.Simple}.
The function \code{pStringNoColor} is used since it does not insert control sequences for colored represenation
and produces a plainly formatted text representation. Its result is of type \code{Text} and must be converted to a
string using the function \code{unpack} from package \code{Data.Text}.

\subsection{Evaluating a Description}
\label{impl-parmod-eval}

A parameter modification description is complete, if all paremeter descriptions are confirmed and the description 
is ``closed'', i.e., has no required invocations. This implies that whenever a parameter is dependent on an invocation argument,
there is a function description present for the invoked function where the corresponding parameter is described.
This allows to eliminate all parameter dependencies by following them until an independent parameter description is found.
This process is called ``evaluation'' of the parameter modification description.

The result of evaluation is a simplified parameter modification description where the value \code{"depends"} does not 
occur anymore as parameter description. Additionally, all information about function invocations is removed, since it is
no more needed.

Evaluation only terminates, if there are no cyclic parameter dependencies. This property is checked by Gencot. If there
are cyclic parameter dependencies in the C code they must be eliminated manually by the developer by removing enough dependencies 
to break all cycles.

A parameter may have several dependencies, which may result in different description values. This cannot be the case for
the values \code{"nonlinear"} and \code{"readonly"}: If the parameter of the invoked function has nonlinear type, this
also holds for the passed parameter, no dependency can exist in this case. If the parameter of the invoked function has
a readonly type, the passed parameter can still have a linear type which is not readonly. But it cannot be modified by the
function invocation, hence no dependency can exist in this case either.

Thus, after evaluation, a parameter may have any subset of the values \code{"yes"}, \code{"discarded"}, and \code{"no"}, meaning 
that it may be modified by some invocations, discarded by some invocations, and not modified by others. This is reduced to
a single value as follows. The value \code{"no"} is only used if none of the other two is present. If both \code{"yes"}
and \code{"discarded"} are present, Gencot cannot decide whether the parameter is always discarded (perhaps after modification),
or always modified (perhaps after discarding and reallocating it). In this case it always assumes a modification and
uses the single value \code{"yes"}. If this is not correct it must be handled manually by the developer.

The reason for this treatment is that before evaluation Gencot gives a local modification a higher priority than a dependency,
to reduce the number of required invocations. This may hide a dependency which results in discarding the parameter. To
be consistent, Gencot also prefers modifications resulting from dependencies after evaluation over discarding. 

Since in evaluated parameter modification descriptions all parameter descriptions are still confirmed, the only values
possible for a parameter description are \code{"nonlinear"}, \code{"readonly"}, \code{"yes"}, \code{"discarded"}, and \code{"no"}.
This information is used for declaring the properties Read-Only and Add-Result for the function parameters.

\subsection{Haskell Modules}
\label{impl-parmod-modules}

Parameter modification descriptions are implemented in the following three Haskell modules.

Module \code{Gencot.Json.Parmod} defines the following types for representing parameter modification descriptions:
\begin{verbatim}
  type Parmod = JSObject JSValue
  type Parmods = [Parmod]
\end{verbatim}
They are used for constructing and processing the JSON representation. Type \code{Parmod} represents a single
function description as a JSON object with arbitrary JSON values. Type \code{Parmods} represents a full parameter modification
description consisting of a sequence of function descriptions.

Module \code{Gencot.Json.Translate} defines the translation from C source code to parameter modification descriptions
in JSON format. The monadic action
\begin{verbatim}
  transGlobals :: [DeclEvent] -> CTrav Parmods
\end{verbatim}
translates a sequence of global declarations and definitions (see Section~\ref{impl-ccode-read}) to a sequence of
function descriptions. It translates all definitions and declarations of functions and of objects with function pointer
type or function pointer array type. It translates all type name definitions for a function type, a function pointer type, 
or a function pointer array type.
For every definition of a compound struct or union type it translates all members with function pointer type or function 
pointer array type.
All other \code{DeclEvent}s are ignored.

Module \code{Gencot.Json.Process} defines functions for reading and processing parameter modification descriptions in JSON format.
The main functions are 
\begin{verbatim}
  showRemainingPars :: Parmods -> [String]
  getRequired :: Parmods -> [String]
  filterParmods :: Parmods -> [String] -> Parmods
  mergeParmods :: Parmods -> Parmods -> Parmods
  sortParmods :: Parmods -> [String] -> Parmods
  addParsFromInvokes :: Parmods -> Parmods
  evaluateParmods :: Parmods -> Parmods
  convertParmods :: Parmods -> ItemProperties
\end{verbatim}
The first function retrieves the list of all unconfirmed parameters in the form
\begin{verbatim}
  <function identifier> / <parameter identifier>
\end{verbatim}
The function \code{getRequired} retrieves the function identifiers of all invocations on which at least one parameter depends.
The function \code{filterParmods} restricts a parameter modification description to the descriptions of all function
where the function identifier belongs to the string list. 
The function \code{mergeParmods} merges two parameter modification description. If a function is described in both, the description
with less unconfirmed parameter descriptions is used. If the same number of parameter descriptions are confirmed 
always the description in the first sequence is selected. The function \code{sortParmods} sorts the function descriptions
in a parameter modification description according to the order specified by a list of function identifiers. The parameter
modification description is reduced to the functions specified in the list. If a function occurs in the list more than once, 
the position of its first occurrence is used for the ordering.
The function \code{evaluateParmods} evaluates a parameter modification description as described in 
Section~\ref{impl-parmod-eval}. 

The function \code{convertParmods} converts the JSON representation to an item
property map (see Section~\ref{impl-itemprops-internal} with declarations of the properties Read-Only and Add-Result.
The parameter modification description must have been evaluated as described in Section~\ref{impl-parmod-eval}. The 
resulting single parameter description values are translated to properties as follows: the description \code{"yes"}
is translated to the Add-Result property, the descriptions \code{"readonly"} and \code{"no"} are translated to the 
Read-Only Property. For the remaining descriptions \code{"nonlinear"} and \code{"discarded"} and the \code{f\_result}
attribute no property is declared.
