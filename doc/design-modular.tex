\subsection{Modularization and Interfacing to C Parts}
\label{design-mdular}

Every C compilation unit produces
a set of global variables and a set of defined functions. Data of the same type may be used in
different compilation units, e.g. by passing it as parameter to an invoked function. In this case type compatibility in C is
only guaranteed by including the \code{.h} file with the type definition in both compilation units. In the compiled
units no type information is present any more. 

This organisation makes it possible to use different \code{.h} files in different compilation units. Even the type definitions
in the included files may be different, as long as they are binary compatible, i.e., have the same memory layout.

We exploit this organisation for an incremental translation from C to Cogent as follows. At every stage we replace some 
C compilation units by Cogent sources. All C data types used both in C units and in Cogent units are mapped to binary compatible
Cogent types. Compiling the Cogent sources again produces C code which together with the remaining C units are linked to
the target program. The C code resulting from Cogent compilation is completely separated from the code of the remaining C units,
common include files are only used for types which are abstract in Cogent, i.e., have no Cogent definition.

All interfacing between C compilation units is done by name. All names of C objects with external linkage can be referred
from other compilation units. This is possible for functions and for global variables. Interfacing from and to Cogent works
in the same way. 

\subsubsection{Interfacing to Functions}

Cogent functions always take a single parameter, the same is true for the C functions generated by the Cogent compiler. Hence
for interfacing from or to an arbitrary C function, wrapper functions are needed which convert between arbitrary many parameters
and a single structured parameter. These wrapper functions are implemented in C. 

The ``entry wrapper'' for invoking a Cogent function 
from C has the same name as the original C function, so it can be invoked transparently. Thus the Cogent implementation of
the function must have a different name so that it does not conflict with the name of the wrapper. This is guaranteed by the 
Gencot renaming scheme as described in Section~\ref{design-names}.

The Cogent implementation of a C function generated by Gencot is never polymorphic. This implies that the Cogent compiler
will always translate it to a single C function of the same name.

The ``exit wrapper'' for invoking a C function from Cogent invokes the C function by its original name, hence the wrapper
must have a different name. We use the same renaming scheme for these wrappers as for the defined Cogent functions.
This implies that every exit wrapper
can be replaced by a Cogent implementation without modifying the invocations in existing Cogent code. Note that for every
function either the exit wrapper or the Cogent implementation must be present, but not both, since they have the same name.

Note that if the C function has only one parameter, a wrapper is not required. For consistency reasons we generate and use
the wrappers also for these functions.

Cogent translates all function definitions to C definitions with internal linkage. To make them accessible the entry wrappers
must have external linkage. They are defined in an antiquoted Cogent (.ac) file which includes the complete code generated from 
Cogent, there all functions translated from Cogent are accessible from the entry wrappers. The exit wrappers are only invoked 
from code generated from Cogent. They are defined with internal linkage in an included antiquoted Cogent file.

\subsubsection{Interfacing to Global Variables}

Accessing an existing global C variable from Cogent is not possible in a direct way, since there are no ``abstract constants'' in 
Cogent. Access may either be implemented with the help of abstract functions which are implemented externally in additional C code and
access the global variable from there. Or it may be implemented by passing a pointer as (part of) a ``system state'' to the
Cogent function which performs the access.

Accessing a Cogent object definition from C is not possible, since the Cogent compiler does not generate a definition for them, it
simply substitutes all uses of the object name by the corresponding value. Hence, all global variable definitions need to remain 
in C code to be accessible there.

Since the way how global state is treated in a Cogent program is crucial for proving program properties, Gencot does not 
provide any automatic support for accessing global C variables from Cogent, this must always be implemented manually.

\subsubsection{Cogent Compilation Unit}

As of December 2018, Cogent does not support modularization by using separate compilation units. A Cogent program may be distributed
across several source files, however, these must be integrated on the source level by including them in a single compilation unit.
It would be possible to interface between several Cogent compilation units in the same way as we interface from C units to Cogent
units, however this will probably result in problems when generating proofs. 

Therefore Gencot always generates a single Cogent compilation unit for the <package>. 
At every intermediate stage of the incremental translation the package consists of one Cogent compilation unit 
together with all remaining original C compilation units and optionally additional C compilation units (e.g., for implementing 
Cogent abstract data types).

Conflicts for names with internal linkage originating in different C compilation units are avoided by Gencot's name mapping scheme
as described in Section~\ref{design-names}.

 
