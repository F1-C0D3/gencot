#! /bin/sh

# Modify an Isabelle theory. Intended to be applied to X_ShallowShared.thy or 
# X_ShallowShared_Tuples.thy generated by Cogent.
# This is a filter from stdin to stdout with an additional filename argument.
# The argument file must contain a sequence of lines of the form
#   <id> <id>:<type> <id>:<type> ...
# where <type> is <id>, <id>*, or <id>[<nr>].

if [ $# != 1 ]
then
  echo "Error: Single file name expected as argument."
  exit 0
fi

awk \
'BEGIN { 
   cfile = ARGV[1]; delete ARGV[1] 
   while ((getline cline < cfile) > 0) { 
     if (2 == split(cline,a)) { 
       split(a[2],aa,":")
       if (substr(aa[1],1,3) == "arr") size1[substr(aa[1],4)] = aa[2]
       if (aa[1] == "data" && split(aa[2],aaa,"[") == 2) size2[a[1]] = substr(aaa[2],1,length(aaa[2])-1)
     } 
   }
   close(cfile) 
   fstbeg = 1
 } 
{
  if ($0 == "This file is generated by Cogent") {
    print $0
    print "and modified by Gencot"
  } else if ($1 == "begin" && fstbeg) {
    print "  GencotTypes"
    print $0
    fstbeg = ""
  } else if ($1 == "typedecl" && $3 == "MayNull") {
    printf("type_synonym %s MayNull = \"%s option\"\n", $2, $2)
  } else if ($1 == "type_synonym" && substr($3,1,7) == "CArrPtr" && substr($6,1,7) == "CArrPtr") {
    printf("type_synonym %s %s = \"%s list\"\n", $2, $3, $2)
  } else if ($1 == "type_synonym" && substr($3,1,4) == "CArr" && $6 == "list") {
    size = substr($3,5,length($3)-12)
    nn = ""
    if (size ~ /^[0-9]+$/) nn = size
    else {
      h = size1[size]
      if (h) {
        n = size2[h]
        if (n) nn = n
      }
    }
    if (nn == "") {
      printf("Error in auxcog-shalshared: size unknown for Gencot array type CArr%s\n", size) > "/dev/stderr"
      nn = "error"
    }
    printf("type_synonym %s %s = \"(%s, %s) FixedList %s\n", $2, $3, nn, $2, $7)
  } else print
}' $1

# documentation:
#
# The theory is modified in the following ways:
# - after a line "This file is generated by Cogent" the line "and modified by Gencot" is inserted.
# - the additional theory GencotTypes is imported by prepending it to the first line 
#   which starts with "begin".
# - every line
#     typedecl 'a MayNull
#   is replaced by
#     type_synonym 'a MayNull = "'a option"
# - every line
#     type_synonym 'el CArrPtr\<^sub>T = "'el CArrPtr"
#   is replaced by
#     type_synonym 'el CArrPtr\<^sub>T = "'el list"
# - every line of the form
#     type_synonym 'el CArr<size>\<^sub>T = "'el list CArr<size>"
#   is replaced by
#     type_synonym 'el CArr<size>\<^sub>T = "(<nr>, 'el) FixedList CArr<size>"
#   where <nr> is determined as follows:
#   - if <size> is a literal number, then <nr> = <size>
#   - otherwise if the argument file contains two lines
#       id1 arr<size>:id2
#       id2 data:id3[n]
#     with arbitrary identifiers id1, id2, id3 and a literal number n then <nr> = n
#   - otherwise <nr> = "error" and an error message is written to stderr
#
# In the BEGIN rule we read the argument file into the array variables size1 and size2.
# For every line of the form "id1 arr<size>:id2" we set size1[<size>] = id2. 
# For every line of the form "id2 data:id3[n]" we set size2[id2] = n.
# All other lines are ignored.
# The variable firstbeg is set to 1 to test for the first line starting with "begin", it is 
# set to "" if such a line has been found.
# 
# The modifications are implemented by matching lines and possibly replacing them by one or more lines.
# All non-matching lines are passed through.
#
# Implementation in awk:
# - The filename argument for the comment file must be copied and removed from the argument list ARGV
#   to prevent its processing as normal input to awk. The argument file is explicitly read by getline.
# - Since in '...' the ' cannot be escaped, we avoid using it in match expressions and print it 
#   by reusing parts of the input.
# - Note that $7 in the printf statement already includes the closing double quotes.
