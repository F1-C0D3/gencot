theory Chapter_basic
  imports Chapter_intro
begin
chapter "Isabelle Basics"
text_raw\<open>\label{basic}\<close>

text \<open>
Isabelle is a ``proof assistant'' for formal mathematical proofs. It supports a notation for propositions and 
their proofs, it can check whether a proof is correct, and it can even help to find a proof.
\<close>

section "Invoking Isabelle"
text_raw\<open>\label{basic-invoke}\<close>

text \<open>
After installation, Isabelle can be invoked interactively as an editor for entering propositions and proofs,
or it can be invoked noninteractively to check a proof and generate a PDF document which displays the 
propositions and proofs.
\<close>

subsection "Installation and Configuration"
text_raw\<open>\label{basic-invoke-install}\<close>
text \<open>** todo **\<close>

subsection "Theories and Sessions"
text_raw\<open>\label{basic-invoke-theory}\<close>
text \<open>
The propositions and proofs in Isabelle notation are usually collected in ``theory files'' with names of the 
form \<^verbatim>\<open>name.thy\<close>. A theory file must import at least one other theory file to build upon its content. For theories
based on higher order logic, as it is the case for the Cogent shallow embedding, the usual starting point to
import is the theory @{theory Main}.

Several theory files can be grouped in a ``session''. A session is usually stored in a directory in the file system.
It consists of a file named \<^verbatim>\<open>ROOT\<close> which contains a specification of the session, and the theory files which
belong to the session.

When Isabelle loads a session it loads and checks all its theory files. Then it can generate a ``heap file'' for
the session which contains the processed session content. The heap file can be reloaded by Isabelle to avoid 
the time and effort for processing and checking the theory files.

A session always has a single parent session, with the exception of the Isabelle builtin session @{session Pure}.
Thus, every session depends on a linear sequence of ancestor sessions which begins at @{session Pure}. The ancestor 
sessions have separate heap files. A session is always loaded together with all ancestor sessions. 

Every session has a name of the form \<^verbatim>\<open>chap/sess\<close> where \<^verbatim>\<open>chap\<close> is an arbitrary ``chapter name'', it defaults to
\<^verbatim>\<open>Unsorted\<close>. The session name and the name of the parent session are specified in the \<^verbatim>\<open>ROOT\<close> file in the session
directory. When a session is loaded by Isabelle, its directory and the directories of all ancestor sessions must
be known by Isabelle.

Every session may be displayed in a ``session document''. This is a PDF document generated by translating the 
content of the session theory files to \LaTeX. A frame \LaTeX document must be provided which includes all content
generated from the theory files. The path of the frame document, whether a session document shall be generated and 
which theories shall be included is specified in the \<^verbatim>\<open>ROOT\<close> file.

The command
\begin{verbatim}
  isabelle mkroot [OPTIONS] [Directory]
\end{verbatim}
can be used to initialize the given directory (default is the current directory) as session directory. It creates
an initial \<^verbatim>\<open>ROOT\<close> file to be populated with theory files names and other specification for the session, and it
creates a simple frame \LaTeX document.
\<close>

subsection "Invocation as Editor"
text_raw\<open>\label{basic-invoke-edit}\<close>
text \<open>
Isabelle is invoked for editing using the command
\begin{verbatim}
  isabelle jedit [OPTIONS] [Files ...]
\end{verbatim}
It starts an interactive editor and opens the specified theory files. If no file is specified it opens the 
file \<^verbatim>\<open>Scratch.thy\<close> in the user's home directory. If that file does not exist, it is created as an empty file.

The editor also loads (but does not open) all transitively imported theory files. If these are Isabelle standard
theories it finds them automatically. If they belong to the session in the current directory it also finds them.
If they belong to other sessions, the option
\begin{verbatim}
  -d <directory pathname>
\end{verbatim}
must be used to make the session directory known to Isabelle. For every used session a separate option must be
specified. Also the directories of all ancestor sessions of the session the opened files belong to must be
specified using this option if they are not yet known to Isabelle. 

The option
\begin{verbatim}
  -l <session name>
\end{verbatim}
can be used to specify a session to load (together with all ancestor sessions) to use imported theories from it.
If a heap file exists for that session it is used, otherwise a heap file is created by loading all the session's 
theories.
\<close>

subsection "Invocation for Batch Processing"
text_raw\<open>\label{basic-invoke-build}\<close>
text \<open>
Isabelle is invoked for batch processing of all theory files in one or more sessions using the command
\begin{verbatim}
  isabelle build [OPTIONS] [Sessions ...]
\end{verbatim}
It loads all theory files of the specified sessions and checks the contained proofs. It also loads all required
ancestor sessions. If not know to Isabelle, the corresponding session directories must be specified using option
\<^verbatim>\<open>-d\<close> as described in Section~\ref{basic-invoke-edit}. Sessions required for other sessions are loaded from
heap files if existent, otherwise the corresponding theories are loaded and a heap file is created. 

If option \<^verbatim>\<open>-b\<close> is specified, heap files are also created for all sessions specified in the command. Option
\<^verbatim>\<open>-c\<close> clears the specified sessions (removes their heap files) before processing them. Option \<^verbatim>\<open>-n\<close> omits 
the actual session processing, together with option \<^verbatim>\<open>-c\<close> it can be used to simply clear the heap files.

The specified sessions are only processed if at least one of their theory file has changed since the last 
processing or if the session is cleared using option \<^verbatim>\<open>-c\<close>. If option \<^verbatim>\<open>-v\<close> is specified all loaded sessions
and all processed theories are listed on standard output.

If specified for a session in its \<^verbatim>\<open>ROOT\<close> file (see Section~\ref{basic-invoke-doc}), also the session document 
is generated when a session is processed.
\<close>

section "Isabelle Theories"
text_raw\<open>\label{basic-theory}\<close>

subsection "Theory Structure"
text_raw\<open>\label{basic-theory-structure}\<close>

text \<open>
\<^item> Theory name
\<^item> Imports
\<^item> Outer/Inner syntax
\<^item> Sections and text
\<close>

subsection "Types and Constants"
text_raw\<open>\label{basic-theory-typcnst}\<close>

text \<open>
\<^item> Strongly typed
\<^item> Type names
\<^item> type synonyms and declarations
\<^item> Constant names
\<^item> Constant declarations
\<close>

subsection "Definitions"
text_raw\<open>\label{basic-theory-definition}\<close>

text \<open>
\<^item> definitions
\<^item> abbreviations
\<close>

subsection "Overloading"
text_raw\<open>\label{basic-theory-overload}\<close>

text \<open>
\<^item> overloading
\<^item> adhoc overloading
\<close>

subsection "Statements"
text_raw\<open>\label{basic-theory-statement}\<close>

text \<open>
\<^item> theorem, lemma, ...
\<^item> statement names
\<^item> named statement collections (lemmas, buckets)
\<close>

subsection "Locales"
text_raw\<open>\label{basic-theory-locale}\<close>

text \<open>
\<^item> locale as parameterized theory
\<^item> locale parameters
\<^item> locale content
\<^item> locale interpretation
\<close>

section "Isabelle Proofs"
text_raw\<open>\label{basic-proof}\<close>

subsection "Goals"
text_raw\<open>\label{basic-proof-goal}\<close>

text \<open>
\<^item> prop syntax
\<^item> assumptions
\<^item> conclusion
\<^item> view as rewrite rule
\<^item> subgoals (proof state)
\<close>

subsection "Proof Scripts"
text_raw\<open>\label{basic-proof-script}\<close>

text \<open>
\<^item> method syntax
\<^item> apply
\<^item> apply scripts
\<^item> done, by
\<^item> sorry
\<close>

subsection "Backward Reasoning"
text_raw\<open>\label{basic-proof-backward}\<close>

text \<open>
\<^item> Reasoning step
\<^item> conclusion unification
\<^item> rule with one assumption
\<^item> rule with several assumptions
\<^item> rule method
\<^item> rule\_tac method
\<^item> introduction rules
\<^item> intro method
\<close>

subsection "Forward Reasoning"
text_raw\<open>\label{basic-proof-forward}\<close>

text \<open>
\<^item> assumption unification
\<^item> assumption selection
\<^item> rotate method
\<^item> drule method
\<^item> drule\_tac method
\<^item> destruction rules
\<^item> erule method
\<^item> erule\_tac method
\<^item> elimination rules
\<close>

section "Isabelle HOL"
text_raw\<open>\label{basic-hol}\<close>

subsection "Meta Level Operators"
text_raw\<open>\label{basic-hol-meta}\<close>

text \<open>
\<^item> rewrite rules
\<^item> \<open>\<equiv>\<close>
\<^item> \<open>\<Longrightarrow>\<close>
\<close>

subsection "Logical Operators"
text_raw\<open>\label{basic-hol-logop}\<close>

text \<open>
\<^item> \<open>\<and>, \<or>, \<not>, \<longrightarrow>\<close>
\<^item> \<open>=, \<noteq>, \<longleftrightarrow>\<close>
\<^item> \<open>\<forall>, \<exists>\<close>
\<close>

subsection "Logic Rules"
text_raw\<open>\label{basic-hol-logrul}\<close>

text \<open>
\<^item> conjI, conjE, disjI1, disjI2, disjE, impI, mp
\<^item> contrapos\_*
\<^item> iffI, iffE, iffD1, iffD2
\<^item> allI, allE, exI, exE
\<close>

subsection "Equational Reasoning"
text_raw\<open>\label{basic-hol-equational}\<close>

text \<open>
\<^item> Equations, conditional equations
\<^item> Substitution
\<^item> subst method
\<^item> symmetric attribut
\<close>

subsection "The Simplifier"
text_raw\<open>\label{basic-hol-simp}\<close>

text \<open>
\<^item> simpset, simp attribute
\<^item> simp method
\<^item> add:, only:, del:
\<^item> simp\_all method
\<^item> recursive simplification for conditions
\<^item> simp trace
\<^item> debugging with subst
\<close>

end
