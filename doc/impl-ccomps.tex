As described in Section~\ref{design-modular} there are several different Gencot components which process C code and generate 
target code.

\subsection{Filters for C Code Processing}
\label{impl-ccomps-filters}

All filters which parse and process C code are implemented in Haskell and read the
C code as described in Section~\ref{impl-ccode-read}.

The following filters always process the content of a single C source file and produce the content for a single 
target file.
\begin{description}
\item[\code{gencot-translate}] translates a single file \code{x.c} or \code{x.h} to the Cogent code to be put in file
\code{x.cogent} or \code{x-incl.cogent}. It processes typedefs, struct/union/enum definitions, and function
definitions. 
\item[\code{gencot-entries}] translates a single file \code{x.c} to the antiquoted C entry wrappers to be put in
file \code{x-entry.ac}. It processes all function definitions with external linkage.
\item[\code{gencot-remfundef}] processes a single file \code{x.c} by removing all function definitions. The output
is intended to be put in file \code{x-globals.c}
\item[\code{gencot-deccomments}] processes a single file \code{x.c} or \code{x.h} to generate the list of
all declaration positions.
\item[\code{parmod-gen}] processes a single file \code{x.c} and generates the 
function parameter modification descriptions (see Section~\ref{impl-parmod}).
\end{description}

All these filters take the name of the original source file as additional first
argument, since they need it to generate Cogent names for C names with internal linkage and for tagless C struct/union
types.

There are other target files which are generated for the whole Cogent compilation unit. The filters for generating these target files 
take as input the list of file names to be processed (see Section~\ref{impl-ccode-package}). Filters of this kind 
are called ``processors'' in the following.

Usually only \code{.c} files need to be specified as input to processors.
In contrast to the single-file filters, the original file name is not required for the files input to a 
Gencot processor. A processor only processes items which are external to all input files, whereas the original
file name is needed for items which are defined in the input files. Therefore the list of input file names is
sufficient and the input files may have arbitrary names which need not be related to the names of the original 
\code{.c} files.

Gencot uses the following processors of this kind:
\begin{description}
\item[\code{gencot-exttypes}] generates the content to be put in the file \code{<package>-exttypes.cogent}. It 
processes externally referenced typedefs, tag definitions and enum constant definitions.
\item[\code{gencot-dvdtypes}] generates the content to be put in the file \code{<package>-dvdtypes.cogent}. It 
processes all used derived array types.
\item[\code{gencot-dvdtypesah}] generates the content to be put in the file \code{<package>-dvdtypes.ah}. It 
processes all used derived array types.
\item[\code{gencot-externs}] generates the abstract function definitions of the exit wrappers to be put in the file 
\code{<package>-externs.cogent}. It processes the declarations of externally referenced functions and variables.
\item[\code{gencot-externsac}] generates the exit wrappers to be put in the file \code{<package>-externs.ac}. It processes
the declarations of externally referenced functions.
\item[\code{parmod-externs}] generates the list of function identifiers of all externally referenced functions and
function pointer (array)s.
\end{description}

\subsection{Main Translation to Cogent}
\label{impl-ccomps-main}

The main translation from C to Cogent is implemented by the filter \code{gencot-translate}. It translates \code{DeclEvent}s
of the following kinds:
\begin{itemize}
\item struct/union definitions
\item enum definitions with a tag
\item enum constant definitions
\item function definitions
\item object definitions
\item type definitions
\end{itemize}
The remaining global items are removed by the predicate passed to \code{Gencot.Input.getDeclEvents}: all declarations, 
and all tagless enum definitions. No Cogent type name is generated for a tagless enum definition,
references to it are always directly replaced by type \code{U32}.

The translation does not use the callback handler to collect information during analysis. It only uses the semantics map
created by the analysis and processes the \code{DeclEvent} sequence created by preprocessing as described in 
Section~\ref{impl-ccode-read}.

The translation of the \code{DeclEvent} sequence is implemented by the function
\begin{verbatim}
  transGlobals :: [DeclEvent] -> FTrav [GenToplv]
\end{verbatim}
in module \code{Gencot.Cogent.Translate}.
It performs the monadic traversal as described in Section~\ref{impl-ccode-trav} and returns the list of toplevel
Cogent definitions of type \code{GenToplv}.

A struct/union/enum definition corresponds to a full specifier, as described in Section~\ref{design-decls-tags}.
The language-c analyser already implements moving all full specifiers to separate global definitions and the
sorting step done by \code{Gencot.Input.getDeclEvents} creates the desired ordering. Therefore, only the translation
of the single struct/union/enum definitions has to be implemented by \code{gencot-translate}.

A struct/union definition is translated to a Cogent type definition where the type name is constructed as described 
in Section~\ref{design-names}. A struct is translated to a corresponding record type, a union is translated to an 
abstract type, as described in Section~\ref{design-types}.
In both cases the type name names the boxed type, i.e., it corresponds to the C type of a pointer to the struct/union.

An enum definition with a tag is translated to a Cogent type definition where the type name is constructed as described 
in Section~\ref{design-names}. The name is always defined for type \code{U32}, as described in Section~\ref{design-types}.

An enum constant definition is translated to a Cogent constant definition where the name is constructed as described 
in Section~\ref{design-names} and the type is always \code{U32}, as described in Section~\ref{design-types}.

A function definition is translated to a Cogent function definition, as described in Section~\ref{design-fundefs}.

A type definition is translated to a Cogent type definition as described in Section~\ref{design-decls-typedefs}.

All these single translations are implemented by the function
\begin{verbatim}
  transGlobal :: DeclEvent -> FTrav GenToplv
\end{verbatim}

A type reference is translated by the function
\begin{verbatim}
  transType :: Type -> FTrav GenType
\end{verbatim}

A type reference may be a direct type, a derived type, or a typedef name. For every typedef name a Cogent type
name is defined, as described in Sections~\ref{design-names} and~\ref{design-modular}. A direct type is either
the type \code{void}, a primitive C type, which is mapped to the name of a primitive Cogent type, or it is a 
struct/union/enum type reference for which Gencot also introduces a Cogent type name or maps it to the 
primitive Cogent type \code{U32} (tagless enums). Hence, both direct types and typedef names can always be mapped
to Cogent type names, with the exception of type \code{void}, which is mapped to the Cogent unit type \code{()}.

-------- todo: rest of subsection must be revised ---------
If a typedef name references (directly or indirectly) a struct or union type, the corresponding Cogent
type name references the boxed type. Therefore, it must be modified by applying the unbox operator. If a typedef
name references a primitive type, this is not necessary, since the corresponding Cogent type is always regular.
However, the abstract Cogent surface syntax always associates a ``sigil'' with a type name. Unnecessary
unbox operators are automatically suppressed by the Cogent prettyprint function. Therefore Gencot always 
associates an unbox sigil with the Cogent type name if it corresponds to a direct type or a typedef name
referencing a direct type.

A derived type is either a pointer type, an array type, or a function type. It is derived from a base type
which in case of a function type is the type of the function result. The base type may again be a derived
type, ultimately it is a direct type or a typedef name.

For a pointer type the translation depends on the base type. If it is a struct or union type or a typedef
name referencing a struct or union type, the pointer type is translated to the Cogent type name corresponding
to the base type. If it is a function type or a typedef name referencing a function type, the pointer type 
is translated to the translation of the base type. In all other cases, as described in Section~\ref{design-types}, 
the pointer type is translated to the name of an abstract type, which is introduced as described in 
Section~\ref{design-names}, using a name for the base type. 

For an array type, the translation also depends on the base type. If it is type \code{char}, the array 
type is translated to the primitive Cogent type \code{String}. In all other cases it is translated 
to the name of an abstract type, which is introduced as described in Section~\ref{design-names}, 
using a name for the base type. This is even done if the base type is a typedef name which references
type char, since Gencot assumes that in this case it is intended as a ``real'' array type and not
as a string type.

If an array type occurs as type of a function parameter, it is ``adjusted'' by C to a pointer type with
the same base type. This is also done by Gencot. 

A function type is always translated to the corresponding Cogent function type, where a tuple type is
used as parameter type if there is more than one parameter, and the unit type is used if there is
no parameter. 

If a pointer type or array type is translated to the name of an abstract type, a name is required for
the base type. If the base type is a direct type or a typedef name, a Cogent type name always exists 
and is used. The only exception is type \code{void}, here the name \code{Void} is used.
If the base type is a derived type, a name is constructed for it as described in Section~\ref{design-names},
even if the base type would normally be mapped to a type expression (which is the case for a function type)
or to its own base type (which is the case for pointer types to struct/union and function types). If the
base type is array of char, the name \code{String} is used for it. 

Note that for most cases where a typedef name occurs as reference or base type, it must be resolved to
the ultimate direct type or derived type referenced by it. This is implemented by the function
\begin{verbatim}
  resolveTypeDef :: TypeDefRef -> Type 
\end{verbatim}
The \code{GlobalDecls} map is not required here, since the language-c analyser puts the (directly) 
referenced type in the \code{TypeDefRef}. 

For a qualified C type Gencot only respects the \code{const} qualifier. For a direct type the \code{const}
qualifier is ignored, since in Cogent values of unboxed and regular types are always immutable. For
a function type the qualifier is also ignored since function types are regular in Cogent. For an array
of char it is ignored since it is translated to type \code{String} which is regular.

All other array types and all pointer types are translated to linear types which can be mutable in
Cogent. Whenever the C type contains no mutable pointer types, it is translated to a readonly Cogent type by 
applying a bang operator to it.

An array type contains mutable pointers if its base type does so. A function type never contains mutable pointers.
A pointer type contains mutable pointers if its base type is not \code{const} qualified or contains mutable pointers.
A primitive type and an enum type does not contain mutable pointers. A struct or union type contains mutable 
pointers, if the type of a member contains mutable pointers.

\subsection{External Functions and Variables}
\label{impl-ccomps-externs}

For the exit wrapper functions Gencot generates the Cogent abstract function definitions and the implementations
in antiquoted C. Exit wrappers are generated for all functions which are invoked but not defined in the Cogent code. 
The information required for each of these functions is contained in the C function declaration.

Additionally, Gencot generates Cogent abstract function definitions for access functions to selected external
variables without providing an implementation in antiquoted C.

\subsubsection{Determining External Functions}

The easiest approach would be to generate an exit wrapper for every function which is declared but 
not defined in the C program. However, often an
included C source file contains many function declaration where only some of them are invoked. Therefore, Gencot
determines the declarations of all actually invoked external functions with the help of the call graph as described in 
Section~\ref{impl-ccode-callgraph}. Only for them declarations are translated.

Note that external functions which are not invoked directly, but converted to a function pointer and invoked 
through a function pointer object are not included by this approach, they must be handled manually.

The external invoked functions are further filtered as follows:
\begin{itemize}
\item If the type is a function pointer, invocations are translated to Cogent in a different way as 
described in Section~\ref{design-types-function}. Therefore we omit all function pointer invocations.
\item A function which is only declared may be incomplete, i.e., its parameters (number and types) are not known. 
We could translate such function declarations to Cogent abstract functions with Unit as argument type, however,
that would not be related to the invocations and thus be useless. Therefore we omit invocations
of incompletely declared functions.
\end{itemize}

An identifier seen by Gencot in a function invocation may also be a macro call which shall be translated by Gencot. 
In this case a dummy function declaration must be manually provided for it as part of the Gencot macro call conversion
(see Section~\ref{design-preprocessor-macros}), so that the language-c parser can parse the invocations. By 
using either an incomplete declaration or a complete declaration it can be controlled whether a Cogent abstract 
function definition is generated for it. If the macro is translated to a macro in Cogent, no abstract function
definition shall be generated and an incomplete dummy declaration must be used.

There are cases where an external function is used without being seen by the call graph. This is the case when
the function is assigned to a function pointer or when the function invocation is created by a macro call and
is thus not visible for the call graph. For these cases Gencot supports a list where additional functions
to be processed can be specified in an auxiliary input file by their names, each in a seperate line. Only
functions with external linkage can be specified, for them the name is unique in the <package>.

\subsubsection{Determining External Variables}

As for functions, Gencot also restricts the processed external variables to a subset of the declared variables.
It would be possible to determine the accessed variables in a similar way as the functions are determined with
the help of the call graph. Gencot does this for all variables of function pointer (array) type, using the 
call graph. Variables accessed in other ways or of other types may be specified explicitly as a list. This
provides more control about the processed external variables for the developer.

The external variables are specified in the same list as the additional external functions.

\subsubsection{Processor \code{gencot-externs}}

The processor \code{gencot-externs} generates the Cogent abstract function definitions. It is invoked as
\begin{verbatim}
  gencot-externs [<parmod file> [<varlist file>]]
\end{verbatim}
where the optional arguments are a file with parameter modification descriptions and with the names of external
variables to be processed.

The processor parses and analyses
all C source files specified in the input file name list, resulting in the list of corresponding symbol tables, as
described in Section~\ref{impl-ccode-package}. Then
it determines for every table the invoked functions and function pointer (array)s as described in 
Section~\ref{impl-ccode-callgraph}. This must
be done before combining the tables, since invocations may also occur in the bodies of functions with internal
linkage. These functions are removed during table combination.

After determining the invoked functions, the tables are combined as described in Section~\ref{impl-ccode-package}
and the invocations are reduced to those for
which a declarations is present in the combined table. These are the invocations of functions and function
pointer (array) variables external to all
read C sources. The processor translates their declarations using the function \code{transGlobals} of
module \code{Gencot.Cogent.Translate}. It translates C function and variable declarations to abstract function 
definitions
in Cogent. It reads and uses parameter modification descriptions to determine readonly parameter types, the
descriptions are generated by \code{parmod-externs} as described in Section~\ref{impl-ccomps-parmod}.
The result is output using \code{prettyTopLevels} from module \code{Gencot.Cogent.Output}.

The processor takes two files as optional arguments. The first file contains parameter modification descriptions
and is used for translating the types of functions and function pointers. If it is not specified all linear
parameters are assumed to be modifyable by the function. The second file contains a list of newline-separated 
names of external variables to be processed in addition to the invoked function pointer (array)s. This file can
only be specified if the parameter modification description file is also specified. If no parameter modifications
shall be used, a file containing the empty list \code{[]} can be used instead.

\subsubsection{Processor \code{gencot-externsac}}

The processor \code{gencot-externsac} generates the wrapper implementations in antiquoted C code.

\subsection{External Cogent Types}
\label{impl-ccomps-exttypes}

The processor \code{gencot-exttypes} generates all Cogent type definitions which origin from a C system include file.
It is invoked as
\begin{verbatim}
  gencot-exttypes [<parmod file> [<varlist file>]]
\end{verbatim}
where the optional arguments are a file with parameter modification descriptions and with the names of external
variables to be processed.

Since often only a small selection of the types defined by a system include file is used by a program, Gencot performs 
an analysis to reduce the type definitions to be translated. It determines all types actually \textit{used} by
referencing them somewhere in the program.

C Types are used in a C source in the following cases:
\begin{itemize}
\item As type of a global or local variable.
\item As result or parameter type of a derived function type.
\item As base type of a derived pointer or array type.
\item As type of a field in a composite type (struct or union).
\item As defining type for a typedef name.
\end{itemize}
There are other uses of types in C, such as in \code{sizeof} expressions, these cases are ignored by Gencot and 
must be handled manually.

We call the items which may have a separate syntactically
specified C type a ``type carrier''. These are variables, functions, fields, and typedef names. Since the language-c
parser constructs for every defined or declared function the derived function type, variables and functions
can be treated in the same way, they only differ in their type: functions have a derived function type, whereas
variables may have all other types, including types derived from function types such as function pointer types. Fields 
always belong to a composite type, therefore we use as type carrier the composite type instead of the single fields.
Together we have three kinds of type carriers: variable/functions, composite types, and typedef names.

Every type carrier has one or (in the case of a composite type) several associated ``syntactic types''
which are the type expressions as specified in the C source. If a syntactic type is a derived type it contains
``syntactic part types'' (base types, parameter and result types). 

We also include enum types as type carriers. They have no associated types, since they always correspond to a name 
for a primitve (numeric) type. However, \code{gencot-exttypes} must determine and translate enum types which 
are defined in system include files similar to a composite type.

Generally, Gencot translates type carriers to Cogent. It translates functions as described in Section~\ref{design-fundefs}
and it translates enum types, composite types and type definitions as described in Section~\ref{design-types}.
Gencot translates global variables to an abstract access function, using the translated type of the variable.
Gencot does not translate local variables, this must be done manually. To support the manual translation, 
however, Gencot treats local variables as if it would translate them to Cogent code referencing the translated 
declared type.

The task of \code{gencot-exttypes} is to translate all type carriers referenced in the translated code for which
no definition has been generated by translating the C sources of the Cogent translation unit, i.e., which have
been defined in a system include file.

When Gencot translates a type carrier, it references at most the associated syntactic types in the resulting Cogent code.
This is the case for struct types and for functions. Union types are translated without referencing the field types
(see Section~\ref{design-types-struct}). To support a manual translation \code{gencot-exttypes} treats them in 
the same way as struct types.

Gencot translates derived types to a parameterized Cogent type with the base type as type argument. Hence the syntactic 
part types are always required as type arguments. Therefore \code{gencot-exttypes} also handles all syntactic
part types associated with a type carrier.

For functions, the associated syntactic type is either a typedef name (resolving to a derived function type) 
or a syntactic derived function type. In the latter case no Cogent type definition is needed for it, since Gencot
directly translates it to a Cogent type expression (Section~\ref{design-fundefs}). 

\subsubsection{Collecting Used Types}

A type can be used by code in a translated C soure file or by a declaration of an external function or variable.
As described in Section~\ref{impl-ccomps-externs}, Gencot only translates external functions and variables if they are 
actually invoked or explicitly listed by the developer.
Therefore, \code{gencot-exttypes} determines the external invoked functions and variables in the same way. Note that
the external invoked functions include those defined in the <package> outside the Cogent compilation unit, as well
as those declared in a system include file.

Enum types, composite types and typedef names are reduced by an analysis of type usage by reference. Every type carrier can be
associated with the enum types, composite types and typedef names referenced in all associated syntactic part types. For 
composite types and typedef names this usage relation is transitive. To determine the relevant enum types, composite types 
and typedef names defined in system include files, \code{gencot-exttypes} starts with all initial type carriers belonging
to the Cogent compilation unit, together with all external invoked functions and the processed external variables. 
It then determines all transitively
used enum types, composite types and typedef names (which all must be defined in system include files).

To further reduce type carriers, the types associated with external type carriers are ``fully resolved'', i.e.~all
typedef names occurring in them are transitively resolved and replaced by their definition. The exception are
typedef names which are referenced by the initial type carriers, they are preserved since they are needed anyways.

For the resulting set of type carriers the required type definitions are generated.

The initial type carriers are collected with the help of the callback handler during analysis, as described in 
Section~\ref{impl-ccode-read}. All type carriers can be wrapped as a \code{DeclEvent}. The callback handler 
is automatically invoked for all type carriers in the parsed
C source files, including local variables (which are not present anymore in the symbol table after the analysis phase).

Gencot uses the callback handler
\begin{verbatim}
  collectTypeCarriers :: DeclEvent -> Trav [DeclEvent] ()
\end{verbatim}
in module \code{Gencot.Util.Types}. It adds all \code{DeclEvent}s with relevant type carriers to the list in the 
user state of the \code{Trav} monad. The handler is used for every \code{.c} file separately, the collected
type carriers must be combined afterwards to get all type carriers in the Cogent compilation unit. This can be
done by first combining the symbol tables as described in Section~\ref{impl-ccode-package}, and then using the union of all 
type carriers which are local, have internal linkage, or are still contained in the resulting combined table. 
This will avoid duplicate occurrences of type carriers.

All parameter declarations are ignored by the callback handler, since for every parameter declaration there must be 
a \code{DeclEvent} for the containing function, which is processed by the handler. Function and global variable declarations 
are also ignored, since they represent external functions and variables which are separately determined. Also,
a function or variable declared in one source file may be defined in another source file of the Cogent compilation unit and thus 
be not external. Type carriers where all associated types are primitive (including enum types) are also ignored, 
since they may neither contain derived types nor reference other type carriers.

Enum types, composite types and typedef names declared in system include files are omitted, since they will be determined 
using the type usage relation. To determine whether
a type carrier is defined in a system include file, the simple heuristics is used that the source file name is specified
as an absolute pathname in the \code{nodeinfo}. System includes are typically accessed using absolute pathnames of the 
form \code{/usr/include/...} (after being searched by cpp). If include paths are specified explicitly for Gencot, 
system include paths must be 
specified as absolute paths whereas include paths belonging to the <package> must be specified as relative paths
to make the heuristics work.

After the language-c analysis phase the declarations of all invoked external functions are determined 
as described in Section~\ref{impl-ccomps-externs}. If the associated syntactic type is a typedef name, it is resolved
to a derived function type. Afterwards, all invoked external functions where not all associated syntactic types
are primitive are added to the combined type carriers determined by the callback handler. No duplicate type carriers
will result here since the combined symbol table contains every external declaration only once.

The resulting set of type carriers is transitively completed by adding all type carriers used by referencing them,
as described above. This will add all required enum types, composite types and typedef names defined in system include files.
Here, type carriers where all associated types are primitive are not omitted, since 
\code{gencot-exttypes} must translate all added type carriers. The same holds for enum types. 
Duplicates could occur if a type carrier is referenced
in several different types, they must be detected and avoided. Since all type carriers correspond to 
syntactic entities in a source file, they can be identified and compared by their position and source file.

\subsubsection{Translating Type Definitions}

For all external enum types, composite types and typedef names in the resulting set \code{gencot-exttypes} translates the
definition to Cogent as described in Sections~\ref{design-types}.
All types used in these definitions are fully resolved, as described above.

To support the full resolving of types, the normal monadic action \code{transGlobals} used by the main translation 
to Cogent described in Section~\ref{impl-ccomps-main} cannot be used. The resolving needs access to all
type names directly referenced from the Cogent compilation unit to stop the resolving there.
The translation of external types is implemented by the monadic action 
\begin{verbatim}
  transExtGlobals :: [String] -> [DeclEvent] -> FTrav [GenToplv]
\end{verbatim}
in module \code{Gencot.Cogent.Translate} where the string list contains the referenced type names.

\subsection{Derived Types}
\label{impl-ccomps-dvdtypes}

The processor \code{gencot-dvdtypes} generates all Cogent type definitions required for the derived types
used in the C program. It is invoked as
\begin{verbatim}
  gencot-dvdtypes [<varlist file>]
\end{verbatim}
where the optional argument is a file with the names of external variables to be processed.

A C derived type, is a pointer type, array type or function type. As described in 
Section~\ref{design-types}, Gencot maps all these types to parameterized Gencot types. The generic types \code{CPtr},
\code{CFunPtr} and \code{CFunInc} used for pointer and function types are predefined by Gencot. However, the generic 
types of the form \code{CArr<size>} used for array types syntactically contain the array size, they 
depend on the translated C program. For these generic types Cogent definitions must be provided.

Derived types are used in C in the form of type expressions, i.e., base types, result and parameter types are 
syntactically included in the type specification. With some exceptions, derived types may occur wherever a type
may be used. Therefore, to determine all used derived types, Gencot determines all used type carriers as
described for \code{gencot-exttypes} in Section~\ref{impl-ccomps-exttypes}. These include all type carriers used 
in translated C sources, in declarations of external functions and variables and those defined in system
include files.

For the same reason as for \code{gencot-exttypes} Gencot also processes the syntactic part types of derived types,
if they are again derived types.

Together, \code{gencot-dvdtypes} processes
\textit{all} type carriers for all associated syntactic part types which are a derived array type.

\subsubsection{Generating Type Definitions}

For all derived array types associated as syntactic part type with a type carrier in the used set, two abstract 
generic type definitions must be generated: one for the array type, and one for the corresponding empty-value type 
(see Section~\ref{design-types-array}). However, only one such pair may be generated for every array \code{<size>}, 
although array types with a specific size may be associated with several different type carriers.

Gencot first generates the translated Cogent type names for all derived array types associated 
as syntactic part type with a type carrier. Then it generates a pair of abstract definitions for every generic type name
used in all these array types. If the translated array type uses the generic name \code{CArrXX} no definition
is generated since this type name is predefined by Gencot.

Generating the type definitions for derived array types is implemented by the monadic action
\begin{verbatim}
  genTypeDefs :: [DeclEvent] -> FTrav [GenToplv]
\end{verbatim}
in module \code{Gencot.Cogent.Translate}, where the list of \code{DeclEvent}s corresponds to the type carriers
to be processed.

\subsubsection{Processor \code{gencot-dvdtypesah}}

\subsection{Declarations}
\label{impl-ccomps-decls}

The filter \code{gencot-deccomments} is used to provide the information about the positions of all declarations with
external linkage in
a translated file, as described in Section~\ref{impl-comments-decl}. This information is used to move declaration
comments to the corresponding definitions, as described in Section~\ref{design-comments-decl}.

Only global declarations are processed by this filter. Therefore the filter processes the list of \code{DeclEvents}
returned by \code{getDeclEvents} (see Section~\ref{impl-ccode-read}). The predicate for filtering the list
selects all declarations with external linkage (i.e. removes all object/function/enumeration/type definitions and 
all declarations with internal or no linkage). 
The main application case are functions declared as external, but moving the comments may also be useful for 
objects.

If a function or object with external linkage is declared and defined in the same file, the language-c analysis step
replaces the declaration by the corresponding definitions in the semantic map, hence it will not be found and processed
by \code{gencot-deccomments}. However, it is assumed that in this case the documentation is assocatied with the definition
and need not be moved from the declaration to the definition.

For processing the declarations we do not need a monad since every declaration can be processed on its own. This is implemented
by the function
\begin{verbatim}
  transDecl :: DeclEvent -> String
\end{verbatim}
in module \code{Gencot.Text.Decls}. It is mapped over the list of \code{DeclEvents} and the resulting string list
is output one string per line.

\subsection{Parameter Modification}
\label{impl-ccomps-parmod}

\subsubsection{\code{parmod-gen}}

The filter \code{parmod-gen} is used to generate the Json parameter modification description from a C source file.
It may be invoked in two forms:
\begin{verbatim}
  parmod-gen <source file name>
  parmod-gen <source file name> close
\end{verbatim}
The second form runs the filter in ``closing mode''.

In normal mode the filter processes all \code{DeclEvent}s in the source file which are function
definitions or definitions for objects with function pointer (array) type. Every such definition is translated to an
entry in the parameter modification description. A function definition is translated to the sequence of its
own description entry and the entries for all invoked local function pointer (array)s and all parameters for which
the type is a function or function pointer (array) directly including the derived function type.

The filter processes every definition of a composite type in the source file and translates all
its members with function pointer (array) type directly including the derived function type to the corresponding
description. The filter processes every type name definition in the source file where the definig type
is a function (pointer (array)) type directly including the derived function type, and translates it to
the corresponding description.

The descriptions of functions, their function parameters, composite type members, and typedef names are 
intended to be used by \code{gencot-translate}
when it translates the function and type definitions. The descriptions of invoked local function pointer (array)s
are intended for evaluating dependencies as described in Section~\ref{impl-parmod}.

In closing mode the filter processes all \code{DeclEvent}s in the source file and in all included files which
are declarations for functions or function pointer (array)s. Every declaration is translated to an entry in the parameter
modification description. These descriptions are only intended for ``closing'' the dependencies for the evaluation.

After analysing the C code as described in Section~\ref{impl-ccode} the call graph is generated as described
in Section~\ref{impl-ccode-callgraph}. Then another traversal is performed using the \code{CTrav} monad and
\code{runWithCallGraph} with action
\begin{verbatim}
  transGlobals :: [DeclEvent] -> CTrav Parmods
\end{verbatim}
defined in module \code{Gencot.Json.Translate}. The resulting list of JSON objects is output as described 
in Section~\ref{impl-parmod-json}.

\subsubsection{Processor \code{parmod-externs}}

The processor \code{parmod-externs} is used to generate the parameter modification descriptions intended
to be used by \code{gencot-externs} (see Section~\ref{impl-ccomps-externs}) and \code{gencot-exttypes} 
(see Section~\ref{impl-ccomps-exttypes}). It is invoked as
\begin{verbatim}
  parmod-externs [<varlist file>]
\end{verbatim}
where the optional argument is a list of names of external variables to be processed.

Since all these parameter modification descriptions are already
generated by \code{parmod-gen}, the processor only generates a list of function identifiers, as described in 
Section~\ref{impl-parmod-ids}. Every identifier is output in a separate line. The identifiers can be used
to specifically select and manually process only those descriptions which are actually required by
\code{gencot-externs} and \code{gencot-exttypes}. 

However, only identifiers for those descriptions are listed,
which are not yet needed by \code{gencot-translate} to translate the source files of the Cogent compilation unit.
The idea is to merge these with the descriptions selected by the listed identifiers to determine the 
descriptions needed by \code{gencot-externs} and \code{gencot-exttypes}.

The processor \code{gencot-externs} processes declarations of external invoked functions. It needs parameter
modification descriptions for these functions and for their parameters of function (pointer (array)) type.
The descriptions for the parameters are needed by \code{gencot-externs} to translate the parameter type as part of the 
generated abstract Cogent function definition. 

Although \code{gencot-externs} only processes complete function declarations of non-variadic external functions, 
\code{parmod-externs} also lists identifiers for incompletely declared functions and for variadic functions,
if they are invoked in the Cogent compilation unit. This is intended as an 
information for the developer who has to translate invocations of such functions manually. All these
external invoked functions are determined with the help of the call graph in the same way as described for 
\code{gencot-externs} in Section~\ref{impl-ccomps-externs}.

The processor \code{gencot-externs} also processes external variables, if they are invoked or listed explicitly
by the developer. Parameter modification descriptions are only relevant for variables of function pointer (array)
type. There may be such variables which are not invoked, but explicitly specified by the developer. For this
reason \code{parmod-externs} also reads the list of external variables to be processed in addition to the
invoked variables.

External invoked composite type members are not included, since they will be added through the used types below. To invoke 
a composite type member an object must exist which is a type carrier for the composite type. The parameter modification
description identifier for the member will be listed when this type carrier or a typedef referenced by it
is processed.

The processor \code{gencot-exttypes} processes derived types of all type carriers and translates enum types,
composite types and typedef names defined in system include files. It needs parameter modification descriptions
for both cases. 

Since parameter modification descriptions must be associated with a function identifier, they cannot be used
for arbitrary types. They are only used for composite type members with a function pointer (array) type and 
for typedef names where the defining type is a function (pointer (array)) type. In both cases the derived
function type must be syntactically included. If it is specified using a typedef name, the parameter modification
description is only used for translating the corresponding type definition.

Accordingly, \code{parmod-externs} lists for all processed type carriers the function ids of all composite type
members and of all typedef names which have a type of this kind. These descriptions cover all cases needed
by \code{gencot-exttypes}.

The type carriers to be processed are determined in the same way as by \code{gencot-exttypes}. Note that the 
external invoked functions and variables are already included there, however, those with only primitive types are omitted.
Here we also include them, since \code{gencot-externs} processes them. 
For external function pointer (array)s descriptions for parameters are not listed, since
for the parameter types of function pointers no parameter modification descriptions are used by Gencot, they
are always translated assuming as default that all nonlinear parameters are modified.

Descriptions for composite types and typedef names need only be processed if they are defined in a system include
file. In all other cases they are already needed by \code{gencot-translate} for translating the source files
of the Cogent compilation unit and are omitted here.

For the determined type carriers \code{parmod-externs} lists the identifiers of 
the parameter modification descriptions for the following entities:
\begin{itemize}
\item declarations of external invoked functions, together with all their parameters, if the parameter
type is a function (pointer (array)) type directly specifying the function type,
\item declarations of external invoked or listed function pointer (array)s, if the declared type directly specifies
the function type,
\item members of all composite types defined in system include files, if their type resolves to a function pointer (array) type.
\item typedef names defined in a system include file, if they resolve to a function (pointer (array)) type.
\end{itemize}

Note that typedef names and member types in system include files need not specify a function type directly for being listed, 
since types in external type carriers are fully resolved by \code{gencot-exttypes} and the resulting type is needed to translate 
the type definition.
