The goal of this step is to translate a single C source file which is part of the translation set to Cogent.
This is done by first using Gencot to translate the file to Cogent with embedded partially translated C code,
and then manually translating the embedded C code.

The translated file is either a \code{.c} file which can be seperately compiled by the C compiler as a compilation unit,
or it is a \code{.h} file which is a part of one or more compilation units by being included by other files. In both cases
the file can include \code{.h} files, both in the package and standard C include files such as \code{stdio.h}.

\subsection{Automatic Translation by Gencot}
\label{app-trans-auto}

To be translated by Gencot the C source file must first be prepared for being read by Gencot as described in
Section~\ref{app-prep}. Then the parameter modification descriptions for all functions and function types defined 
in the source file must be created and evaluated as described in Section~\ref{app-parmod-defined}. 

A \code{.c} file is translated using the command
\begin{verbatim}
  gencot [options] cfile file.c [<parmod>]
\end{verbatim}
where \code{file.c} is the file to be translated and \code{<parmod>} is the file containing the parameter modification 
descriptions. If it is not provided, Gencot assumes for all functions and function types, that linear parameters 
may be modified. The result of the translation is stored as \code{file.cogent} in the current directory.

An \code{.h} file is translated using the command
\begin{verbatim}
  gencot [options] hfile file.h [<parmod>]
\end{verbatim}
where \code{file.h} is the file to be translated and \code{<parmod>} is as above. The result of the translation is 
stored as \code{file-incl.cogent} in the current directory.

Special support is provided for translating configuration files. A configuration file is a \code{.h} file mainly
containing preprocessor directives for defining flags and macros, some of which are deactivated by being ``commented
out'', i.e., they are preceded by \code{//}. If such a file is translated using the command
\begin{verbatim}
  gencot [options] config file.h [<parmod>]
\end{verbatim}
it is translated like a normal \code{.h} file, but before, all \code{//} comment starts at line beginnings are 
removed, and afterwards the corresponding Cogent comment starts \code{--} are re-inserted before the definitions.

\subsection{Manual Translation of C Function Bodies}
\label{app-trans-manbody}

The manual part of the translation is mainly required for the bodies of all C functions defined in the C source file.
A \code{.h} file normally does not contain function or object definitions, then it may be the case that no manual actions 
are necessary. But some \code{.h} files define functions, typically as \code{static inline}, then also their bodies
must be translated manually.

The manual translation is done by modifying the \code{.cogent} file generated by the automatic translation in an 
editor. As described in Section~\ref{design-fundefs-body}, the result of automatically translating a function
definition has the form
The generated Cogent function definition has the form
\begin{verbatim}
  <name> :: (<ptype1>, ..., <ptypen>) -> <restype>
  <name> (<pname1>, ..., <pnamen>) = <dummy result>
  {- <compound statement> -}
\end{verbatim}
where the \code{<compound statement>} is plain C code with global names mapped to Cogent. The task of the manual
translation is to replace the \code{<dummy result>} by a Cogent expression equivalent to the \code{<compound statement>}.

In the following subsections we provide some patterns how to translate typical C constructs occurring in a
\code{<compound statement>}.

\subsubsection{Function Pointer Invocation}

In C a function pointer may be \code{NULL}, therefore it is typically tested for being valid before the
referenced function is invoked, such as in 
\begin{verbatim}
  if( fptr == NULL ) ...
  else fptr( params );
\end{verbatim}
We assume that fptr shall have a type which is binary compatible to the function pointer type in C.
This prevents to use a Cogent type \code{Option a} as the natural equivalent of a value that may be undefined.
\code{Option a} is a Cogent variant type and is not binary equivalent to the C function pointer type.

If \code{fptr} is a member of a C struct, it would be possible to use a Cogent recored with a taken field,
if the function pointer is undefined. Then it would be clear from the record type whether the function pointer
is valid and can be invoked. However, this would require two implementations for all functions with such a records 
as parameter, which is usually infeasible.

The simplest solution is to assume that function pointers are always defined. Instead of using the value 
\code{NULL}, they must then be set to point to a default function. Then no test is required, the function
can simply be invoked in Cogent.

Note that to be binary compatible the Cogent type of \code{fptr} is an abstract type of the form \code{\#F\_...}.
To invoke the referenced function the translation function \code{invk\_F\_...} must be used (see 
Section~\ref{design-types-function}). 

For example, if the function pointer is declared in C as 
\begin{verbatim}
  int (*fptr)(int p1, const char *p2);
\end{verbatim}
the corresponding invocation in Cogent would be
\begin{verbatim}
  invk_F_'U32'RP_U8'_U32 (fptr,arg1,arg2)
\end{verbatim}
with result type \code{U32}.

\subsubsection{The Address Operator \code{\&}}

The address operator \code{\&} is used in C to determine a pointer to data which is not yet accessed through a 
pointer. The main use cases are
\begin{itemize}
\item determine a pointer for a local or global variable as in the example
\begin{verbatim}
  int i = 5;
  int *ptr = &i;
\end{verbatim}

\item determine a pointer for a member in a struct as in the example
\begin{verbatim}
  struct ii { int i1; int i2; } s = {17,4};
  int *ptr = &(s.i2);
\end{verbatim}

determine a pointer to a function as in the example
\begin{verbatim}
  int f(int p) { return p+1; }
  ...
  int *ptr = &f;
\end{verbatim}
\end{itemize}

In all these cases the pointer is typically used as reference to pass it to other functions or store it
in a data structure.

The binary compatible Cogent equivalent of the pointer is a value of a linear type. However, there is
no Cogent functionality to create such values. Hence it must be implemented by an abstract function.

In the first use case there are several problems with this approach. First, there is no true equivalent
for C variables in Cogent. Second, it is not possible to pass the variable to the implementation of the
abstract function, without determining its address using the address operator. Third, if the address
operator is applied to the variable in the implementation of the abstract function, the Isabelle c-parser
will not be able to process the abstract function, since it only supports the address operator when 
the result is a heap address.

All these problems can be solved by allocating the variable on the heap instead. Then the variable definition
must be replaced by a call to the (abstract) creation function for the corresponding linear type and 
at the end of its scope a call to the (abstract) dircarding function must be added. Then the address
operator need not be translated, since the creation function already returns the linear value which can be 
used for the same purposes. The resulting Cogent code would be
\begin{verbatim}
  let ptr = create_P_U32 5
  in free_P_U32(...ptr...)
\end{verbatim}
where the argument of \code{free\_P\_U32} is an expression which uses and returns the \code{ptr} in the 
usual way for a value of linear type.

The second use case cannot be translated in this way, since the referenced data is a part of a larger structure.
If it is separated from the structure and allocated on the heap, the structure is not binary compatible any more.

If the overall structure is not allocated on the heap, the same three problems apply as in the first use case.
This can be solved in the same way, by moving the overall structure to the heap. Then it can be represented
by the linear Cogent type
\begin{verbatim}
  type Struct_Cogent_ii = { i1: U32, i2: U32 }
\end{verbatim}
Then it is possible to define and implement abstract functions
\begin{verbatim}
  take_i2 : Struct_Cogent_ii -> (P_U32, Struct_Cogent_ii take i2)
  put_i2 : (P_U32, Struct_Cogent_ii take i2) -> Struct_Cogent_ii
\end{verbatim}
The first one is implemented in C by applying the address operator to the member \code{i2} of its argument
and return it together with the argument. The second function is implemented by simply returning the second 
tuple member. 

Using a partial record type here is not necessary, but it makes the code safer, since the member \code{i2}
cannot be accessed as long as the type has not been changed to the full record type again, which should be 
done by \code{put\_i2}, discarding the pointer. However, it is possible to apply any other explicit \code{put}
operation which writes the member \code{i2} while the pointer still exists, causing the shared content to
be overwritten. To prevent this it must be proven for the Cogent program that no \code{put} operation for field 
\code{i2} is applied to the result of \code{take\_i2} until it is restored by \code{put\_i2}.

An alternative implementation of \code{take\_i2} would allocate a new copy of member \code{i2} on the heap
and return this heap pointer as first result component. The implementation of \code{put\_i2} would copy the 
value from the heap and free the heap entry. Then no sharing can occur and the program has the 
same type safety properties as a usual Cogent program. However, the copying makes it less efficient.

In both cases the Cogent code has the form
\begin{verbatim}
  let (ptr,s') = take_i2 s
  in put_i2 (...ptr...,s')
\end{verbatim}
where the first argument of \code{put\_i2} is an expression which uses and returns the \code{ptr} in the 
usual way for a value of linear type.

The third use case is translated in a specific way for function pointers, using the translation function
\code{to\_F\_...} (see Section~\ref{design-types-function}), which is generated by Gencot for all function
pointer types. The resulting Cogent code has the form
\begin{verbatim}
  Cogent_f : U32 -> _U32
  Cogent_f p = p+1
  ...
  let ptr = to_F_'U32'_U32 Cogent_f
  in ...
\end{verbatim}
In this case \code{ptr} has the nonlinear type \code{\#F\_'U32'\_U32} in Cogent and may freely be copied and
discarded in its scope.
