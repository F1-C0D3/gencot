For postprocessing the output generated by Cogent some information about how the Cogent compiler translates the 
Cogent types to C types is required. The main reason is that Cogent does not preserve the Cogent type names,
instead it generates type names of the form \code{t<nn>} in the C program.

Cogent translates record types, tuple types and variant types to C struct types. The Gencot array and pointer types are 
always mapped to a wrapper record in Cogent, so they are also translated to a C struct type. Function types 
are translated to enumeration types with an index number for each known function of that type. Basic types are
translated using specific type names in C (\code{u8, u16, u32, u64, unit\_t, bool\_t}). Type \code{String} is
always translated to \code{char *}. Abstract types are translated to C types of exactly the same name as in Cogent.

So the relevant information is that for all generated struct types and for the enumeration types generated for 
the function types. For struct types the information consists of the names and types of all members. For the latter
the information consists of the parameter and result types and of the set of known functions.

This information is available in the main \code{.h} file written by the Cogent compiler. Gencot parses this file 
and provides the information in a textual representation which can be read and processed when needed.

\subsection{Textual Representation of Type Information}
\label{impl-ctypinfo-repr}

The textual representation consists of a sequence of lines. 

For the generated struct types every line describes a single struct type using the following format:
\begin{verbatim}
  <name> <memnam>:<memtype> ... <memnam>:<memtype>
\end{verbatim}
where \code{<name>} is the struct type name of the form \code{t<nn>} and each \code{<memnam>} is the 
member id. For Cogent record types the member ids are equal to the record component names. For Cogent
variant types the member ids are equal to the alternative tags, with a member with id \code{"tag"}
and type \code{"tag\_t"}
prepended. For Cogent tuple types the member ids are \code{p1, p2, ...}. For a Gencot array type
the id of the single member is \code{arr<size>} (see Section~\ref{design-types-array}). For a Gencot 
pointer type the id of the single member is \code{cont} (which cannot be distinguished from a record 
with a single component of that name).

The \code{<memtype>} specifies the member's type and may have three different forms. It may be a single 
identifier referencing a struct type (for tuples, unboxed records and variants), an enumeration 
(for function types), or a basic type. It may be an identifier followed by a single \code{"*"} 
(for boxed records and variants). Since in Cogent the case of pointer-to-pointer cannot be expressed
a single star is always sufficient. Since the boxed form in Cogent is only available for records and
variants, an identifier followed by a star normally has the form \code{t<nn>}. However, Gencot temporarily implements
the type \code{MayNull b} where \code{b} is a boxed record by defining the typedef name \code{MayNull\_tnn}
as an alias for \code{tnn}, where \code{tnn *} is the type translation used for \code{b}. Thus an 
identifier followed by a star may also have the form \code{MayNull\_t<nn>}.

The third form specifies a an array type as
\begin{verbatim}
  <eltype>[<size>]
\end{verbatim}
and is used for Cogent builtin array types. Since Cogent builtin array types are always wrapped in a
struct, the element type \code{<eltype>} cannot be an array or pointer type and is always a single identifier. 
The array size \code{<size>} is always specified by a literal positive number which is not zero (since 
Cogent builtin arrays cannot be empty).

The member specifications are separated by whitespace, every member specification is a single word
without whitespace. 

For the translated function types every line describes a single function type or a function belonging 
to a type. Every type description is immediately followed by the list of its functions descriptions.
A type description uses the following format:
\begin{verbatim}
  <name> <restype> <partype>
\end{verbatim}
where \code{<name>} is the enumeration type name of the form \code{t<nn>}. The name and types are
separated by whitespace. Note that in Cogent every function has exactly one parameter and one result. 

A function belonging to 
a type is simply specified by its name (which is the same in Cogent and in the generated C code).
So type and function specification lines can be distinguished by the number of their words.

\subsection{Reading the C Source}
\label{impl-ctypinfo-read}

The \code{.h} C source generated by Cogent uses C preprocessor directives to include files and to define macros.
The included files contain type definitions for the translated basic Cogent types and for all abstract
polymorphic types defined in the Cogent program. They are required for parsing the C code. The 
macros defined in the \code{.h} file are never used there and can be ignored. Thus Gencot processes the
\code{.h} file using the standard C preprocessor \code{cpp} as described in Section~\ref{impl-ccode-preproc}
to execute and remove all preprocessor directives.

Then the file is parsed by a Haskell program using the language-c parser as described in 
Section~\ref{impl-ccode-read}. The file is read from standard input. It is parsed and then processed
by the language-c analysis module using function \code{readFromInput} in module \code{Gencot.Input}.
The resulting symbol table contains all globally defined identifiers.

To determine the required type information only the following definitions must be processed:
\begin{itemize}
\item \code{struct} definitions to determine all relevant struct types,
\item dispatcher function definitions to determine the information about function types.
\end{itemize}
Definitions from included files are not needed, so their content is filtered from the symbol table
as described in Section~\ref{impl-ccode-read}. The remaining symbol table entries are converted to
a list of \code{DeclEvent} values and filtered according to the required entries. Together,
Gencot uses the function \code{getDeclEvents} from module \code{Gencot.Input} in the same way as
for reading an original C program for translating it to Cogent.

\subsection{Generating the Struct Type Information}
\label{impl-ctypinfo-struct}

The struct type information is generated by a separate processing step. The \code{DeclEvent} list is filtered
so that only the struct definitions remain. Since every struct definition can be processed independently
and the state information used for translatig a C source is not used here, no monadic traversal is required. 

The processing is implemented by the function
\begin{verbatim}
  procStruct :: DeclEvent -> String
\end{verbatim}
defined in module \code{Gencot.Text.CTypInfo}. It is mapped to the filtered list of \code{DeclEvent}s and the resulting
List of Strings is output as a sequence of lines.

\subsection{Generating the Function Type Information}
\label{impl-ctypinfo-func}

The function type information is generated by a separate processing step. 

In its default configuration, Cogent uses the single enumeration type \code{untyped\_func\_enum} for enumerating
the functions of all function types. They are defined in the form
\begin{verbatim}
  typedef untyped_func_enum t<nn>;
\end{verbatim}
This is not sufficient for retrieving the information about a function type.

Instead, the information is taken from the dispatcher functions. Cogent generates for every function type a dispatcher 
function of the form
\begin{verbatim}
  static inline <restype> dispatch_<funtype>(
      untyped_func_enum a2, <paramtype> a3) { 
    switch (a2) {
      case FUN_ENUM_<name>: return <name>(a3);
        ...
      default: return <name>(a3);
  }}
\end{verbatim}
If the type has only one known function the body only consists of the default return statement.
The dispatcher function definition contains the function type name \code{<funtype>} and the \code{<restype>} and \code{<paramtype>}.
The names of the functions can be read from the \code{return} statements in the body. The \code{DeclEvent} list is filtered
so that only the dispatcher function definitions remain. Again, every dispatcher function definition
can be processed independently, no monadic traversal is required.

The processing is implemented by the function
\begin{verbatim}
  procFunc :: DeclEvent -> [String]
\end{verbatim}
defined in module \code{Gencot.Text.CTypInfo}. It returns the list of strings consisting of the type description and all related 
function names. It is mapped to the filtered list of \code{DeclEvent}s and the resulting
List is flattened and output as a sequence of lines.
