For working with the mapped C datatypes, in particular for those mapped using abstract Cogent types, Gencot provides support by
defining and implementing polymorphic Cogent functions, some of which are abstract and some of which are implemented in Cogent.

Although the operations provided for different kinds of datatypes have different semantics, they have common properties
and most are represented by common polymorphic functions. Here the operations are first introduced conceptually, together with
the polymorphic functions, then they are presented for specific kinds of data types.
Gencot provides the polymorphic function definitions in separate Cogent files which can be
included in a Cogent source.

\subsection{Dummy Expressions}
\label{design-operations-dummy}

For every mapped type Gencot defines a dummy expression of that type. It is used as a replacement for the actual 
body when translating C functions (see Section~\ref{design-fundefs}).

The dummy expression for all mapped numerical and enumeration types is the literal \code{0}.
The dummy expression for the unit type (used for functions which have \code{void} as result type) is the 
unit value \code{()}.

For all other types Gencot provides in \code{include/gencot/DummyExpr.cogent} the polymorphic abstract function
\begin{verbatim}
  gencotDummy: all(a). () -> a
\end{verbatim}
from the unit type to every possible Cogent type. Since the dummy expressions are intended to be eliminated before compiling the 
C code generated by the Cogent compiler, Gencot does not provide C definitions for this abstract function. 

If a function modifies parameters of linear type, it is translated by Gencot to return a tuple consisting of the 
original result and all such parameters (see Section~\ref{design-parmod}).
The dummy result expression is then built as a tuple with a dummy expression for the original result as the first component 
and the unmodified parameters as the remaining components.

\subsection{Default Values}
\label{design-operations-default}

Conceptually, Gencot provides a default value for every regular non-function Cogent type. For the primitive numeric types it is 
\code{0}, for type \code{String} it is \code{""}, and for type \code{()} it is the unit value \code{()}.

For a regular tuple (which has no component of linear or readonly type) it is the tuple of default values. For a
regular unboxed record it is the record where all fields have their default value. For a regular variant type it is
the default value of the first variant.

Gencot defines the polymorphic abstract function
\begin{verbatim}
  defaultVal: all(out:<DSE). () -> out
\end{verbatim}
in \code{include/gencot/Default.cogent}. 

Gencot provides instances for the numeric types \code{U8,U16,U32,U64} which return 0, for the unit type \code{()} which returns 
\code{()}, and for type \code{String} which returns \code{""}. 

Other instances must currently be defined manually, Gencot could be extended to provide automatic support for them as well.

\subsection{Creating and Disposing Boxed Values}
\label{design-operations-create}

Since all pointer types are mapped to Cogent linear types, Cogent does not provide support for creating values
of these types (``boxed values''). In C a pointer can be created using the address operator \code{\&} or by allocating data on
the heap using a C standard function such as \code{malloc}. The address operator is supported by Gencot
only for data on the heap, as explained in Section~\ref{app-transfunction-addrop}. Therefore, the basic functionality
for pointer creation is allocation on the heap. This must be provided as an abstract Cogent function.

Since values of a linear type cannot be discarded in Cogent, another abstract Cogent function is required for
disposing such values, implemented by using the C standard function \code{free}.

Gencot provides the polymorphic abstract functions defined in \code{include/gencot/Memory.cogent}:
\begin{verbatim}
  create : all(evt). Heap -> Result (evt,Heap) Heap
  dispose : all(evt). (evt,Heap) -> Heap
\end{verbatim}
for creating and disposing values of linear types. Gencot provides instance implementations for all linear
types, i.e. all (boxed) record types and abstract types. \code{Heap} is an abstract data type for modelling
the C heap where the data structures are allocated, it is defined in \code{include/gencot/Memory.cogent}.
\code{Result} is a variant type defined in the Cogent standard library (usually abbreviated as \code{R})
with variants for the success and error cases. In the success case \code{create} returns the newly allocated 
boxed value and the modified heap, in the error case it only returns the heap.

The \code{create} instances only allocate space on the heap but do not initialize it. To model this property in 
Cogent, Gencot uses two different Cogent types for every linear type to represent uninitialized (``empty'') and 
initialized (``valid'') values.
Conceptually, the instances of \code{create} and \code{dispose} are only defined for the empty-value types.
The function \code{create} returns empty values, the function \code{dispose} expects empty values. In particular,
empty values cannot contain linear parts (pointers to other memory regions) and can thus be safely discarded by 
deallocating their memory space. 

Note that according to their definition, the functions \code{create} and \code{dispose} are defined for arbitrary
types \code{evt}. However, Gencot only provides instances for (empty-value) linear types. Since it is not possible
to express this type property in Cogent, the use of unsupported instances of both functions are not detected by the 
Cogent compiler.

When Gencot maps a C type to a linear Cogent type, it always uses a Cogent record type (see Section~\ref{design-types}).
For these types the empty-value type is implemented by the record with all fields taken. Gencot defines in 
\code{include/gencot/Memory.cogent} the preprocessor macro
\begin{verbatim}
  EVT(vvt)
\end{verbatim}
which expands to the empty-value type \code{vvt take (..)} corresponding to the valid-value type \code{vvt}. 
It can be used to specify the correct
instances of \code{create} and \code{dispose} for all types implemented as Cogent record. For example, the 
\code{create} instance for a mapped pointer type \code{CPtr U32} can be specified as
\begin{verbatim}
  create[EVT(CPtr U32)]
\end{verbatim}

\subsection{Modifying Boxed Values}
\label{design-operations-modify}

Boxed records can be modified in Cogent by the put and take operations which in the simplest case have the form
\begin{verbatim}
  let r' = r { f = v } in ...
  let r' { f = p } = r in ...
\end{verbatim}
In the put operation \code{r} is the old record value, \code{f} is the field to be written, \code{r'} is the 
new (``modified'') record value and \code{v} is the new field value. The type of \code{r'} is either the same as 
for \code{r} or it differs, if field \code{f} was taken in \code{r}. In the take operation \code{r} is the old record value, \code{f} 
is the field to be taken, \code{r'} is the record without \code{f} and \code{p} is a pattern for binding the old 
field value. The type of \code{r'} is always different from that of \code{r}.

Note that in the C translation of this code the boxed records correspond to pointers to structs and for both operations
the pointers \code{r} and \code{r'} are the same.

We generalize this idea by defining operations for modifying boxed values in the form of Cogent functions.
To provide a common framework for modification operations, Gencot defines function types for such modification functions 
in \code{include/gencot/ModFun.cogent}. The basic function types are
\begin{verbatim}
  type ModTypeFun obj res arg out = (obj,arg) -> (res,out)
  type ModFun obj arg out = ModTypeFun obj obj arg out
\end{verbatim}
Here \code{obj} is the type of the value to be modified and \code{res} is its type after the modification.
Type \code{ModTypeFun} covers the general case where the type of the new value is different from that of the old value (although the pointer
values in C are the same!), \code{ModFun} covers the more special case where
the type is the same before and after the modification. In both cases a value of type \code{arg} is passed to the modification
function, it may provide information about how to modify the value, and the modification function additionally returns a value of
type \code{out}, e.g., an error code. The functions \code{fst} and \code{snd} defined in the Cogent standard library can be used
to retrieve the modified value and the additional output.

Note, that the additional property of a ``modification function'', that the result pointer must be the same as the argument pointer,
cannot be expressed in Cogent (or any other functional language). The type \code{ModTypeFun} is used by Gencot as an informal marker
for such functions. A function implemented in Cogent is a modification function, if it only applies take and put operations 
or other modification functions to its
first argument. An abstract Cogent function is a modification function
if the C implementation always returns the same pointer, without deallocating it in between.

The put operation can now be represented as a function of type \code{ModTypeFun R (R put f) V ()} where \code{R} is the type of
\code{r} and \code{V} that of field \code{f} and value \code{v}. If the field is not taken in \code{R} the type is \code{ModFun R V ()}.
The take operation can be represented as a function of type \code{ModTypeFun R (R take f) () V}, it returns 
a pair of the remaining record and the taken field value.

In case of an error a \code{ModTypeFun} may not be able to produce a result value of type \code{res}. For this case Gencot defines 
a function type for ``transactional'' modification functions which either succeed or ``roll back'' the modification and return 
the original input value:
\begin{verbatim}
  type TModTypeFun obj res arg out = (obj,arg) -> (Result res obj,out)
\end{verbatim}
using the variant type \code{Result} from the Cogent standard library. Note that a \code{ModFun} can be transactional, if it
returns the information that an error occurred as part of the additional result of type \code{out}.

A typical pattern for modifying a record field \code{f} is a combination of a take and a put operation of the form
\begin{verbatim}
  let r' { f = h } = r 
  and r'' = r' { f = chg(h) }
\end{verbatim}
where a function \code{chg} is used to determine the new field value from the old field value. We can generalize function
\code{chg} to a function of type \code{(fld,arg)->(fld,out)} where \code{fld} is the type of field \code{f}. It takes 
additional input of type \code{arg} and returns additional output of type \code{out}. However, it need not be a modification
function, since type \code{fld} need not be linear and \code{chg} may map its first argument to an arbitrary other value
of the same type. Gencot defines the function type
\begin{verbatim}
  type ChgFun obj arg out = (obj,arg) -> (obj,out)
\end{verbatim}
for this kind of ``change functions''. Its meaning is the plain Cogent semantics of the type definition, no additional property is 
included.

Now we can define a higher order function for the combined field modification as
\begin{verbatim}
  modify (r,(chg,x)) = 
    let r' { f = h } = r
    and (v,y) = chg(h,x)
    in (r' { f = v }, y)
\end{verbatim}
It has the function type \code{ModFun R (ChgFun V arg out, arg) out}, accepts as additional input a pair of a change
function for the field value and its additional input, and returns the modified record and the additional result of
the field change function. Note that \code{modify} also respects the type constraints if the field type \code{V}
is linear. The field value is neither duplicated nor discarded.

For this kind of modifying a part Gencot defines the corresponding generalized function type
\begin{verbatim}
  type ChgPartFun obj prt arg out = 
    ModFun obj (ChgFun prt arg out, arg) out
\end{verbatim}
where \code{obj} is the type of the modified object, \code{prt} is the type of the part to be changed, \code{arg} is the type
of the information passed to the part change function, and \code{out} is the type of additional output of both functions.

Since every \code{ModFun} is also a \code{ChgFun}, modification functions of this type can be chained to modify parts arbitrarily 
deep embedded in other parts. 

As an example, to change a part \code{p} of type \code{P} in a part \code{q} of type \code{Q} in a value \code{r} of type \code{R}
an expression of the form
\begin{verbatim}
  modifyQInR (r, (modifyPInQ, (chg, arg)))
\end{verbatim}
modifies \code{r} by replacing \code{p} by \code{chg (p,arg)}. To make the modification functions generic for the type of the additional input
to the part modification function and for the type of its additional output they can be defined as polymorphic:
\begin{verbatim}
  modifyQInR: all(arg,out). ChgPartFun R Q arg out
  modifyPInQ: all(arg,out). ChgPartFun Q P arg out
  chg: ChgFun P A O
\end{verbatim}

If the change function \code{chg} needs as input information of nonlinear type from other linear parts of \code{q} or \code{r} it is not
possible to pass these parts to \code{chg}. For a record type \code{R} either they must be taken from \code{r} and put back in after the modification, then
the type of \code{r} is \code{R take (...)} and \code{modifyQInR} cannot be applied because of type incompatibility. Or the parts are
accessed as readonly in a banged context for \code{r}, then the readonly parts cannot escape from the banged context to be passed to the
modification operation (which must be outside of the banged context since it modifies \code{r}). Instead, the required nonlinear information must 
be retrieved from the linear parts in a banged context for \code{r}. Since it is nonlinear it may escape from the context and can be passed 
to the modification operation.

In C it is a common pattern to pass pointers to other parts of a data structure around for efficiency and access values through these pointers 
only when needed to modify parts of the structure. In the Cogent translation the values must be accessed separately in a banged context and then
passed to the modification operation as copies.

If type \code{prt} of the part to be modified is not linear, function \code{modify} removes the part's value from the structure,
passes it to the part change function and puts the result back into the structure. This is
inefficient for large parts when the part is only \textit{modified} by changing a small subpart.
In C the typical way of dealing with this situation is to pass a pointer to the part change function 
instead. 

The same approach can be used in Cogent defining a function \code{modref} which works like \code{modify}, but
uses a part modification function of type \code{ModFun} and passes a pointer to it instead of a copy of the part. 
Since it returns the same pointer, the part value can be modified ``in-place''.
In Cogent the pointer corresponds to a value of linear type, so the part modification function can usually be 
implemented in Cogent. Function \code{modref}, instead, must be abstract and implemented in C with the help of 
the address operator \code{\&}. 

Gencot defines the function type
\begin{verbatim}
  type ModPartFun obj pprt arg out = 
    ModFun obj (ModFun pprt arg out, arg) out
\end{verbatim}
which can be used to specify the type of \code{modref}:
\begin{verbatim}
  modref: ModPartFun obj pprt arg out
\end{verbatim}
Here \code{pprt} is the pointer type corresponding to the part's type \code{prt}. Note that Gencot's type mapping 
scheme supports for every mapped C type a corresponding pointer type.

Function \code{modref} can be chained with other \code{modref} functions and with \code{modify} functions in the
same way as described for \code{modify} functions.

Of course, using a pointer to the in-place part of the boxed value introduces sharing between both. However, the 
part modification function has no access to the boxed value other than by the pointer to the part. It could only get
access if the boxed value or a part of it would be passed to it using the additional input of type \code{arg}. But since
that is passed to \code{modref} together with the boxed value itself, the Cogent type checking rules prevent this
as a double use of the boxed value. Thus the approach is safe and the part modification function can work with the
pointer according to the usual Cogent rules, as long as it always returns the same pointer as result value. This
means it cannot dispose it and it cannot store it in another structured value and return a different pointer of
the same type. Function \code{modref} then simply discards the returned pointer so that the sharing ends when it
completes.

\subsection{Initializing and Clearing Boxed Values}
\label{design-operations-init}

Gencot uses the terms ``initialization'' and ``clearing'' for the conversions between empty and valid boxed values.
After a boxed value has been created it must be initialized to be used, before it is disposed it must be cleared.

Initialization must set every part of a structured value to a valid value. For parts of nonlinear type this is
straightforward, since values of nonlinear types can be directly denoted in Cogent programs in most cases. Parts
of unboxed record and abstract types are made valid by passing a pointer to the part to an initialization
function for the corresponding boxed part value (as described for function \code{modref} in 
Section~\ref{design-operations-modify}).

For parts of linear type there are two possible approaches: they can be created during initialization 
or they can be passed as arguments. If they are created, the initialization function needs the heap as additional 
in- and output. Otherwise it takes all parts of linear type as additional input. Of course, if several parts
of linear type exist, some of them can be created and some passed as arguments.

Parts of readonly type \code{S!} cannot be initialized by creating a value for them. If a value is created in the 
initialization function it must be banged there but then it may not leave the banged context. The readonly value 
must either be created by a function which returns a value of type \code{S!}, or it must be passed as argument
to the initialization function. 

Clearing must convert every part of a structured value to an empty value. For parts of nonlinear type nothing
needs to be done, or the value can be explicitly set to a default value to overwrite the stored information for
security reason. Parts of unboxed record and abstract types are made empty by passing a pointer to a clearing 
function for the boxed part value.

Parts of linear type, dually to initializing them, can be disposed during clearing, or they can be returned
as result, so that they are not discarded. If they are disposed, the clearing function takes the heap as 
additional in- and output. Otherwise it returns all parts of linear type as output. If several parts
of linear type exist, some of them can be disposed and some returned as results.

Parts of readonly type need no specific treatment during clearing, since they can be discarded in the same way as
parts of nonlinear type.

Initialization and clearing functions are modification functions in the sense of Section~\ref{design-operations-modify}.
Translated to C they always return the same pointer they received as input.
Gencot defines the following function types in \code{Memory.cogent}:
\begin{verbatim}
  type IniFun evt vvt arg out = ModTypeFun evt vvt arg out
  type ClrFun vvt evt arg out = ModTypeFun vvt evt arg out
  type TIniFun evt vvt arg out = TModTypeFun evt vvt arg out
\end{verbatim}
They can be used by the developer to mark functions as initialization or clearing functions. This is purely 
informal since no constraint between the type parameters can be enforced by Cogent, so a correct pair of 
empty-value type and the corresponding valid-value type must be specified by the developer.

The third type supports ``transactional'' initialization functions which may fail and are rolled back, they return
a result of type \code{Result vvt evt}, as for type \code{TModTypeFun} (see Section~\ref{design-operations-modify}.
This is typically the case when initializing a part of the value includes allocating space on the heap.
If this is not done, initialization only consists of storing values, which cannot fail. For clearing we always 
assume that no error can occur, then the rollback for transactional initialization is always possible without 
causing another error.

Initialization and clearing functions are defined by Gencot to always expect additional input and output values of 
arbitrary types \code{arg} and \code{out}. The input value can be used to specify default values to be used,
the heap for creating and disposing parts of linear type, and initialization and clearing 
functions for parts of the value. If a function only uses fixed default values and functions for parts 
the unit type \code{()} is used as type \code{arg}. The output value can be used to return an error code,
the modified heap, or parts of linear type which have not been disposed.

An initialization or clearing function for a type with several parts must handle all parts together because it must
transform from the empty-value type, where all parts are taken, to the valid-value type, where all parts are present.
If an initialization or clearing function handles only one part, its type must respect which other parts are 
taken and which are not. This is not feasible for types with many parts. However, if all parts must be handled together,
there are many ways how to do so, especially if there are parts of linear and/or readonly type. 

Gencot provides the following polymorphic abstract initialization and clearing functions which are defined for only 
some of these cases:
\begin{verbatim}
  initFull : all(evt,vvt). IniFun evt vvt #vvt ()
  clearFull : all(vvt,evt). ClrFun vvt evt () #vvt
  initHeap : all(evt,vvt). TIniFun evt vvt Heap Heap
  clearHeap : all(vvt,evt). ClrFun vvt evt Heap Heap
  initSimp : all(evt,vvt). IniFun evt vvt () ()
  clearSimp : all(vvt,evt). ClrFun vvt evt () ()
\end{verbatim}
Generally, these functions are only defined if \code{evt} is the empty-value type corresponding to the valid-value
type \code{vvt}. Since this cannot be expressed by constraints in Cogent, Gencot defines the preprocessor macros:
\begin{verbatim}
  INIT(<k>,vvt) -> init<k>[EVT(vvt),vvt]
  CLEAR(<k>,vvt) -> clear<k>[vvt,EVT(vvt)]
\end{verbatim}
They can be used to specify valid instances of the functions with the correct types so that the constraints
between them are fulfilled and the Cogent typechecker can be used to test for correct application.
For example, \code{INIT(Full,vvt)} expands to \code{initFull[EVT(vvt),vvt]}. The macros can be used for 
all types \code{vvt} which are implemented as a Cogent record type.

Gencot also defines the macros
\begin{verbatim}
  INITTYPE(<k>,vvt)
  CLEARTYPE(<k>,vvt)
\end{verbatim}
which expand to the corresponding function types.

The first two functions pass the full content as argument: the additional input type for initialization and the additional
result type for clearing is the
unboxed type \code{\#vvt}. It is used to pass all content for the referenced memory region to \code{initFull} which
copies it there. For \code{clearFull} it is used to return all content, in particular, all content of linear type, so that 
it is not discarded.

The second pair passes the heap as additional input and result. Additionally, for initialization \code{vvt}
may not contain any readonly parts of type other than \code{(MayNull a)!} (see Section~\ref{design-operations-null}), 
because these cannot be initialized internally. Function \code{initHeap} allocates all parts of linear type on the heap 
and \code{clearHeap} disposes them. Parts of type \code{MayNull a} are initialzed to \code{null} and are disposed only 
if they are not \code{null}. Parts of type \code{(MayNull a)!} are initialized to \code{roNull}.
All parts of nonprimitive type are
initialized or cleared using function \code{initHeap} or \code{clearHeap}, respectively.
All parts of primitive type are initialized to their default value \code{defaultVal ()} and are cleared by
doing nothing. \code{clearHeap} also clears parts of readonly type by doing nothing. Whenever an allocation fails for 
\code{initHeap}, all other allocations are rolled back using \code{clearHeap}. The initialization function returns a variant
value which signals success or error.

The third pair passes no additional information. Moreover, \code{vvt} must have no linear parts. 
Functions \code{initSimp} and \code{clearSimp} work as \code{initHeap} or \code{clearHeap},
but the heap is not required since there are no linear parts which must be allocated or disposed.

The first pair is the most general, it is applicable to all kinds of valid-value types \code{vvt}. However, it bears the
most overhead, since all content must be passed as argument and copied to the memory to be initialized. The other
two pairs support ``in-place'' operation, however, they are more restrictive. 

Since the type of \code{initHeap} is different from that of the other initialization functions they cannot 
be passed as argument to a common function parameter. An alternative would have been to define all initialization
functions using the common type \code{TIniFun}, but then their use would always require unnecessary checks and
implementing an error case which can never occur.

Functions \code{clearFull}, \code{clearHeap}, and \code{clearSimp} do not overwrite the referenced memory with a 
``clearing value''. If this is required, a manually defined clearing function must be used instead.

For specific types \code{vvt} custom initialization and clearing functions can be defined manually. Typically, they 
pass values for some parts as parameters (in particular those of readonly types), and use default values or heap
allocation for the others.

\subsection{Accessing Parts of Structured Values}
\label{design-operations-parts}

For working with a structured value it is often necessary to access its parts for reading or modifying them.
Gencot supports the following conceptual operations on structured values:
\begin{description}
  \item[\code{get}] access the value of a part for reading,
  \item[\code{set}] replace the value of a part by a given value, discarding the old value,
  \item[\code{exchng}] replace the value of a part by a given value, returning the old value,
  \item[\code{modify}] apply a change function to a part.
\end{description}

Every function accesses only a single part of the structured value, if several parts must be accessed at the same
time custom operations must be defined manually.

Depending on the type of structured value and the kind of specifying the part, the part may safely exist or not.
For example, for a record field specified by its name it can be statically determined whether it exists,
for an array element specified by a calculated index value this is not the case. 

The actual function types of the operations differ depending on the way how the part is specified for them and
whether it safely exists. However, if the structured value has type \code{T} and the part has type \code{S} 
the conceptual functionalities are as follows:

The function \code{get} has functionality \code{T! -> S!}, if the part safely exists. It expects a readonly value as input and returns
a readonly copy of the part's value. This operation can be defined in Cogent for arbitrary types \code{S}
because the returned value can be shared with the value remaining in the structure since both are readonly.

If the part does not safely exists there are two possible functionalities: either the function returns a variant
value, or it returns a default value if the part does not exists. The variant value is the simpler and ``cleaner''
form, possible variant types are \code{Option} and \code{Result} from the Cogent standard library (the former treating
the part semantically as ``optional'', the latter treating its nonexistence as an ``error''). However, the use
of the variant value introduces an overhead, since Cogent implements it as a record. It must be constructed, passed
on the stack as function result, and then tested and deconstructed; for very frequent accesses to a part this may
cause a relevant performance reduction. Therefore an alternative form should be provided which always passes the
part's value directly, using a default if the part does not exist. It should only be used if it is clear from the
context that the part exists. A possible choice for the default value is \code{defaultVal} (defined in 
Section~\ref{design-operations-default}), however that is restricted to parts of regular type, therefore other 
solutions are required for other types.

An alternative to the function \code{get} would be a function which takes a modifyable structure and returns the structure
together with the element. However, this would be cumbersome in many applications and misleading for proofs, since 
the function never modifies the structure. 

The function \code{set} has functionality \code{(T,S) -> (T,())} and is a modification function in the sense of 
Section~\ref{design-operations-modify}, hence its type can be denoted as \code{ModFun T S ()}. 
It expects a structure and the new value as input
and returns the structure where only the value of the part has been replaced by the new value. The result value is 
structured as a pair, so that the function has the form of a modification function. Since the old
value of the part is discarded, function \code{set} is only defined if type \code{S} is discardable.
If the part does not exist, the function returns the unmodified structure.

The function \code{exchng} has functionality \code{(T,S) -> (T,S)} and is also a modification function, so its type
can be denoted as \code{ModFun T S S}. It works like \code{set}, but instead of
discarding the old value of the part it returns it in the result. This can be done for arbitrary types \code{S}
since values of this type are neither shared nor discarded. If the part does not exist, the function returns
the unmodified structure together with the input value.

The function \code{modify} is a modification function and has functionality \code{ChgPartFun T S A O} where 
\code{A} and \code{O} are arbitrary types.
According to the definition of \code{ChgPartFun} \code{modify} applies a part change function of
type \code{ChgFun S A O} to change the part. All types may be linear, since the corresponding values are
only passed through to the part change function and back.
The part change function determines the new part value from the old part value. If the part's type \code{S}
is linear it can be implemented by actually modifying the part's value. In particular, this can be done by
again using \code{modify} as part change function changing a part's part, as it has been described
for the \code{modify} function in Section~\ref{design-operations-modify}.

If the part does not exist, function \code{modify} returns the unmodified structure. However, it must also
return a value of type \code{O}, although the part change function is never executed. Similar as for 
function \code{get} there are two possibilities: returning a variant value or a default value. A third
possibility here is to use the same type \code{A} as additional input and result to the part change
function. Then, if the part change function is not executed, its additional input can be returned
as result. This works even for linear types \code{A} since this way the value is not discarded.

If the part's type \code{S} is not linear, it can be efficiently accessed using a pointer to it.
Gencot supports this with the following two operations:
\begin{description}
  \item[\code{getref}] return a pointer to a part,
  \item[\code{modref}] apply a modification function in-place to a part.
\end{description}

The function \code{getref} has functionality \code{T! -> PS!} where \code{PS} is the mapped type used by Gencot
for pointer to \code{S}. If \code{S} is an unboxed record or abstract type \code{\#B} then \code{PS} is the
corresponding boxed type \code{B}. Otherwise \code{PS} is the type \code{P\_S} generated by Gencot for pointers
to values of type \code{S}. The function cannot be implemented in Cogent and is usually implemented in C using the address 
operator \code{\&}. The operation is safe since both the structure and the result type are readonly. The shared
memory used by both can neither be modified through the structure nor through the resulting pointer. 

If the part does not safely exist, the situation is similat to function \code{get}. However, now the result 
type \code{PS} is always linear, so \code{defaultVal} cannot be used to provide a default value.

The function \code{modref} has functionality \code{ModPartFun T PS A O} where \code{A} and \code{O} are
arbitrary types. It behaves as described in Section~\ref{design-operations-modify}. If the part does not safely exist, 
the possible solutions are the same as for function \code{modify}.

Note that all part access functions are defined in a way that they never allocate or deallocate memory on the heap.
therefore they never need the heap as additional in- and output.

An alternative to the function \code{modref} would be a pair of functions \code{ref} and \code{deref} where \code{ref}
returns the pointer together with the structure converted to a type which marks the part as removed (for a record this
corresponds to the type with a field taken), and \code{deref} converts the type back to normal. 
Since the structure has the converted type the part cannot be accessed through it
as long as the type has not been changed back which is done by \code{deref}, consuming the pointer.
However, it is possible to apply \code{deref} to another pointer of the same type, causing sharing between the 
structure and the original pointer. To prevent this it must be proven for the Cogent program that the \code{deref}
operation is always applied to a pointer retrieved by a \code{ref} operation before any other \code{deref}
is applied to the structure. This implies that
for proving the type safety properties an arbitrary complex part of the Cogent program must be taken into
account. Therefore Gencot does not support such functions.

To make the other parts of the structure available in the modification operation the \code{modref} operation could
pass the structure to it together with the additional input, with the type converted to a readonly type where the modified
part is marked as removed. This is safe because in the modification function the part cannot be accessed
through the structure and the structure cannot be modified by inserting another value for the part since it is
readonly in the modification operation. Note however, that instead of passing the structure to the modification operation,
all (nonlinear) values required from it can also be retrieved outside of \code{modref} and passed to it as part of the 
additional information of type \code{A}. Therefore Gencot does not support this approach.

\subsection{Primitive Types}
\label{design-operations-prim}

The primitive Cogent types are the numerical types, \code{Bool} and \code{String}. 

\subsubsection{Creating and Disposing Values}

Values of primitive types cannot be created and disposed. If instances such as \code{create[U32]} are used in a program 
this is not detected as error by the Cogent compiler. However, since Gencot does not provide implementations for such
instances the resulting C program will not compile.

\subsubsection{Modifying Values}

Values of primitive types cannot be modified, they can only be replaced. The type constructor \code{ChgFun} 
can be used to define such replacement functions for primitive types. The type constructors for modification functions
defined in Section~\code{design-operations-modify} can also
be applied to primitive types, however the resulting function type does not have the
intended semantics of modification functions. Therefore such types should not be used.

\subsubsection{Initializing and Clearing Values}

Values of primitive types cannot be initialized or cleared. For primitive types there is no corresponding empty-value type.
Like for the modification function types the type constructors
\code{IniFun} and \code{ClrFun} can be applied to primitive types with useful results, but not with the intended semantics.
Therefore they should not be used.

\subsubsection{Accessing Parts of Values}

Primitive values have no parts, therefore the part access operations are not provided for them.

Although the type \code{String} has a structure consisting of a sequence of characters, access to characters is not supported
by Gencot because there is no known size for \code{String} values.

\subsection{Pointer Types}
\label{design-operations-pointer}

Here we denote as ``Gencot pointer types'' all Cogent types of the form \code{CPtr Ref} where \code{Ref} is an arbitrary non-function
Cogent type (except the unit type). These types are generated by Gencot for several C pointer types (see Section~\ref{design-types-pointer}).

Gencot pointer types always point to a value of primitive type, of an abstract type representing an unboxed array, or again a pointer 
(which may also be a function pointer, or a pointer used to represent an array or a boxed record).

Gencot pointer types do not include the type \code{CVoidPtr}. Since this is the mapping of the C type \code{void*} no information 
about the referenced data structure is available. Therefore Gencot cannot support any operations 
for it. Values of this type are fully opaque, they can be passed around but neither created, nor manipulated or disposed. 

It is possible for the developer to manually use additional Gencot pointer types by applying the generic type \code{CPtr} to other
Cogent types. Gencot provides the operation support described in the following sections also for such types.

\subsubsection{Creating and Disposing Pointers}

Since every Gencot pointer type is implemented by a Cogent record type, the corresponding empty-value type can be constructed by 
taking the single field: \code{(CPtr Ref) take (..)} which is equivalent to the expansion of the macro call \code{EVT(CPtr Ref)}
(see Section~\ref{design-operations-create}).

For every Gencot pointer type \code{CPtr Ref} used in the Cogent program Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[EVT(CPtr Ref)]
  dispose[EVT(CPtr Ref)]
\end{verbatim}

\subsubsection{Modifying Pointers}

Since Gencot pointer types are specific Cogent record types, modifications of pointer values can be done with the Cogent take and 
put functions.

The only modification function applicable to a pointer consists of replacing the referenced value. Such modifications correspond
either to initialization and clearing operations or to dereferencing operations, described in the next two sections.

\subsubsection{Initializing and Clearing Pointers}

Before a pointer returned by \code{create} can be used it must be initialized by storing a value into the referenced memory region.
Dually, before disposing a pointer the memory region may be cleared.

All instances of the functions \code{initFull/Heap/Simp} and \code{clearFull/Heap/Simp} described in 
Section~\ref{design-operations-init} are available
for Gencot pointer types. Functions \code{initFull} and \code{clearFull} additionally pass the value referenced
by the pointer (wrapped in an unboxed record). Functions \code{initSimp} and \code{clearSimp} set the referenced
value to its default value, discarding it upon clearing. Functions \code{initHeap} and \code{clearHeap} 
are required, if the referenced value is linear, for allocating or deallocating it on the heap. 

Functions
\code{initHeap} and \code{clearHeap} must also be used if the referenced value is of type \code{MayNull a} 
(see Section~\ref{design-operations-null}) since it has linear type. Note that function \code{initHeap} here
actually does not use the heap since it sets the referenced value to null. However, we assume that this is
feasible and do not provide alternative support for it, since it can also be implemented in Cogent using
the put operation.

For example a pointer \code{p} of type \code{EVT(CPtr U32)} can be initialized to the value \code{5} with typechecks by the 
Cogent expression
\begin{verbatim}
  INIT(Full,CPtr U32) (p,#{cont=5})
\end{verbatim}
and a pointer \code{p} of type \code{CPtr (CPtr U32)} can be cleared with typechecks by the Cogent expression
\begin{verbatim}
  CLEAR(Heap,CPtr (CPtr U32)) (p,heap)
\end{verbatim}
which clears and disposes the referenced pointer.

Alternatively values of Gencot pointer type can be initialized and cleared using the Cogent put and take
operations. Then the code for the initialization example above is
\begin{verbatim}
  p{cont=5}
\end{verbatim}
and for the clearing example is
\begin{verbatim}
  let p{cont=h}
  and h{cont}
  and heap = dispose(h,heap)
  in (p,heap)
\end{verbatim}
where clearing the value referenced by \code{h} is omitted since it is of primitive type.

\subsubsection{Dereferencing Pointers}

If a pointer is seen as a structured value, it has the referenced value as a single part.
Then the operations for accessing parts of a structured value can be defined for a Gencot pointer type as follows
The operation \code{getref} corresponds to the identity, the operation \code{modref} is equivalent to applying the
part modification function directly to the pointer. Both are not provided separately for pointers.
The other operations all dereference the pointer in some way. Gencot provides in \code{inlude/gencot/CPointer.cogent} 
the polymorphic functions
\begin{verbatim}
  getPtr: all(ptr,ref). ptr! -> ref! 
  setPtr: all(ptr,ref:<D). ModFun ptr ref ()
  exchngPtr: all(ptr,ref). ModFun ptr ref ref
  modifyPtr: all(ptr,ref,arg,out). ChgPartFun ptr ref arg out
\end{verbatim}
Instances of these functions are only defined if \code{ptr} is a Gencot pointer type and \code{ref} is the corresponding
type of the referenced values. 

The function \code{getPtr} dereferences a readonly pointer and returns the result as readonly. The function \code{setPtr}
replaces the referenced value by its second argument, discarding the old value. The function \code{exchngPtr} works like 
\code{setPtr} but returns the old referenced value as additional result. The function \code{modifyPtr} applies a change
function to the referenced value, replacing or modifying it.

Since a Gencot pointer type corresponds to a pointer which is guaranteed to be not null, the value referenced by the 
pointer safely exists and the functions need not handle the case where it does not exist.

\subsection{Function Pointer Types}
\label{design-operations-function}

As described in Section~\ref{design-types-function}, function pointer types are mapped by Gencot to abstract types of the form 
\code{CFunPtr Funtyp} where \code{Funtyp} is an arbitrary Cogent function type, or \code{CFunInc Restyp} where \code{Restyp}
is not a function type. They are not covered by Gencot pointer types since they behave differently.

\subsubsection{Creating and Disposing Function Pointers}

Function pointers cannot be created and disposed. Gencot does not provide instances of \code{create} and \code{dispose}
for function pointer types.

\subsubsection{Modifying Values}

Function pointers cannot be modified. As for primitive types the type constructors for modification functions should not be used for them.

\subsubsection{Initializing and Clearing Values}

Function pointers cannot be initialized or cleared, there is no corresponding empty-value type.
Like for the modification function types the type constructors
\code{IniFun} and \code{ClrFun} can be applied to function pointer types with useful results, but not with the intended semantics.
Therefore they should not be used.

\subsubsection{Accessing Parts of Values}

Function pointers have no parts, therefore the part access operations are not provided for them.

\subsubsection{Converting between Functions and Function Pointers}

For the values of the abstract type for function pointers in Cogent there are two relevant operations: invoking
it as a function and converting a Cogent function to a value of that type. Both are supported by Gencot
by providing polymorphic abstract functions in \code{inlude/gencot/CPointer.cogent} for the task.

The latter operation is supported by the polymorphic abstract function
\begin{verbatim}
  toFunPtr: all(fun,encfun). fun -> #(CFunPtr encfun)
\end{verbatim}
where \code{fun} is a Cogent function type and \code{encfun} is its encoding as a Cogent abstract type.

Invoking a function is supported by translating the function pointer to the Cogent function (equivalent to the enumeration value) which
then can be invoked in the usual way in Cogent. The translation is done by the polymorphic abstract function
\begin{verbatim}
  fromFunPtr: all(fun,encfun). #(CFunPtr encfun) -> Result fun ()
\end{verbatim}

All functions for which a function pointer is accepted or returned by these functions must be known to
Cogent so that there is an enumeration constant for it. It is not possible to pass a pointer to an arbitrary 
C function to Cogent as a parameter or as a field in a record. The function must either be defined in Cogent 
or it must be defined as an abstract function in Cogent. Moreover, if no function of type \code{fun} is 
defined in the Cogent program, the generated C code from an invocation of the result of \code{fromFunPtr} 
in Cogent is incomplete, since it invokes the dispatcher function which does not exist.

Illegal function pointers will be detected in the function \code{fromFunPtr}. The function must be implemented 
by selecting the result from a fixed list of known functions. Its result type uses the generic type \code{Result}
from the Cogent standard library. If the input pointer does not point to a 
function in the list (because it is NULL or points to an unknown function), an error is returned. Therefore,
whenever a function pointer shall be invoked, after translating it it must be checked whether the translation
was successful.

Note that \code{toFunPtr} is always successful, since it gets a known Cogent function as input and returns 
the corresponding function pointer.

An alternative approach for invoking a function pointer would be a polymorphic abstract function 
\begin{verbatim}
  invkFunPtr: all(args,res). (#(CFunPtr (args->res)), args) -> res
\end{verbatim}
where \code{args} is the type of the single argument of the Cogent function (possibly a tuple) and \code{res}
is the result type of the Cogent function. In its C implementation \code{invkFunPtr} applies the function pointer
to the argument and returns its result. 
This approach always causes correct C code to be generated by the Cogent compiler. However, since the Isabelle
C parser does not support function pointer invocations, no refinement proof can be processed for the resulting
C program.

Therefore Gencot does not support this alternative approach.

Hence for example for the C type
\begin{verbatim}
  int *()(int, short)
\end{verbatim}
the following function instances are provided
\begin{verbatim}
  toFunPtr[(U32,U16) -> (CPtr U32),FXU32XU16X_P_U32]
  fromFunPtr[(U32,U16) -> (CPtr U32),FXU32XU16X_P_U32]
\end{verbatim}

For incomplete function pointer types of the form \code{\#(CFunInc Restyp)} Gencot cannot provide instances of
\code{fromFunPtr} and \code{toFunPtr}, since it cannot determine the corresponding Cogent function type. Therefore
such function pointers cannot be used in any way in Cogent, they can only be passed through.

\subsection{The NULL Pointer}
\label{design-operations-null}

The type safety of Cogent relies on the fact that the pointers representing values of linear types are never \code{NULL}.
If null pointers are used in the C source, there is no immediate translation. The way how to translate C code which uses 
null pointers in a binary compatible way depends on the way how the null pointers are used.

A null pointer can be used as struct member \code{f} to mark the corresponding part as ``uninitialized''. 
It is set when the struct is created and later
replaced by a valid pointer. It remains valid until the struct is disposed. If additionally the struct is used only in places
during the ``uninitialized state'' which are different from those afterwards, the ``uninitialized state'' can be represented
by marking the part \code{f} as not present in the type used for the struct. Setting the pointer to a non-null value 
changes the struct type to the normal type used for it in Cogent. In a similar way NULL pointers can be used in array
elements and in referenced values while the array or pointer has its empty-value type.

If the field \code{f} is initialized ``on demand'', i.e., not at a statical point in the program, or if not all elements
of an array are initialized together, this solution is not possible.
A null pointer can also be used as an ``error'' or ``escape'' value for function parameters or results. 

The main problem in both cases is that it must be possible to determine at runtime whether a value is null or not. So simply
allocating a ``dummy'' to get a valid non-null pointer is not sufficient, it must also be possible to recognize the dummy pointer.

One possibility for this is if there is a value referenced by the pointer which never occurs in normal execution,
it can be used to mark the pointer as dummy. 

Another possibility is to use a single dummy pointer for all values of a specific linear type which can be null and store it 
in a seperate place for comparing it. However, this cannot be done in Cogent since the dummy pointer would be a shared linear 
value. Even if implemened in C through abstract functions, to prove memory safety every access to such a value must 
be guarded with a test for the dummy pointer. Thus it is easier to actually use the null pointer instead of the dummy pointer,
in combination with a guard testing for the null pointer

Moreover using a dummy pointer is not binary compatible if the pointer is 
also accessed in external existing C code where it is set to \code{NULL} or tested for being \code{NULL}.

A straightforward approach for working with the null pointer uses polymorphic abstract functions
\begin{verbatim}
  null: all(a). () -> a
  ronull: all(a). () -> a!
  isNull: all(a). a! -> Bool
\end{verbatim}
To dispose the null pointer the function \code{dispose} must also check for the null pointer and ignore
invocations for it. The function \code{ronull} is required to create null values of readonly types. This cannot be done 
by applying the bang operator to the result of \code{null} since then the readonly null value
cannot escape the banged context. 

However, the polymorphic functions cannot be restricted to specific types \code{T} by Cogent, therefore all values of all
types must be assumed to be null and their use must be guarded by \code{isNull}.

If Gencot generates monomorphic functions \code{null\_T}, \code{ronull\_T}, \code{isNull\_T} only for linear types or a
specific subset of them, this approach is also not safe. The existence of the function \code{null\_T} makes it necessary to guard all accesses to values of type
\code{T} and \code{T!} with the help of \code{isNull\_T}. The existence of the function \code{ronull\_T} makes it necessary to guard
all accesses to values of type \code{T!}, the values of type \code{T} need not be guarded since a readonly value can never be 
made modifyable again. Cogent cannot detect cases where values which may be null are accessed without guard.
Therefore Gencot does not automatically define the functions for linear types \code{T}.

\subsubsection{The abstract data type \code{MayNull}}

A safer approach replaces type \code{T} by an abstract type \code{MayNull T} and uses type \code{T} only in places where a value has been checked
for not being null. The abstract type must be specific for \code{T} and it must be complemented with abstract functions for
generating and testing the null pointer. Gencot provides the following generic abstract data type in \code{include/gencot/MayNull.cogent}.
It is available for all linear Cogent types, not only for types generated by Gencot by mapping a C pointer type.
\begin{verbatim}
  type MayNull a 
  null:      all(a). () -> MayNull a
  roNull:    all(a). () -> (MayNull a)!
  mayNull:   all(a). a -> MayNull a
  roMayNull: all(a). a! -> (MayNull a)!
  notNull:   all(a). MayNull a -> Option a
  roNotNull: all(a). (MayNull a)! -> (Option a)!
\end{verbatim}
The function \code{null} returns the null pointer, the function \code{mayNull} casts a non-null pointer of type \code{a}
to type \code{MayNull a}. The operations \code{roNull} and \code{roMayNull} do the same for readonly pointers. 

The type \code{Option} is used from the Cogent standard library. It is preferred over type \code{Result} because being null
is not interpreted as an error here.
The function \code{notNull} returns \code{None} if the argument is null and \code{Some x} if the argument \code{x} is not null.
The function \code{roNotNull} does the same for a readonly argument. 
Since \code{notNull} and \code{roNotNull} are the only functions which make the value available as a value of type \code{a} 
it is guaranteed by the Cogent type constraints that all accesses to the value are guarded by one of these two functions
(if no other abstract functions are introduced which convert from \code{Maynull a} to \code{a}).

As usual,
the type parameter \code{a} cannot be restricted by Cogent to linear types. However, Gencot provides instances of the functions only for
linear types \code{a}.

Note that since the type \code{MayNull a} is not denoted by a single type name it is not possible to construct Cogent mappings of 
derived types for it, such
as a function type with a parameter of type \code{MayNull a}. This is correct, since the function would be polymorphic. If a Cogent type name 
is defined for a specific instance of \code{MayNull}, mappings of derived types for the instance can be constructed using this type name.

Based on the abstract functions the function
\begin{verbatim}
  isNull: all(a). (MayNull a)! -> Bool
\end{verbatim}
is defined for an explicit test for the null pointer. It could be implemented in Cogent based on function \code{roNotNull} but
is implemented in C for efficiency reasons, avoiding the intermediate use of a value of type \code{Option a}.

\subsubsection{General Operations}

Values of type \code{MayNull a} cannot be created, disposed, initialized, or cleared. Either they are null, or they are pointers of
a valid-value pointer type, for which the type-specific functions for creating, initializing, cearing, and disposing are available.

The type constructors for modification function (see Section~\ref{design-operations-modify}) can be applied to \code{MayNull a} 
with the usual intended semantics.

\subsubsection{Part Access Operations}

Conceptually, the type \code{MayNull a} can be seen as a structured value with the non-null pointer of type \code{a} being
an optional ``part''. Then the operations for accessing parts of a structured value can be defined for \code{MayNull a} as follows
The operation \code{get} corresponds to \code{roNotNull}. The operation \code{set} cannot be defined, since the type \code{a} of the 
``part'' is always linear and thus not discardable. The operations \code{getref} and \code{modref} cannot be defined, since
the ``part'' is identical to the container and need not be stored somewhere on the heap. 
All four operations are not provided by Gencot. The other two operations are provided
by the polymorphic functions
\begin{verbatim}
  exchngNull: all(a).
     ModFun (MayNull a) a a
  modifyNull: all(a,arg).
     ModPartFun (MayNull a) a arg arg
  modifyNullDflt: all(a,arg:<D,out:<DSE).
     ModPartFun (MayNull a) a arg out
\end{verbatim}
Again, instances of the functions are only defined if \code{a} is a linear type. Like \code{isNull} the functions could be 
implemented in Cogent but are implemented in C for efficiency.

The function \code{exchngNull (mn, p)} takes as input two pointers, the first of which may be null. If \code{mn} is not null 
the result is the pair of \code{mayNull p} and the non-null pointer corresponding to \code{mn}.

The functions \code{modifyNull (mn, (modfun,addinput))} and \code{modifyNullDflt (mn, (modfun,addinput))} are
alternatives for operation \code{modify} as described in Section~\ref{design-operations-parts}.
If \code{mn} is not null it modifies the object referenced by \code{mn} by applying the part modification function \code{modfun} of type 
\code{ModFun a arg out} to \code{mn} and returns \code{mn} and the additional result of type \code{out}. Note that since here
the ``part'' is identical with the ``whole'', to modify the whole a modification function must be applied to the part instead of
a change function. Therefore the functions have type \code{ModPartFun} instead of \code{ChgPartFun}.

The case where the \code{MayNull a} value is null corresponds to the case where the part does not exist. According to the description in
Section~\ref{design-operations-parts} the function \code{roNotNull} corresponds to function \code{get} with a variant type as result.
Here a more efficient alternative passing the result value immediately is not possible, since in the null case a valid pointer must
be passed, which is not available. Therefore the typical C pattern of dereferencing a pointer without testing for null, because
we know from the context that it is not null, cannot be transferred directly to Cogent. However, a similar effect can be achieved
using type \code{a} for which it is guaranteed by the Cogent type system that it is a non-null pointer and which is always dereferenced
without testing it for null. 

Function \code{exchngNull} behaves in the null case as described in Section~\ref{design-operations-parts}, it returns its input \code{(mn,p)}.
Function \code{modifyNull} corresponds to the third case described in Section~\ref{design-operations-parts}. It uses the same type
for the additional input and result and returns the input to the part modification function as output when the part modification 
function is not used. This is the most general solution, therefore it is preferred over the other two. Since it restricts the function
to be used as part modification functions, the alternative \code{modifyNullDflt} is provided which discards the additional argument
and returns the default value \code{defaultVal[out]()} as additional result, however it is restricted in its types \code{arg} and
\code{out} as usual.

\subsection{Record Types}
\label{design-operations-record}

As described in Section~\ref{design-types-struct} C struct types are always mapped to Cogent record types.
Additional record types may be introduced manually in the translated Cogent program.

\subsubsection{Creating and Disposing Records}

The empty-value type corresponding to a record type \code{R} is the type \code{R take (..)} where all fields are taken,
which may be denoted by \code{EVT(R)} (see Section~\ref{design-operations-create}).

For every record type \code{R} used in the Cogent program (not only those generated by mapping a C type) Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[EVT(R)]
  dispose[EVT(R)]
\end{verbatim}

\subsubsection{Modifying Records}

The type constructors \code{ModFun}, \code{ModTypeFun}, \code{ChgPartFun}, and \code{ModPartFun} can be applied to record types with the 
usual intended semantics. 

A specific kind of modification functions for records are functions which put or take a record field. 
Gencot defines macros in \code{include/gencot/CStruct.cogent} to generate the type of simple put and take operations for
record types.

A macro call of the form 
\begin{verbatim}
  PUTFUN(R,f,A,O)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take f) R A O
\end{verbatim}
for a function which puts field \code{f} in a record of type \code{R}. A macro call of the form
\begin{verbatim}
  TAKEFUN(R,f,A,O)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun R (R take f) A O
\end{verbatim}
for a function which takes field \code{f} in a record of type \code{R} (without returning the taken value).

A macro call of the form 
\begin{verbatim}
  PUTFUN<n>(R,(f1,...,fn),f,A,O)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f,f1,...,fn)) (R take (f1,...,fn)) A O
\end{verbatim}
for a function which puts field \code{f} while the fields \code{fi} are already taken. A macro call of the form
\begin{verbatim}
  TAKEFUN<n>(R,(f1,...,fn),f,A,O)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f1,...,fn)) (R take (f,f1,...,fn)) A O
\end{verbatim}
for a function which takes field \code{f} while the fields \code{fi} are already taken.

Gencot does not automatically define modification functions for record types, since a record can be modified using the
Cogent get and put operations for its fields. Only if a field of unboxed record type is modified in-place through a 
modification function for its context, the record fields
must be manipulated using modification functions for the record. Then such operations must be defined manually.

\subsubsection{Initializing and Clearing Records}

Before a record returned by \code{create} can be used it must be initialized by putting values for all fields. 
Dually, before disposing a record it must be cleared by taking all fields.

All instances of the functions \code{initFull/Heap/Simp} and \code{clearFull/Heap/Simp} described in 
Section~\ref{design-operations-init} are available
for record types. Functions \code{initFull} and \code{clearFull} pass a value of the corresponding
unboxed record type. Functions \code{initSimp} and \code{clearSimp} set all fields to
their default value, ignoring them upon clearing. Functions \code{initHeap} and \code{clearHeap} 
are required if the record contains fields of linear type, for allocating or deallocating values for them on the heap.

Functions
for initializing and clearing a record \code{r} of type \code{R} by treating the fields differently can be manually 
defined in Cogent by putting or taking values into/from all fields.

If fields of linear type or of unboxed record or abstract type should be initialized or cleared using specific initialization
or clearing functions, these functions can either be specified explicitly in the code or they can be passed as additional
parameter to the initialization or clearing function. 

A field \code{f} with an unboxed record type \code{\#S} corresponds to an embedded struct in C. The space for this struct is allocated together
with the space for \code{r} by function \code{create}, so it needs only be initialized. The \code{initFull} instance initializes 
it by writing the value in one assignment together with alll other fields. The \code{initHeap/Simp} instances instead pass a pointer 
to the embedded struct to corresponding \code{initHeap/Simp} instances for the part. 

When an initialization function for \code{R} is implemented
manually, it should be possible to do the same with an arbitrary initialization function of type \code{IniFun EVT(S) S arg out}
for field \code{f}. This is the same approach as for the operation \code{modref} described in Section~\ref{design-operations-modify}.
However, \code{modref} takes as argument a value of type \code{R}
where no field is taken, so it cannot be used to put the taken field \code{f} by initializing it. Separate modification functions
are required for the record with taken fields. If the record contains several embedded structs every modification function
initializes one field and the result type has one field less taken. Thus, defining such modification functions imposes an order
in which the embedded structs must be initialized and whether they are initialized before or after the other fields. A corresponding
modification function for field \code{f} which must be initialized before field \code{g} but after all other fields would be
\begin{verbatim}
  putFInR : all(arg,out). 
    PUTFUN1(R,(g),f,(IniFun EVT(S) S arg out,arg),out)
\end{verbatim}
It is invoked with the initialization function for the embedded record and its argument 
as additional information. In a similar way a field of unboxed record type \code{\#S} can be cleared in-place using an abstract
function of the form
\begin{verbatim}
  takeFInR : all(arg,out).
    TAKEFUN1(R,(g),f,(ClrFun S EVT(S) arg out,arg),out)
\end{verbatim}
which applies a clearing function of type \code{ClrFun S EVT(S) arg out} and takes the field \code{f} while field \code{g} 
is already taken. Of course, instead of polymorphic functions for all types \code{arg} and \code{out} the specific forms
corresponding to \code{initFull}, \code{initHeap}, or \code{initSimp} can be defined.

Another approach to record initialization could have been that the function \code{create[EVT(R)]} returns a value where 
only the fields of primitive and linear type
are taken and the embedded structs are present, but again with all primitive and linear fields taken. Then the initialization function for
field \code{f} could be directly applied to a pointer to field \code{f}. However, it is still necessary to retrieve the pointer to \code{f}
with the help of an abstract function which now has to respect the fact that other embedded record fields have types with
some fields taken. So the same number of additional abstract functions is needed as in the approach above and their argument
types are of similar complexity.

Initializing a field \code{f} with a function pointer type \code{\#C(FunPtr Funtyp)} can always be done using the Cogent put operation.
The value to be put must be constructed using the function \code{toFunPtr} (see Section~\ref{design-operations-function}). To
avoid null pointers to functions, as described in Section~\ref{app-transfunction-pointer}, a dummy function should be defined in
Cogent and passed to the \code{toFunPtr} function.

\subsubsection{Accessing Record Fields}

The parts of a record are its fields. The conceptual operations for accessing parts of a structured value can be defined for a record type 
\code{R} as follows.

The field to be accessed by the operation must be specified by its name. This can only be done as part of the function name.
Therefore Gencot does not define polymorphic functions for accessing arbitrary fields of arbitrary record types. For every record type
\code{R} a set of differently named functions must be defined for every field \code{f}. Since only some of the functions are needed, Gencot
does not automatically generate such functions, they must be defined manually, if required.

The access functions can be defined as polymorphic functions in respect to the record type. Then, for every field name
\code{f} there is a polymorphic function which can be used for all records with a field named \code{f}. Additionally, the
function must be polymorphic in the field type, so that it supports fields of different type. The resulting 
functions have the following forms
\begin{verbatim}
  getFldF : all(rec,fld). rec! -> fld!
  setFldF : all(rec,fld:<D). ModFun rec fld ()
  exchngFldF : all(rec,fld). ModFun rec fld fld
  modifyFldF : all(rec,fld,arg,out). ChgPartFun rec fld arg out
\end{verbatim}
where \code{rec} is the type of the record and \code{fld} is the type of the field.

The operation \code{getFldF} for a field \code{f} corresponds to the Cogent member access operation \code{r.f}.
Since the \code{get} operation is not passed as argument to other functions, it need not be defined for record fields, it is always possible
to use the Cogent member access operation instead.

The operation \code{setFldF} for a field \code{f} and a value \code{v} corresponds to the Cogent put operation r{f = v}, if
the field has a discardable type. Otherwise it is not supported.

The operation \code{exchngFldF} for a field \code{f} and a value \code{v} can be implemented in Cogent by first taking the 
old value of \code{f}, then putting \code{v} and finally returning the record together with the old value.

The operation \code{modifyFldF} for a field \code{f} and a field change function can be implemented in Cogent 
by first taking the value of \code{f}, then applying the change function to it, and finally putting the result back into
the field. 

All three operations may be passed as argument to other modification functions, then they must be defined and cannot be replaced
by a direct inline implementation in Cogent.

Defining the access functions as polymorphic in the record type has the drawback that they cannot be implemented in Cogent, 
although every single instance for a specific record type can be implemented in Cogent. So, an alternative approach is to
define the access functions for every record type \code{Rec} and every field \code{f} of \code{Rec} with type \code{Fld} as
\begin{verbatim}
  getFInRec : Rec! -> Fld!
  setFInRec : ModFun Rec Fld ()
  exchngFInRec : ModFun Rec Fld Fld
  modifyFInRec : all(arg,out). ChgPartFun Rec Fld arg out
\end{verbatim}
where setFInRec is only defined if \code{Fld} is discardable.

The operations \code{getref} and \code{modref} cannot be implemented in Cogent, they must be defined as abstract function which are implemented in 
C with the help of the address operator \code{\&}. For a field \code{f} the corresponding function definitions have the form
\begin{verbatim}
  getrefFldF : all(rec,pfld). rec! -> pfld!
  modrefFldF : all(rec,pfld,arg,out). ModPartFun rec pfld arg out
\end{verbatim}
where \code{pfld} is the Gencot mapping of the type of pointer to the field type. 

Since whenever an instance of these functions is defined, the field is safely existing, the case of the nonexisting
part needs not be respected.

Remember that according to the definition of 
\code{ModPartFun} the function \code{modrefFldF} is invoked in the form
\begin{verbatim}
  (r',o) = modrefFldF(r, (m,a))
\end{verbatim}
where \code{r} is a boxed record value which is not readonly, \code{m} is a modification function of type \code{ModFun pfld arg out} which
has the form \code{(pfld,arg) -> (pfld,out)}, \code{a} is the argument of type \code{arg} passed to \code{m}, \code{r'} is
the record value \code{r} after the modification, and \code{o} is the additional result of type \code{out} returned by \code{m}.

\subsection{Array Types}
\label{design-operations-array}

Gencot represents arrays of known size in Cogent always by a (boxed) type \code{CArr<size> El} which is a record 
type wrapping the array (see Section~\ref{design-types-array}).
We call these types ``Gencot array types'' here.

Gencot array types are complemented by abstract polymorphic functions for working with
arrays. For these functions Gencot automatically generates the instance 
implementations in C. All these implementations involve the array size in some way. The developer may manually introduce
additional Gencot array types by adhering to the Gencot naming schema for array types (see Section~\ref{design-types-array}). 
Then Gencot also supports these types and generates instances of all polymorphic functions for them.

If the array size is unknown (types of the form \code{CArrXX El})
no instances of the polymorphic functions are provided by Gencot. However, implementations may be provided manually. Often
this is possible by the developer determining the array size from the context. If several array types with 
different unknown sizes have been mapped to the same abstract type, they must be disambiguished manually.

Gencot only supports arrays which are allocated on the heap. In C, arrays can also be introduced by defining
them as global or local variable, but Cogent has no language constructs which support this.

\subsubsection{Creating and Disposing Arrays}

Cogent does not provide a language construct to create or dispose values for Gencot array types.

Since Gencot array types are implemented as Cogent records, the empty-value type corresponding to type \code{CArr<size> El} 
is generated by the macro call \code{EVT(CArr<size> El)} as 
usual.

For every Gencot array type \code{CArr<size> El} used in the Cogent program Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[EVT(CArr<size> El)]
  dispose[EVT(CArr<size> El)]
\end{verbatim}

Both functions also support multidimensional array types of the form \code{CArr<size1> \#(CArr<size2> El)}.

\subsubsection{Modifying Arrays}

If an array is seen as a structured value, its elements are its parts.

Since the actual array type is always abstract, all accesses to array elements must be performed using abstract functions.

The type constructors for modification functions (see Section~\ref{design-operations-modify}) can be applied to 
Gencot array types with the usual intended semantics. 

Gencot provides no equivalent for single Cogent take and put operations for array elements. It would be
necessary to statically encode the set of array indices for which the elements have been taken in the type expression,
this is not feasible.

\subsubsection{Initializing and Clearing Arrays}

An array initialization function sets a valid value for every element. An array clearing function clears every element, 
clearing and disposing all linear values contained in elements. Since all elements are of the same type, they can all be
treated in the same way by an initialization or clearing function for the element type. Array elements are similar to
an embedded struct: the element value is stored in-place in the memory region used for the array. Hence, initializing and 
clearing an element can also be done in-place by passing a pointer to the element to the element initialization or 
clearing function. As usual, an additional input given to the array function is passed through to every invocation 
of the element function. 

All instances of the functions \code{initFull/Heap/Simp} and \code{clearFull/Heap/Simp} described in 
Section~\ref{design-operations-init} are available
for Gencot array types. Functions \code{initFull} and \code{clearFull} take or return the complete array content
as an unboxed value of type \code{\#(CArr<size> El)}. Functions \code{initSimp} and \code{clearSimp} set all elements
to their default value, ignoring them upon clearing. Functions \code{initHeap} and \code{clearHeap} 
are required, if the element type is linear, for allocating or deallocating it on the heap.

For example an array \code{a} of type \code{EVT(CArr16 U32)} can be initialized by setting all elements to \code{0} 
(the \code{defaultVal[U32]()}) with typechecks by the Cogent expression
\begin{verbatim}
  INIT(Simp,CArr16 U32) (a,())
\end{verbatim}
and an array \code{a} of pointers to integers with Cogent type \code{CArr16 (CPtr U32)} can be cleared with typechecks 
by the Cogent expression
\begin{verbatim}
  CLEAR(Heap,CArr16 (CPtr U32)) (a,heap)
\end{verbatim}
which will clear and dispose all elements.

Additionally, Gencot provides operations where the user can specify how to initialize or clear a single element, which is then
applied to all elements. The specification for a single element is done by passing an initialization or clearing function which
can be applied to a pointer to the element. Gencot defines the corresponding polymorphic abstract functions
\begin{verbatim}
  initEltsParCmb: all(evt,vvt,epe,vpe,arg:<S,out). 
     IniFun evt vvt (IniFun epe vpe arg out, arg, (out,out)->out) out
  clearEltsParCmb: all(vvt,evt,vpe,epe,arg:<S,out). 
     ClrFun vvt evt (ClrFun vpe epe arg out, arg, (out,out)->out) out
  initEltsPar: all(evt,vvt,epe,vpe,arg:<S). 
     IniFun evt vvt (IniFun epe vpe arg (), arg) ()
  clearEltsPar: all(vvt,evt,vpe,epe,arg:<S). 
     ClrFun vvt evt (ClrFun vpe epe arg (), arg) ()
  initEltsSeq: all(evt,vvt,epe,vpe,arg). 
     IniFun evt vvt (IniFun epe vpe arg arg, arg) arg
  clearEltsSeq: all(evt,vvt,epe,vpe,arg). 
     ClrFun vvt evt (ClrFun vpe epe arg arg, arg) arg
\end{verbatim}
where \code{epe} is the empty-value type for a pointer to an element and \code{vpe} is the corresponding valid-value type.
The first pair of functions passes the additional input of type \code{arg} in parallel to every invocation of the element function, 
therefore it must be sharable. The outputs of type \code{out} are combined using the function passed as third part of
the additional input to \code{initEltsParCmb} or \code{clearEltsParCmb}. It is applied by ``folding'', starting at the first element.
The second pair uses an element function which does not return a result and needs no combination function.
The third pair of functions passes the additional result of every invocation of the element function as additional input 
to the invocation for the next element. Thus it must have a common type, which may be linear, since it is neither shared nor
discarded. 

All three initialization functions are only defined for the case that no error can occur. In particular, the function
\code{initHeap} cannot be used as element initialization function. If this is required, a corresponding array initialization
function must be implemented manually.

For every array type \code{CArr<size> El} Gencot provides corresponding instances of all six functions.
In these instances all types besides \code{A} and \code{O} are uniquely determined by the array size and the element type, although
this cannot be expressed by Cogent type constraints. Therefore Gencot defines in \code{include/gencot/CArray.cogent}
the preprocessor macros
\begin{verbatim}
  INITelts(<k>,<ek>,<size>,El,A,O)
  CLEARelts(<k>,<ek>,<size>,El,A,O)
\end{verbatim}
which expand to the corresponding instance specifications shown above and
\begin{verbatim}
  INITTYPEelts(<k>,<ek>,<size>,El,A,O)
  CLEARTYPEelts(<k>,<ek>,<size>,El,A,O)
\end{verbatim}
which expand to their function types. Parameter \code{<k>} is either \code{ParCmb}, \code{Par}, 
or \code{Seq}. The additional parameter \code{<ek>} is required for technical reasons and specifies the
kind of the element type, as for macro \code{CPTR} (see Section~\ref{design-types-pointer}. 
It must be \code{U} if the element is an unboxed record type or an unboxed Gencot array type, and it
must be empty otherwise. If \code{<k>} is not \code{ParCmb} the last parameter \code{O} is ignored and may be empty.

For example an array \code{a} of type \code{EVT(CArr16 U32)} can be initialized by setting all elements to \code{5} 
with typechecks by the Cogent expression
\begin{verbatim}
  INITelts(Par,,16,U32,U32,) (a,(INIT(Full,CPtr U32),#{cont=5}))
\end{verbatim}

It could be useful to also know the element index in the element function. This could be supported by passing the index
as additional input to the element functions. However, this implies that the normal initialization and clearing functions
for the element type cannot be used as element functions here, since they do not expect the index as additional input.
Therefore the functions automatically supported by Gencot for initializing and clearing arrays do not pass the index 
to the element functions. However, using \code{initEltsSeq} or \code{clearEltsSeq}, the index can be calculated by
passing it from one invocation of the element function to the next, counting it up in the element function.

\subsubsection{Accessing Array Elements}

All operations for accessing parts of a structured value are nontrivial for the elements of an array. Since elements are 
specified by an index value a specified element need not exist, this case must be handled by the part access operations.

Gencot provides polymorphic functions for all six operations with alternatives for the case where the element does not 
exist:
\begin{verbatim}
  getArr : all(arr,idx,el). (arr!,idx) -> el!
  getArrChk : all(arr,idx,el). (arr!,idx) -> Result el! ()
  setArr : all(arr,idx,el:<D). ModFun arr (idx,el) ()
  exchngArr : all(arr,idx,el). ModFun arr (idx,el) (idx,el)
  modifyArr : all(arr,idx,el,arg). 
    ModFun arr (idx, ChgFun el arg arg, arg) arg
  modifyArrDflt : all(arr,idx,el,arg:<D,out:<DSE). 
    ModFun arr (idx, ChgFun el arg out, arg) out
  getrefArr : all(arr,idx,pel). (arr!,idx) -> pel!
  getrefArrChk : all(arr,idx,pel). (arr!,idx) -> Result pel! ()
  modrefArr : all(arr,idx,pel,arg). 
    ModFun arr (idx, ModFun pel arg arg, arg) arg
  modrefArrDflt : all(arr,idx,pel,arg:<D,out:<DSE). 
    ModFun arr (idx, ModFun pel arg out, arg) out
\end{verbatim}
The type variable \code{arr} denotes the array type, \code{idx} denotes the index type,
\code{el} denotes the array element type, and \code{pel} denotes the type of pointers to elements. 

Instances of these functions are only defined if \code{arr} is a Gencot array type. Type \code{idx}
must be one of \code{U8, U16, U32, U64} according to the \code{<size>} of the array. Types \code{el} and
\code{pel} must be as determined by \code{arr}. \code{arg} and \code{out} may be arbitrary types
only constrained as specified above.

Function \code{getArr} retrieves the indexed element as readonly. If the element does not exist because
the specified index is not in the range \code{0..<size>-1} the function returns the element with 
index \code{0} which always exists since Gencot array types must have atleast one element. Note that
this solution is more general than returning \code{defaultVal} since it works for arbitrary element types.
As alternative, as described in Section~\ref{design-operations-parts}, the function
\code{getArrChk} returns a variant value using the value \code{Error()} if the element does not exist.
This function should be used whenever it cannot be proven that the index is valid.

Function \code{setArr}, as usual, is only defined for a discardable element type. 
It simply discards the old value of the indexed element and sets it to the specified value.

Function \code{exchngArr}
replaces the element at the specified position by the element passed as parameter and returns the old element in the result.
The index is always part of the result so that the additional output has the same type as the additional input,
so that \code{exchngArr} can be used as element function also for \code{modifyArr} and \code{modrefArr}.

If the specified
index is not in the range \code{0..<size>-1} both functions work as described in Section~\ref{design-operations-parts}:
\code{setArr} returns the unmodified array and \code{exchngArr} returns its unmodified input.

Function \code{modifyArr} changes the element at the specified position by applying the element change function
to it. If the specified
index is not in the range \code{0..<size>-1} the function returns the unmodified array together with the additional input
value for the element change function. This corresponds to the third solution described in Section~\ref{design-operations-parts}
and requires that the types of additional input and result are the same. Since this may prevent the use of some element
change functions an alternative is provided by the function \code{modifyArrDflt} which discards the additional
input and returns the default value \code{defaultVal[out] ()}. This allows different types for input and result, however,
the required constraints apply to these types.

Function \code{getrefArr} returns a pointer to the element in the array without copying the element. This is safe since 
both the array and the result type are readonly. If the element does not exist it behaves like \code{getArr}, returning 
a pointer to the element with index \code{0}. The alternative function \code{getrefArrChk} is provided and returns the 
corresponding variant value.

Functions \code{modrefArr} and \code{modrefArrDflt} work like \code{modifyArr} and \code{modifyArrDflt} but use an
element modification function and pass a pointer to the element to it, so that the element is modified in-place.

The types of \code{modifyArr}, \code{modifyArrDflt}, \code{modrefArr}, and \code{modrefArrDflt} are similar to a 
\code{ChgPartFun} or \code{ModPartFun}, but differ because in addition to the 
element function and its argument the element index must be passed as argument.

Note that it is not possible
to pass the array or parts of it as additional information in the parameter of type \code{arg} of the element
functions, since that would always be
a second use of the array of linear type. If several elements must be modified together, a specific modification function
must be defined and used instead of \code{modifyArr} or \code{modrefArr}.

For multidimensional array types of the form \code{An1An2...} the element type is again an array type and the access 
functions work accordingly.

\subsection{Explicitly Sized Arrays}
\label{design-operations-eearray}

A common pattern in C programs is to explicitly use a pointer type instead of an array type for referencing an array,
in particular if the array is allocated on the heap. This is typically done if the number of elements in the
array is not statically known at compile time. The C concept of variable length array types can sometimes be
used for a similar purpose, but is restricted to function parameters and local variables and cannot be used for
structure members.

In C the array subscription operator can be applied to terms of pointer type \code{p} in the form \code{p[i]}. 
The semantics is to access an element in memory at the specified offset after the element referenced by the pointer. 
To use this in a safe way, the number of array elements must be known. 

Gencot provides support for this kind of working with arrays, if the number of elements is specified explicitly as
an integer value. The element pointer and the element size are combined to a pair. The corresponding type is called
an ``explicitly sized array'' type. Gencot uses the generic type \code{CArrEE}
to construct types for explicitly sized arrays, such as \code{CArrEE PEl} for an explicitly sized array with elements
of type \code{El}, where \code{PEl} is the type of pointers to the elements. The corresponding type definition is
\begin{verbatim}
  type CArrEE pel = (pel, U64)
\end{verbatim}

Since the type argument must be the pointer-to-element type Gencot provides in \code{include/gencot/ESArray.cogent}
the preprocessor macro
\begin{verbatim}
  CAES(<ek>,el)
\end{verbatim}
where \code{<ek>} describes the kind of element type as for the macro \code{CPTR} (see Section~\ref{design-types-pointer}).

For every instance of type \code{CArrEE} Gencot provides operations as described in the following sections.

\subsubsection{Converting Arrays}

Gencot provides support for converting array values between explicitly sized arrays and the fixed size arrays of types
\code{CArr<size> El}. It supports the polymorphic abstract functions
\begin{verbatim}
  toExplicitSize: all(arr,esa). arr -> esa
  toFixedSize: all(esa,arr). esa -> Result arr esa
  rotoExplicitSize: all(arr,esa). arr! -> esa!
  rotoFixedSize: all(esa,arr). esa! -> Result arr! esa!
\end{verbatim}
where \code{arr} is the fixed size array type and \code{esa} is the explicitly sized array type. Gencot provides instances
for all cases where \code{arr} and \code{esa} have the same element type. Since this contraint cannot be represented in
Cogent, Gencot provides the following preprocessor macros in \code{include/gencot/ESArray.cogent}:
\begin{verbatim}
  CAESTO(Trg,<ek>,<size>,El)
  CAESROTO(Trg,<ek>,<size>,El)
\end{verbatim}
where \code{Trg} is either \code{Explicit} or \code{Fixed}, \code{<ek>} is the kind of element type as above, \code{<size>} is the 
number of elements, and \code{El} is the element type. As example, the macro call \code{CAESTO(Explicit,,8,U32)} expands to
\begin{verbatim}
  toExplicitSize[CArr8 U32,CArrEE (CPtr U32)]
\end{verbatim}
and the macro call \code{CAESROTO(Fixed,P,5,CPtr U16)} expands to
\begin{verbatim}
  rotoFixedSize[CArrEE (CPtr (CPtr U16)),CArr5 (CPtr U16)]
\end{verbatim}

Function \code{toExplicitSize} returns the pair of the pointer to the first array element and the constant known size, this
always succeeds. Function \code{toFixedSize} compares the explicit size in the argument to the known fixed size of the result.
If they are equal it returns the element pointer, otherwise it returns an error value with the original input.

Whenever a pointer \code{p} to an element is given in a program and an expression \code{s} is known which specifies the corresponding
element size, the corresponding explicitly sized array value can be constructed manually as \code{(p,s)} in Cogent.

\subsubsection{Creating and Disposing Explicitly Sized Arrays}

The empty-value type corresponding to an explicitly sized array type \code{(PEl,U64)} is the type \code{(EVTYPE(PEl),U64)}.
For specifying this type Gencot provides the preprocessor macro
\begin{verbatim}
  EVT_CAES(<ek>,El)
\end{verbatim}
where parameter \code{<ek>} is as described for \code{CAES} above.

For allocating an explicitly sized array the size must be specified, since it is not known as part of the type.
Gencot provides the polymorphic abstract functions
\begin{verbatim}
  createESA: all(evt). (U64,Heap) -> Result (evt,Heap) Heap
  disposeESA: all(evt). (evt,Heap) -> Heap
\end{verbatim}
for all cases where \code{evt} is a type of the form \code{EVT\_CAES(ek,El)}.

\subsubsection{Modifying Explicitly Sized Arrays}

Explicitly sized arrays can be modified in the same way as fixed size arrays. In particular, 
all type constructors for modification functions (see Section~\ref{design-operations-modify}) can be applied to 
explicitly sized array types with the usual intended semantics. 

\subsubsection{Initializing and Clearing Explicitly Sized Arrays}

Since the array size is known at runtime, all conceptual initialization and clearing operations defined for fixed
size arrays can also be provided for explicitly sized arrays. These are the general operations defined in 
Section~\ref{design-operations-init} and the array-specific operations defined in Section~\ref{design-operations-array}.

The functions \code{initFull} and \code{clearFull} are not supported, since they are defined using the unboxed type \code{\#vvt}
to represent the content. For an explicitly sized array type the unboxed type is identical, then \code{initFull} has not the
intended semantics of moving data from the stack to the heap. The other functions work as described.

Since the way how the empty-value type is constructed is different for explicitly sized arrays, the macros defined in
Section~\ref{design-operations-init} cannot be used. Gencot instead provides the macros
\begin{verbatim}
  INIT_CAES(<k>,<ek>,El)
  CLEAR_CAES(<k>,<ek>,El)
  INITTYPE_CAES(<k>,<ek>,El)
  CLEARTYPE_CAES(<k>,<ek>,El)
\end{verbatim}
where \code{<k>} is one of \code{Heap} or \code{Simp}, and \code{<ek>} and \code{El} are as for \code{CAES} above.

The functions \code{initEltsParCmb}, \code{clearEltsParCmb}, \code{initEltsPar}, \code{clearEltsPar}, \code{initEltsSeq}, 
\code{clearEltsSeq} are all supported for explicitly sized array types \code{vvt}. Gencot provides the macros
\begin{verbatim}
  INITelts_CAES(<k>,<ek>,El,A,O)
  CLEARelts_CAES(<k>,<ek>,El,A,O)
  INITTYPEelts_CAES(<k>,<ek>,El,A,O)
  CLEARTYPEelts_CAES(<k>,<ek>,El,A,O)
\end{verbatim}
corresponding to \code{INITelts}, \code{CLEARelts}, \code{INITTYPEelts}, and \code{CLEARTYPEelts}. As for them
\code{<k>} is one of \code{ParCmb}, \code{Par}, or \code{Seq} and \code{A} and \code{O} are arbitrary types for the 
additional input and output of the element function. \code{O} is ignored if \code{<k>} is not \code{ParCmb}.

\subsubsection{Accessing Array Elements}

All element access functions defined for fixed size arrays in Section~\ref{design-operations-array} are also supported for 
explicitly sized arrays, i.e., their type variable \code{arr} can be an explicitly sized array type. The index type \code{idx}
can be as described (one of U8, U16, U32, U64).
