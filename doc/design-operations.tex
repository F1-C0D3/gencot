For working with the mapped C datatypes, in particular for those mapped to abstract Cogent types., Gencot provides support by
defining and implementing polymorphic Cogent functions, some of which are abstract and some of which are implemented in Cogent.

\subsection{Conceptual Operations}
\label{design-operations-concept}

Although the operations provided for different kinds of datatypes have different semantics, there have common properties
and are represented by common polymorphic functions. Here the operations are introduced conceptually, together with
the polymorphic functions. Gencot provides the polymorphic function definitions in separate Cogent files which can be
included in a Cogent source.

\subsubsection{Creating and Disposing Boxed Values}

Since all pointer types are mapped to Cogent linear types, Cogent does not provide support for creating values
of these types (``boxed values''). In C a pointer can be created using the address operator \code{\&} or by allocating data on
the heap using a C standard function such as \code{malloc}. The address operator is supported by Gencot
only for data on the heap, as explained in Section~\ref{app-trans-addrop}. Therefore, the basic functionality
for pointer creation is allocation on the heap. This must be provided as an abstract Cogent function.

Since values of a linear type cannot be discarded in Cogent, another abstract Cogent function is required for
disposing such values, implemented by using the C standard function \code{free}.

Gencot provides the polymorphic abstract functions defined in \code{Memory.cogent}:
\begin{verbatim}
  create : all(evt). () -> evt
  dispose : all(evt). evt -> ()
\end{verbatim}
for creating and disposing values of linear types. Gencot provides instance implementations for all linear
types, i.e. all (boxed) record types and abstract types.

The \code{create} instances only allocate space on the heap but do not initialize it. To model this property in 
Cogent, Gencot uses two different Cogent types for every linear type to represent uninitialized (``empty'') and 
initialized (``valid'') values.
Conceptually, the instances of \code{create} and \code{dispose} are only defined for the empty-value types.
The function \code{create} returns empty values, the function \code{dispose} expects empty values. In particular,
empty values cannot contain linear parts (pointers to other memory regions) and can thus be safely discarded by 
deallocating their memory space. 

Note that according to their definition, the functions \code{create} and \code{dispose} are defined for arbitrary
types \code{evt}. However, Gencot only provides instances for (empty-value) linear types. Since it is not possible
to express this type property in Cogent, the use of unsupported instances of both functions are not detected by the 
Cogent compiler.

\subsubsection{Modifying Boxed Values}

Boxed values can be modified in Cogent. Modification is directly supported by the Cogent language only by the put
and take operations which are applicable to boxed record values and in the simplest case have the form
\begin{verbatim}
  let r' = r { f = v } in ...
  let r' { f = p } = r in ...
\end{verbatim}
Here \code{r} is the old record value, \code{f} is the field to be modified, \code{r'} is the modified record value.
In the put operation \code{v} is the new field value. The type of \code{r'} is either the same as for \code{r} or it
differs, if field \code{f} was taken in \code{r}. In the take operation \code{p} is a pattern for binding the old 
field value, in \code{r'} the field is not present anymore, the type of \code{r'} is always different from that of \code{r}.

For boxed abstract types a modification operation can only be defined with the help of an abstract function.
To provide a common framework for modification operations, Gencot defines function types for modification functions 
in \code{include/gencot/ModFun.cogent}. The basic function types are
\begin{verbatim}
  type ModTypeFun obj res arg = (obj,arg) -> res
  type ModFun obj arg = ModTypeFun obj obj arg
\end{verbatim}
The first type covers the genaral case where the type of the modified value is different from that of the old value, in the second
case the type is the same before and after the modification. In both cases a value of type \code{arg} is passed to the modification
function, it may provide information about how to modify the value. 

The put operation can now be represented as a function of type \code{ModTypeFun R (R put f) V} where \code{R} is the type of
\code{r} and \code{V} that of field \code{f} and value \code{v}. If the field is not taken in \code{R} the type is \code{ModFun R V}.
The take operation can be represented as a function of type \code{ModTypeFun R (R take f) ()}. If the value of the taken
field should also be returned it can be represented as a function of type \code{ModTypeFun R (V,R take f) ()} where the result
is a pair of the taken field value and the remaining record.

If field \code{f} again has a linear type, it must have been taken before the put operation can be applied. Thus the 
typical pattern for modifying a field of linear type is
\begin{verbatim}
  let r' { f = p } = r 
  and r'' = r' { f = v }
\end{verbatim}
This can be represented as a function of type \code{ModFun R V} if the old field value is discarded (which is only possible
if the function is abstract). However, often the linear value of field \code{f} is not replaced but modified and then put back
in. This case can be represented by a function of type \code{ModFun R (ModFun V)} where the additional information for the modification
of \code{r} is the modification function to be applied to the value of field \code{f}. More generally, it must also be possible
to specify the additional argument to be passed to the modification function for the field, so the argument to the outer 
modification function should be a pair of the inner modification function and its argument. Gencot defines the corresponding
function type
\begin{verbatim}
  type ModPartFun obj prt arg = ModFun obj (ModFun prt arg, arg)
\end{verbatim}
where \code{obj} is the type of the modified object, \code{prt} is the type of the part to be modified, and \code{arg} is the type
of the information passed to the modification function of the part.

Since every \code{ModPartFun} is a \code{ModFun}, modification functions of this type can be chained to modify linear parts arbitrarily 
deep embedded in other linear parts. Moreover, a \code{ModPartFun} corresponds to combined take and put operation and can be used
to model ``in-place modification'' of linear parts. For these reasons Gencot uses such functions for all cases of modifications 
in the following sections.

As an example, to modify a part \code{p} of type \code{P} in a part \code{q} of type \code{Q} in a linear value \code{r} of type \code{R}
an expression of the form
\begin{verbatim}
  modifyQInR (r, (modifyPInQ, (modifyP, arg)))
\end{verbatim}
modifies \code{p} by replacing it by \code{modifyP (p,arg)}. To make the modification functions generic for the type of the additional input
to the part modification function they can be defined as polymorphic:
\begin{verbatim}
  modifyQInR: all(arg). ModPartFun R Q arg
  modifyPInQ: all(arg). ModPartFun Q P arg
  modifyP: ModFun P A
\end{verbatim}

If the modification function \code{modifyP} needs as input information of nonlinear type from other linear parts of \code{q} or \code{r} it is not
possible to pass these parts to \code{modifyP}. For a record type \code{R} either they must be taken from \code{r} and put back in after the modification, then
the type of \code{r} is \code{R take (...)} and \code{modifyQInR} cannot be applied because of type incompatibility. Or the parts are
accessed as readonly in a banged context for \code{r}, then the readonly parts cannot escape from the banged context to be passed to the
modification operation (which must be outside of the banged context since it modifies \code{r}). Instead, the required nonlinear information must 
be retrieved from the linear parts in a banged context for \code{r}. Since it is nonlinear it may escape from the context and can be passed 
to the modification operation.

In C it is a common pattern to pass pointers to other parts of a data structure around for efficiency and access values through these pointers 
only when needed to modify parts of the structure. In the Cogent translation the values must be accessed separately in a banged context and then
passed to the modification operation.

\subsubsection{Initializing and Clearing Boxed Values}

Gencot uses the terms ``initialization'' and ``clearing'' for the conversions between empty and valid boxed values.
After a boxed value has been created it must be initialized to be used, before it is disposed it must be cleared.

Initialization must set every part of a structured value to a valid value. For parts of nonlinear type this is
straightforward, since values of nonlinear types can be directly denoted in Cogent programs in most cases. Parts
of unboxed record and abstract types are made valid by converting them to a boxed value and initializing it.
Parts of linear value are created using function \code{create} and then initialized.

Clearing must convert every part of a structured value to an empty value. For parts of nonlinear type nothing
needs to be done, or the value can be explicitly set to a default value to overwrite the stored information for
security reason. Parts of unboxed record and abstract types are made empty by converting them to a boxed value 
and clearing it. Parts of linear value are cleared and then disposed using function \code{dispose}. Together, 
clearing a structured value will deallocate all mamory referenced by contained pointers, without deallocating
the memory used by the structured value itself.

Gencot does not provide polymorphic functions for initializing and clearing values. The reason is that the type
constraint that one type must be an empty-value type and the other the corresponding valid-value type cannot be
expressed in Cogent. Thus the polymorphic functions must be defined for arbitrary type pairs. Then Cogent cannot 
derive the empty-value type from the valid-value type and the correct relation between them cannot be statically
checked. This check is useful for guaranteeing correct initialization and clearing for all boxed values.

It would be possible for Gencot to provide initialization and clearing functions for every pair of empty-value
and valid-value types generated by mapping the types in the translated C program. However, in general there are 
several diffent ways how to initialize a specific data structure. Moerover, for types introduced manually the developer 
must implement initialization and clearing functions anyways. Therefore Gencot automatically generates
monomorphic initializing and clearing functions only for some types of boxed values.

Gencot defines the following generic types in \code{Memory.cogent}:
\begin{verbatim}
  type IniFun evt vvt arg = ModTypeFun evt vvt arg
  type ClrFun vvt evt arg = ModTypeFun vvt evt arg
\end{verbatim}
They can be used by the developer to mark functions as initialization or clearing functions. This is purely 
informal since no constraint between the type parameters can be forced by Cogent, so a correct pair of 
empty-value type and the corresponding valid-value type must be specified by the developer.

Initialization and clearing functions are defined by Gencot to expect an additional input value of an
arbitrary type \code{arg}. It can be used to specify default values to be used and initialization and clearing 
functions for parts of the value. If a function only uses fixed default values and functions for parts 
the unit type \code{()} is used for type \code{arg}.

The additional input is required for cases where Gencot automatically defines initialization and clearing
functions for types which may have parts of types for which Gencot does not define such functions. Then 
it cannot specify fixed functions for the parts, the functions to be used must be passed as arguments.

\subsubsection{Accessing Parts of Structured Values}

All types generated by Gencot are either primitive, records, or abstract. For record and abstract types both 
unboxed and boxed types are generated. Abstract types may be used to represent structured C values.

For working with a structured value it is often necessary to access its parts for reading or modifying them.
Gencot supports the following conceptual operations on structured values:
\begin{description}
  \item[\code{get}] access the value of a part for reading,
  \item[\code{set}] replace the value of a part by a given value, discarding the old value,
  \item[\code{exchng}] replace the value of a part by a given value, returning the old value,
  \item[\code{access}] return a pointer to a part,
  \item[\code{modify}] apply a modification function in-place to a part.
\end{description}

Every function accesses only a single part of the structured value, if several parts must be accessed at the same
time other operations must be defined manually.

The actual function types of the operations differ depending on the way how the part is specified for them.
However, if the structured value has type \code{T} and the part has type \code{S} the conceptual functionalities 
are as follows:

The function \code{get} has functionality \code{T! -> S!}. It expects a readonly value as input and returns
a readonly copy of the part's value. This operation can be defined in Cogent for arbitrary types \code{S}
because the returned value can be shared with the value remaining in the structure since both are readonly.

The function \code{set} has functionality \code{(T,S) -> T}. It expects a structure and the new value as input
and returns a structure where only the value of the part has been replaced by the new value. If type \code{S}
is not linear the old value can be safely discarded. Otherwise the old value must be cleared and disposed.
For this the operation either uses a fixed clearing function for type \code{S} or it expects such a clearing
function as additional input.

The function \code{exchng} has functionality \code{(T,S) -> (T,S)}. It works like \code{set}, but instead of
discarding the old value of the part it returns it in the result. This can be done for arbitrary types \code{S}
since values of this type are neither shared nor discarded.

The function \code{access} has functionality \code{T! -> PS!} where \code{PS} is the mapped type used by Gencot
for pointer to \code{S}. If \code{S} is an unboxed record or abstract type \code{\#B} then \code{PS} is the
corresponding boxed type \code{B}. Otherwise \code{PS} is the type \code{P\_S} generated by Gencot for pointers
to values of type \code{S}. The function cannot be implemented in Cogent and is usually implemented in C using the address 
operator \code{\&}. The operation is safe since both the structure and the result type are readonly. The shared
memory used by both can neither be modified through the structure nor through the resulting pointer. 

The function \code{modify} has functionality \code{(ModPartFun T PS A} where \code{A} is an arbitrary type.
According to the definition of \code{ModPartFun} \code{modify} applies a part modification function of
type \code{ModFun PS A} to modify the part.
The part modification function expects a pointer to the part as input and modifies the part's value ``in-place''. If
\code{S} is a linear type the part's value is not discarded but modified. In particular, this can be done by
again using \code{modify} as part modification function modifying a part's part, as it has been described
for the function type \code{ModPartFun} above.

Instead of passing a pointer to the part modification function, the part's value could be removed from the structure,
passed to a modification function of type \code{ModFun S A} and then be put back into the structure. However, this
would be less efficient since to remove the value from the structure it must be copied.

Note that the use of the pointer in the modification function is safe, no sharing can occur for the part's memory
space. For sharing to occur, the structure value or a part of it must be passed to the part modification function as
part of the additional input of type \code{A}. If the structure is modifyable, type \code{T} is linear and passing 
the value as part of the additional input would be a double use which is prevented by the Cogent type constraints.

An alternative to the function \code{get} would be a function which takes a modifyable structure and returns the structure
together with the element. However, this would be cumbersome in many applications and misleading for proofs, since 
the function never modifies the structure. 

An alternative to the function \code{modify} would be a pair of functions \code{ref} and \code{deref} where \code{ref}
returns the pointer together with the structure converted to a type which marks the part as removed (for a record this
corresponds to the type with a field taken), and \code{deref} converts the type back to normal. 
Since the structure has the converted type the part cannot be accessed through it
as long as the type has not been changed back which is done by \code{deref}, consuming the pointer.
However, it is possible to apply \code{deref} to another pointer of the same type, causing sharing between the 
structure and the original pointer. To prevent this it must be proven for the Cogent program that the \code{deref}
operation is always applied to a pointer retrieved by a \code{ref} operation before any other \code{deref}
is applied to the structure. This implies that
for proving the type safety properties an arbitrary complex part of the Cogent program must be taken into
account. Therefore Gencot does not support such functions.

To make the other parts of the structure available in the modification operation the \code{modify} operation could
pass the structure to it together with the additional input, with the type converted to a readonly type where the modified
part is marked as removed. This is safe because in the modification function the part cannot be accessed
through the structure and the structure cannot be modified by inserting another value for the part since it is
readonly in the modification operation. Note however, that instead of passing the structure to the modification operation,
all (nonlinear) values required from it can also be retrieved outside of \code{modify} and passed to it as part of the 
additional information of type \code{A}.

There could be more complex cases of working with a structured value through pointers to parts. For example, the 
modification function could return information of an additional type \code{B} as part of its result.

If used, such variants of \code{modify} must be defined manually. Gencot only supports the basic variant of the 
\code{modify} operation described above.

\subsection{Primitive Types}
\label{design-operations-prim}

The primitive Cogent types are the numerical types, \code{Bool} and \code{String}. 

\subsubsection{Creating and Disposing Values}

Values of primitive types cannot be created and disposed. If instances such as \code{create[U32]} are used in a program 
this is not detected as error by the Cogent compiler. However, since Gencot does not provide implementations for such
instances the resulting C program will not compile.

\subsubsection{Modifying Values}

Values of primitive types cannot be modified. The type constructors \code{ModTypeFun}, \code{ModFun}, and \code{ModPartFun}
can be applied to primitive types. The resulting types are consistent and may be useful, however they do not have the
intended semantics of ``modification functions''. Therefore they should not be used.

\subsubsection{Initializing and Clearing Values}

Values of primitive types cannot be initialized or cleared. For primitive types there is no corresponding empty-value type.
Like for the modification function types the type constructors
\code{IniFun} and \code{ClrFun} can be applied to primitive types with useful results, but not with the intended semantics.
Therefore they should not be used.

\subsubsection{Accessing Parts of Values}

Primitive values have no parts, therefore the part access operations are not provided for them.

Although the type \code{String} has a structure consisting of a sequence of characters, access to characters is not supported
by Gencot because there is no known size for \code{String} values.

\subsection{Pointer Types}
\label{design-operations-pointer}

Here we denote as ``Gencot pointer types'' all mappings of C pointer types \code{t*} where \code{t} is no C struct, union, array or function.
As described in Section~\ref{design-types-pointer} , Gencot pointer types are 
Cogent abstract types with a name of the form \code{P\_T} where \code{T} is the Cogent mapping of a primitive, enumeration, struct, or union 
type \code{t} or a name of the form \code{PT} where \code{T} is the Cogent mapping of a function pointer or array or \code{T} is again a 
Gencot pointer type.

Gencot pointer types do not include the type \code{P\_Void}. For \code{P\_Void} no information about the referenced data structure is available. 
Therefore Gencot cannot support any operations 
for it. Values of this type are fully opaque, they can be passed around but neither created, nor manipulated or disposed. 

It is possible for the developer to manually define additional Gencot pointer types by defining abstract types using the same naming schema.
Gencot provides the operation support described in the following sections also for such types.

\subsubsection{Creating and Disposing Pointers}

The empty-value type corresponding to a Gencot pointer type \code{P...} is the type \code{TP...} which
is automatically generated by Gencot. It has a similar meaning as a Cogent
record with all fields taken. It statically marks the pointer as referencing uninitialized memory. It is mapped to the same C 
type as \code{P...}.

Gencot defines in \code{include/gencot/Memory.cogent} the preprocessor macro 
\begin{verbatim}
  PTREMPTY(P...)
\end{verbatim}
to specify the empty-value type for the valid-value Gencot pointer type \code{P...}. (It is implemented 
as preprocessor macro because it cannot be implemented as generic type in Cogent.)

For every Gencot pointer type \code{P...} used in the Cogent program Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[PTREMPTY(P...)]
  dispose[PTREMPTY(P...)]
\end{verbatim}

\subsubsection{Modifying Pointers}

Since pointer types are always abstract, all modifications of pointer values must be performed using abstract functions.

The only modification function applicable to a pointer consists of replacing the referenced value. Such modifications correspond
either to initialization and clearing operations or to dereferencing operations, described in the next two sections.

\subsubsection{Initializing and Clearing Pointers}

Before a pointer returned by \code{create} can be used it must be initialized by storing a value into the referenced memory region.
Dually, before disposing a pointer the memory region may be cleared.

Since Gencot pointer types \code{P...} point to a value of primitive type or again a pointer (which may be a function pointer,
or a pointer used to represent an array or a boxed record), an in-place
stepwise initialization of the referenced value is not possible. Initialization is always done by writing a single value or pointer
into the referenced memory. Clearing disposes a referenced non-function pointer, in all cases it may overwrite the referenced value
for security reasons.

Gencot defines generic types for such pointer initialization and clearing functions in \code{include/gencot/Memory.cogent}:
\begin{verbatim}
  type PtrIniFun evt vvt ref = IniFun evt vvt ref
  type PtrClrFun vvt evt = ClrFun vvt evt ()
  type PtrPtrClrFun vvt evt ref eref arg = ClrFun vvt evt (ClrFun ref eref arg, arg)
\end{verbatim}
where \code{evt} is the empty-value pointer type, \code{vvt} is the valid-value pointer type, and \code{ref} is the valid-value
type of the referenced values. A pointer initialization function always expects as additional input the value to be stored in
the referenced memory region. A function of type \code{PtrClrFun} has no additional input, it may overwrite the referenced memory
with a fixed value or leave it unchanged. The type \code{PtrPtrClrFun} is used if \code{ref} is a non-function pointer type. It takes 
as additional input a clearing function for type \code{ref} together with its argument. \code{eref} is the empty-value type
corresponding to \code{ref} and \code{arg} is the type of the additional input for the clearing function for the referenced value. 
All types besides \code{arg} are uniquely determined by the 
pointer type \code{vvt}, although this cannot be expressed by Cogent type constraints. Therefore Gencot  defines in 
\code{include/gencot/Memory.cogent} the preprocessor macros
\begin{verbatim}
  PTRINIFUN(REF,k)
  PTRCLRFUN(REF,k,AIT)
\end{verbatim}
for the types of initialization and clearing functions for a Gencot pointer type referencing a value of type \code{REF}
The additional parameter \code{k} is used to tell the kind of \code{REF}. It may be empty for a primitive type,
\code{F} for a function pointer type, \code{R} for a record type, or \code{P} for all other pointer types. Type \code{AIT}
is the type of the additional input for the clearing function for the referenced value. If \code{k} is \code{F} or
empty it is ignored and can be empty.

For example the macro call \code{PTRINIFUN(U32,)} expands to the pointer initialization function type
\begin{verbatim}
  PtrIniFun TP_U32 P_U32 U32
\end{verbatim}
and the macro call \code{PTRCLRFUN(P\_U32,P,Arg)} expands to the pointer clearing function type
\begin{verbatim}
  PtrClrFun PP_U32 TPP_U32 P_U32 TP_U32 Arg
\end{verbatim}

Gencot defines the polymorphic functions
\begin{verbatim}
  initPtr: all(evt,vvt,ref). PtrIniFun evt vvt ref
  clearPtr: all(vvt,evt). PtrClrFun evt vvt
  clearPtrPtr: all(vvt evt ref eref arg). PtrPtrClrFun vvt evt ref eref arg
\end{verbatim}
Gencot defines instances of \code{initPtr} for all Gencot pointer types. It provides instances of \code{clearPtr} only for Gencot pointer types which
reference a primitive or function pointer value, and it provides instances of \code{clearPtrPtr} only for all other Gencot pointer types.
The \code{initPtr} instances store the additional input value 
into the referenced memory. The \code{clearPtr} instances do nothing and return their first argument (they do not overwrite the referenced memory).
The \code{clearPtrPtr} instances invoke the clearing function on the referenced value and the additional input and apply \code{dispose} to the result.
They leave the referenced memory unchanged. By using these functions with an explicit type specified by one of the macros above the Cogent type 
checker can be employd for checking the type consistency of the function use.

For example a pointer \code{p} of type \code{TP\_U32} can be initialized to the value \code{5} with typechecks by the Cogent expression
\begin{verbatim}
  initPtr[PTRINIFUN(U32,)] (p,5)
\end{verbatim}
and a pointer \code{p} of type \code{PP\_U32} can be cleared with typechecks by the Cogent expression
\begin{verbatim}
  clearPtrPtr[PTRCLRFUN(P_U32,P,())] (p,(clearPtr,()))
\end{verbatim}

\subsubsection{Dereferencing Pointers}

If a pointer is seen as a structured value, it has the referenced value as a single part.
Then the operations for accessing parts of a structured value can be defined for a Gencot pointer type as follows
The operation \code{access} corresponds to the identity, the operation \code{modify} is equivalent to applying the
part modification function directly to the pointer. Therefore both operations are not provided separately for pointers. 
The other operations all dereference the pointer in some way and are provided by the polymorphic functions
\begin{verbatim}
  getPtr: all(p,ref). p! -> ref! 
  setPtr: all(p,ref:<D). ModFun p ref
  exchngPtr: all(p,ref). (p,ref) -> (p,ref)
\end{verbatim}
Instances of these functions are only defined if \code{p} is a Gencot pointer type and \code{ref} is the corresponding
type of the referenced values. 

The function \code{getPtr} dereferences a readonly pointer and returns the result as readonly. The function \code{setPtr}
replaces the referenced value by its second argument, discarding the old value. Therefore the type \code{ref} of the referenced 
value must be discardable. The function \code{exchngPtr} works like
\code{setPtr} but returns the old referenced value as additional result.

\subsection{Function Pointer Types}
\label{design-operations-function}

As described in Section ~\ref{design-types-function}, function pointer types are mapped by Gencot to abstract types of the form 
\code{\#F...}. They are not covered by Gencot pointer types since they behave differently.

\subsubsection{Creating and Disposing Function Pointers}

Function pointers cannot be created and disposed. If instances such as \code{create[F...]} are used in a program 
this is not detected as error by the Cogent compiler. However, since Gencot does not provide implementations for such
instances the resulting C program will not compile.

\subsubsection{Modifying Values}

Function pointers cannot be modified. The type constructors \code{ModTypeFun}, \code{ModFun}, and \code{ModPartFun}
can be applied to function pointer types. The resulting types are consistent and may be useful, however they do not have the
intended semantics of ``modification functions''. Therefore they should not be used.

\subsubsection{Initializing and Clearing Values}

Function pointers cannot be initialized or cleared, there is no corresponding empty-value type.
Like for the modification function types the type constructors
\code{IniFun} and \code{ClrFun} can be applied to function pointer types with useful results, but not with the intended semantics.
Therefore they should not be used.

\subsubsection{Accessing Parts of Values}

Function pointers have no parts, therefore the part access operations are not provided for them.

\subsubsection{Converting between Functions and Function Pointers}

For the values of the abstract type for function pointers in Cogent there are two relevant operations: invoking
it as a function and converting a Cogent function to a value of that type. Both are supported by Gencot
by providing polymorphic abstract functions for the task.

The latter operation is supported by the polymorphic abstract function
\begin{verbatim}
  toFunPtr: all(fun, ptr). fun -> ptr
\end{verbatim}
where \code{code} is a Cogent function type and \code{ptr} is the corresponding function pointer type.
Although \code{ptr} is uniquely determined by \code{fun} Gencot does not provide support for this constraint.
However, Gencot provides implementations of instances only for valid pairs of function and function pointer types.

Invoking a function can be supported in two different ways. The first approach is by a polymorphic
abstract function
\begin{verbatim}
  fromFunPtr: all(ptr,fun). ptr -> fun
\end{verbatim}
which translates the function pointer to the Cogent function (equivalent to the enumeration value) which
then can be invoked in the usual way in Cogent. The second approach is by a polymorphic  abstract function 
\begin{verbatim}
  invkFunPtr: all(ptr,args,res). (ptr, args) -> res
\end{verbatim}
where \code{args} is the type of the single argument of the Cogent function (possibly a tuple) and \code{res}
is the result type of the Cogent function. Function \code{invkFunPtr} internally translates the function pointer,
invokes the resulting Cogent function with the argument and returns its result.

If the first approach is used, all functions which are passed to Cogent as a parameter or as a field in a record must be known to
Cogent so that there is an enumeration constant for it. It is not possible to pass a pointer to an arbitrary 
C function to Cogent, the function must either be defined in Cogent or it must be defined as an abstract function 
in Cogent. Moreover, if no function of type \code{fun} is defined in the Cogent program, the
generated C code from an invocation in Cogent is incomplete, since it invokes the dispatcher function which does
not exist.

The second approach always causes correct C code to be generated by the Cogent compiler, however, since the functions
invoked from function pointers are not known to Cogent, they cannot be taken into account by Cogent proofs.

For simplicity, the current Gencot version only supports the second approach.

Hence for example for the C type
\begin{verbatim}
  int *()(int, short)
\end{verbatim}
the following function instances are provided
\begin{verbatim}
  toFunPtr[((U32,U16) -> P_U32), #F_'U32'U16'_P_U32]
  invkFunPtr[#F_'U32'U16'_P_U32, (U32,U16), P_U32]
\end{verbatim}

\subsection{The NULL Pointer}
\label{design-operations-null}

The type safety of Cogent relies on the fact that the pointers representing values of linear types are never \code{NULL}.
If null pointers are used in the C source, there is no immediate translation. The way how to translate C code which uses 
null pointers in a binary compatible way depends on the way how the null pointers are used.

A null pointer can be used as struct member \code{f} to mark the corresponding part as ``uninitialized''. 
It is set when the struct is created and later
replaced by a valid pointer. It remains valid until the struct is disposed. If additionally the struct is used only in places
during the ``uninitialized state'' which are different from those afterwards, the ``uninitialized state'' can be represented
by marking the part \code{f} as not present in the type used for the struct. Setting the pointer to a non-null value 
changes the struct type to the normal type used for it in Cogent. In a similar way NULL pointers can be used in array
elements and in referenced values while the array or pointer has its empty-value type.

If the field \code{f} is initialized ``on demand'', i.e., not at a statical point in the program, or if not all elements
of an array are initialized together, this solution is not possible.
A null pointer can also be used as an ``error'' or ``escape'' value for function parameters or results. 

The main problem in both cases is that it must be possible to determine at runtime whether a value is null or not. So simply
allocating a ``dummy'' to get a valid non-null pointer is not sufficient, it must also be possible to recognize the dummy pointer.

One possibility for this is if there is a value referenced by the pointer which never occurs in normal execution,
it can be used to mark the pointer as dummy. 

Another possibility is to use a single dummy pointer for all values of a specific linear type which can be null and store it 
in a seperate place for comparing it. However, this cannot be done in Cogent since the dummy pointer would be a shared linear 
value. Even if implemened in C through abstract functions, to prove memory safety every access to such a value must 
be guarded with a test for the dummy pointer. Thus it is easier to actually use the null pointer instead of the dummy pointer,
in combination with a guard testing for the null pointer

Moreover using a dummy pointer is not binary compatible if the pointer is 
also accessed in external existing C code where it is set to \code{NULL} or tested for being \code{NULL}.

A straightforward approach for working with the null pointer uses polymorphic abstract functions
\begin{verbatim}
  null: all(a). () -> a
  ronull: all(a). () -> a!
  isNull: all(a). a! -> Bool
\end{verbatim}
To dispose the null pointer the function \code{dispose} must also check for the null pointer and ignore
invocations for it. The function \code{ronull} is required to create null values of readonly types. This cannot be done 
by applying the bang operator to the result of \code{null} since then the readonly null value
cannot escape the banged context. 

However, the polymorphic functions cannot be restricted to specific types \code{T} by Cogent, therefore all values of all
types must be assumed to be null and their use must be guarded by \code{isNull}.

If Gencot generates monomorphic functions \code{null\_T}, \code{ronull\_T}, \code{isNull\_T} only for linear types or a
specific subset of them, this approach is also not safe. The existence of the function \code{null\_T} makes it necessary to guard all accesses to values of type
\code{T} and \code{T!} with the help of \code{isNull\_T}. The existence of the function \code{ronull\_T} makes it necessary to guard
all accesses to values of type \code{T!}, the values of type \code{T} need not be guarded since a readonly value can never be 
made modifyable again. Cogent cannot detect cases where values which may be null are accessed without guard.
Therefore Gencot does not automatically define the functions for linear types \code{T}.

\subsubsection{The abstract data type \code{MayNull}}

A safer approach replaces type \code{T} by an abstract type and uses type \code{T} only in places where a value has been checked
for not being null. The abstract type must be specific for \code{T} and it must be complemented with abstract functions for
generating and testing the null pointer. Gencot provides the following generic abstract data type in \code{include/gencot/MayNull.cogent}.
It is available for all linear Cogent types, not only for types generated by Gencot by mapping a C pointer type.
\begin{verbatim}
  type MayNull a 
  null:      all(a). () -> MayNull a
  roNull:    all(a). () -> (MayNull a)!
  mayNull:   all(a). a -> MayNull a
  roMayNull: all(a). a! -> (MayNull a)!
  notNull:   all(a). MayNull a -> Option a
  roNotNull: all(a). (MayNull a)! -> (Option a)!
\end{verbatim}
The function \code{null} returns the null pointer, the function \code{mayNull} casts a non-null pointer of type \code{a}
to type \code{MayNull a}. The operations \code{roNull} and \code{roMayNull} do the same for readonly pointers. 

The type \code{Option} is used from the Cogent standard library. 
The function \code{notNull} returns \code{None} if the argument is null and \code{Some x} if the argument \code{x} is not null.
The function \code{roNotNull} does the same for a readonly argument. 
Since \code{notNull} and \code{roNotNull} are the only functions which make the value available as a value of type \code{a} 
it is guaranteed by the Cogent type constraints that all accesses to the value are guarded by one of these two functions. 

As usual,
the type parameter \code{a} cannot be restricted by Cogent to linear types. However, Gencot provides instances of the functions only for
linear types \code{a}.

Based on these functions the function
\begin{verbatim}
  isNull: all(a). (MayNull a)! -> Bool
  isNull mn = roNotNull mn | None -> True | Some x -> False
\end{verbatim}
is defined in Cogent for an explicit test for the null pointer.

\subsubsection{General Operations}

Values of type \code{MayNull a} cannot be created, disposed, initialized, or cleared. Either they are null, or they are pointers of
a valid-value pointer type, for which the type-specific functions for creating, initializing, cearing, and disposing are available.

The type constructors \code{ModFun}, \code{ModTypeFun}, and \code{ModPartFun} can be applied to \code{MayNull a} with the usual intended
semantics.

\subsubsection{Part Access Operations}

Conceptually, the type \code{MayNull a} can be seen as a structured value with the value referenced by the non-null pointer of type \code{a} being
an optional part. Then the operations for accessing parts of a structured value can be defined for \code{MayNull a} as follows
The operation \code{get} corresponds to \code{roNotNull}, the operation \code{access} corresponds to the
identity operation. Both operations are not provided separately. The other operations are provided
by the polymorphic functions
\begin{verbatim}
  setNotNull: all(a,ea,arg:<D). 
     ModFun (MayNull a) (a, ClrFun a ea arg, arg))
  exchngNull: all(a).
     (MayNull a,a) -> (MayNull a,a)
  modifyNull: all(a,arg:<D).
     ModPartFun (MayNull a) a arg
\end{verbatim}
Again, instances of the functions are only defined if \code{a} is a linear type.

The function \code{setNotNull (mn, (p,clrfun))} takes as input two pointers and a clearing function. The pointer \code{mn} may be null. 
If it is not null it is cleared using \code{clrfun} and disposed. The result is always \code{mayNull p}. Note that the input type is
structured in a way that the function's type is equivalent to \code{ModFun (MayNull a) (a, ClrFun a ea arg, arg)} so that the function can be used
as argument to a \code{ModPartFun}. The type \code{arg} of the additional input passed to the clearing function must be discardable, because
it is discarded if \code{mn} is not null. The type \code{ea} must be the empty-value type corresponding to the valid-value type \code{a}. This 
cannot be enforced by Cogent, but if the clearing function is correctly defined the type \code{ea} will be derived from it by Cogent.

The function \code{exchngNull (mn, p)} takes as input two pointers, one of which may be null. If \code{mn} is null the result is
\code{(mn,p)}, otherwise it is the pair of \code{mayNull p} and the non-null pointer corresponding to \code{mn}.

The function \code{modifyNull (mn, (modfun,addinput))} is a 
modification function according to the description of \code{ModPartFun} in Section~\ref{design-operations-concept} 
If \code{mn} is not null it modifies the object referenced by \code{mn} by applying the part modification function \code{modfun} of type 
\code{ModFun a arg} to \code{mn} and returns \code{mn}. Otherwise it returns the null pointer \code{mn}. The type \code{arg} of the additional input
must be discardable, because it is discarded, if \code{mn} is null.

Note that since the type \code{MayNull a} is not denoted by a single type name it is not possible to construct Cogent mappings of derived types for it, such
as a function type with a parameter of type \code{MayNull a}. This is correct, since the function would be polymorphic. If a Cogent type name 
is defined for a specific instance of \code{MayNull}, mappings of derived types for the instance can be constructed using this type name.

\subsection{Record Types}
\label{design-operations-record}

As described in Section~\ref{design-types-struct} C struct types are always mapped to Cogent record types, no other record types are generated by Gencot. 
Additional record types may be introduced manually in the translated Cogent program.

\subsubsection{Creating and Disposing Records}

The empty-value type corresponding to a record type \code{R} is the type \code{R take (..)} where all fields are taken.
Gencot defines in \code{include/gencot/Memory.cogent} the preprocessor macro 
\begin{verbatim}
  RECEMPTY(R)
\end{verbatim}
to specify the empty-value type for \code{R}. (It is implemented 
as preprocessor macro because, like \code{PTREMPTY}, it cannot be implemented as generic type in Cogent.)

For every record type \code{R} used in the Cogent program (not only those generated by mapping a C type) Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[RECEMPTY(R)]
  dispose[RECEMPTY(R)]
\end{verbatim}

\subsubsection{Modifying Records}

The type constructors \code{ModFun}, \code{ModTypeFun}, and \code{ModPartFun} can be applied to record types with the 
usual intended semantics. 

A specific kind of modification functions for records are functions which put or take a record field. 
Gencot defines macros in \code{include/gencot/ModFun.cogent} to generate the type of simple put and take operations for
record types.

A macro call of the form 
\begin{verbatim}
  PUTFUN(R,f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take f) R A
\end{verbatim}
for a function which puts field \code{f} in a record of type \code{R}. A macro call of the form
\begin{verbatim}
  TAKEFUN(R,f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun R (R take f) A
\end{verbatim}
for a function which takes field \code{f} in a record of type \code{R} (without returning the taken value).

A macro call of the form 
\begin{verbatim}
  PUTFUN<n>(R,(f1,...,fn),f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f,f1,...,fn)) (R take (f1,...,fn)) A
\end{verbatim}
for a function which puts field \code{f} while the fields \code{fi} are already taken. A macro call of the form
\begin{verbatim}
  TAKEFUN<n>(R,(f1,...,fn),f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f1,...,fn)) (R take (f,f1,...,fn)) A
\end{verbatim}
for a function which takes field \code{f} while the fields \code{fi} are already taken.

Gencot does not automatically define modification functions for record types, since a record can be modified using the
Cogent get and put operations for its fields. Only if a field of record type is modified through a modification function for its context, the record fields
must be manipulated using modification functions for the record. Then such operations must be defined manually.

\subsubsection{Initializing and Clearing Records}

Gencot defines in \code{include/gencot/Memory.cogent} the preprocessor macros
\begin{verbatim}
  RECINIFUN(R,AIT)
  RECCLRFUN(R,AIT)
\end{verbatim}
for the types of initialization and clearing functions for a record type \code{R} with additional input of type \code{AIT}.

Before a record returned by \code{create} can be used it must be initialized by putting values for all fields. 
Dually, before disposing a record it must be cleared by taking all fields.

Functions
for initializing and clearing a record \code{r} of type \code{R} can be defined in Cogent by putting or taking values 
into/from all fields.

Putting values into fields of primitive type is straightforward. For fields of a boxed record type \code{S} a value can be created 
using the function \code{create}, then applying an initialization function of type RECINIFUN(S) and putting the result into the field using the
Cogent put operation. For fields of a boxed abstract type it depends which abstract functions are available for creating and 
initializing values. Fields of type \code{MayNull a} can be initialized by putting \code{null()}. For fields of array type and Gencot
pointer type, instances of \code{create} are available and the type specific initialization functions described in 
Sections~\ref{design-operations-pointer} and~\ref{design-operations-array}.

Fields of a readonly boxed type \code{S!} cannot be initialized according to this schema. If a value is created in the 
initialization function for \code{r} it must be banged there but then it may not leave the banged context. The readonly value must be created
outside and then passed to a banged context. The initialization of \code{r}, its use and its clearing must all happen inside
this context. To support this, the initialization functions for type \code{R} must take as additional input a tuple of all
values to be used for readonly fields. A simpler solution is to use type \code{(MayNull S)!} instead for the field and 
put the value \code{roNull()} during initialization. Then a readonly non-null value can be set later in the corresponding
banged context. Fields of type \code{(MayNull a)!} can be initialized by putting \code{roNull()}.

A field \code{f} with an unboxed record type \code{\#S} corresponds to an embedded struct in C. The space for this struct is allocated together
with the space for \code{r} by function \code{create}, so it needs only to be initialized. The initialization should be possible by using
an initialization function of type \code{RECINIFUN(S,AIT)}.

The most natural way of initializing an embedded struct would be in-place using a pointer to the embedded struct as described
for operation \code{modify} in Section~\ref{design-operations-concept}. But \code{modify} takes as argument a value of type \code{R}
where no field is taken, so it cannot be used to put the taken field \code{f} into the record. Separate modification functions
are required for the record with taken fields. If the record contains several embedded structs every modification function
puts one field and the result type has one field less taken. Thus, defining such modification functions imposes an order
in which the embedded structs must be initialized and whether they are initialized before or after the other fields. A corresponding
modification function for field \code{f} which must be initialized before field \code{g} but after all other fields would be
\begin{verbatim}
  putFInR : PUTFUN1(R,(g),f,(RECINIFUN(S,AIT),AIT))
\end{verbatim}
It is invoked with the initialization function for the embedded record and its argument 
as additional information.

A more flexible way would be to use the Cogent put operation. However, for field \code{f} it needs a value of type 
\code{\#S} which is not produced by the initialization function. To bridge this gap we can use an abstract function
\begin{verbatim}
  deref : S -> #S
\end{verbatim}
which dereferences the argument pointer, and returns a copy of its content. Additionally it frees the pointer so that the
linear input value is safely disposed. (Note that the argument cannot be readonly to avoid freeing the pointer, since then
the result must also be readonly if it contains linear values.) Then the Cogent code to initialize the embedded struct 
\code{f} in a record \code{r} using the initialization function \code{init} with additional input \code{arg} would be
\begin{verbatim}
  r { f = deref (init (create (),arg)) }
\end{verbatim}
It is not as efficient as in-place initialization, since it allocates a struct of type \code{S} on the heap, initializes it,
copies it to the embedded struct \code{f} and deallocates it.

Since both ways may be useful in certain contexts Gencot does not generate one or both of them, they must be provided manually.

Another approach could be that the function \code{create[RECEMPTY(R)]} returns a value where only the fields of primitive and linear type
are taken and the embedded structs are present, but again with all primitive and linear fields taken. Then the initialization function for
field \code{f} could be directly applied to a pointer to field \code{f}. However, it is still necessary to retrieve the pointer to \code{f}
with the help of an abstract function which now has to respect the fact that other embedded record fields have types with
some fields taken. So the same number of additional abstract functions is needed as in the approach above and their argument
types are of similar complexity.

Fields of an unboxed abstract type are created by Gencot only in the case of arrays and function pointers (see 
Section~\ref{design-types-array} and~\ref{design-types-function}). Initializing an embedded array field \code{f} of type 
\code{\#UA'<size>'\_El} can be done in-place or separate like an embedded record field. In the first case an abstract
function of the form 
\begin{verbatim}
  putFInR : PUTFUN1(R,(g),f,(ARRINIFUN(A'<size>'_El,AIT),AIT))
\end{verbatim}
is required which uses an array initialization function and puts \code{f} while field \code{g} is still taken. 
In the second case an abstract function of the form
\begin{verbatim}
  deref : A'<size>'_El -> #UA'<size>'_El
\end{verbatim}
is required which copies the array content and frees the array on the heap.

Initializing a field \code{f} of a function pointer type \code{\#F\_...} can always be done using the Cogent put operation.
The value to be put must be constructed using the function \code{to\_F\_...} (see Section~\ref{design-types-function}). To
avoid null pointers to functions, as described in Section~\ref{app-trans-funpointer}, a dummy function should be defined in
Cogent and passed to the \code{to\_F\_...} function.

In a clearing function for a record all content shall be discarded. For fields of primitive and readonly type this is
straightforward by using the Cogent take operation and ignoring the taken value. For fields of linear type the taken value
cannot be simply discarded, it needs special treatment.

For a field of a boxed type \code{S} the taken value must be disposed by applying the function \code{dispose}.
For a field of type
\code{MayNull S} the value must be tested whether it is null, otherwise the function \code{dispose} must be applied. In
all these cases a clearing function for type \code{S} must be applied first, so that the dispose-function is applicable.

A field of unboxed record type \code{\#S} is linear, if the embedded record contains linear fields. During clearing these must be
disposed. This can be achieved by applying a clearing function for type \code{S} before taking the field. Dually to the 
initialization of an embedded record this can be done in-place or using a copy. The in-place approach requires an abstract
function of the form
\begin{verbatim}
  takeFInR : TAKEFUN1(R,(g),f,(RECCLRFUN(S,AIT),AIT))
\end{verbatim}
which applies a clearing function of type \code{RECCLRFUN(S,AIT)} and takes the field \code{f} while field \code{g} is already taken.
The other approach requires an abstract function 
\begin{verbatim}
  refer : #S -> S
\end{verbatim}
which allocates an object on the heap and stores the content of its argument into it. Then field \code{f} can be taken, the taken
value passed to \code{refer}, and a clearing function applied to its result, before it is disposed.

A field of an unboxed abstract type is never linear, so the field can always be taken and the taken value discarded.
However, if the C implementation of the abstract type contains pointers, they must be deallocated. This can be achieved by
applying a clearing function in the same way as for an unboxed record field with the help of an abstract function
\code{takeFInR} or \code{refer}.

\subsubsection{Accessing Record Fields}

The parts of a record are its fields. The conceptual operations for accessing parts of a structured value can be defined for a record type 
\code{R} as follows.

The field to be accessed by the operation must be specified by its name. This can only be done as part of the function name.
Therefore Gencot does not define polymorphic functions for accessing the fields of arbitrary record types. For every record type
\code{R} a set of differently named functions must be defined for every field \code{f}. Since only some of the functions are needed, Gencot
does not automatically generate such functions, they must be defined manually, if required.

The operation \code{get} for a field \code{f} of a record \code{r} corresponds to the Cogent member access operation \code{r.f}.
Since the \code{get} operation is not passed as argument to other functions, it need not be defined for record fields, it is always possible
to use the Cogent member access operation instead.

The operation \code{set} for a field \code{f} of a record \code{r} and a value \code{v} corresponds to the Cogent put operation r{f = v}, if
the field has a nonlinear type. Otherwise it must first take the old value, clear it and dispose it. All these operations can be impleented in Cogent.

The operation \code{exchng} for a field \code{f} of a record \code{r} and a value \code{v} can be implemented in Cogent by first taking the 
old value of \code{f}, then putting \code{v} and finally returning the record together with the old value.

The operations \code{access} and \code{modify} cannot be implemented in Cogent, they must be defined as abstract function which are implemented in 
C with the help of the address operator \code{\&}. For a field \code{f} of type \code{S} the corresponding function definitions have the form
\begin{verbatim}
  accessFInR : R! -> PS!
  modifyFInR : all(arg). ModPartFun R PS arg
\end{verbatim}
where \code{PS} is the Gencot mapping of the type of pointer to \code{S}.

\subsection{Array Types}
\label{design-operations-array}

The abstract types generated for arrays with known size are complemented by Gencot by abstract polymorphic 
functions for working with
arrays. For these functions Gencot automatically generates the instance 
implementations in C. All these implementations involve the array size in some way. The developer may manually introduce
other array types by adhering to the Gencot naming schema for array types. Then Gencot also supports these types and
generates instances of all polymorphic functions for them.

If the array size is unknown (types of the form \code{A\_El}) or too complex (types of the form \code{A''\_El})
no instances of the polymorphic functions are provided by Gencot. However, implementations may be provided manually. Often
this is possible by the developer determining the array size from the context. If several array types with 
different unknown sizes have been mapped to the same abstract type, they must be disambiguished manually.

Gencot only supports arrays which are allocated on the heap. In C, arrays can also be introduced by defining
them as global or local variable, but Cogent has no language constructs which support this.

\subsubsection{Creating and Disposing Arrays}

Gencot represents array values in Cogent always by an abstract type of the form \code{A'<size>'...}.
Hence Cogent does not provide a language construct to create such values. 

The empty-value type corresponding to type \code{A'<size>'...} is the abstract type \code{TA'<size>'...} which
is automatically generated by Gencot. It has a similar meaning as a Cogent
record with all fields taken. It statically marks the array as uninitialized. It is mapped to the same C 
type as \code{A'<size>'...}.

Gencot defines in \code{include/gencot/Memory.cogent} the preprocessor macro 
\begin{verbatim}
  ARREMPTY(A...)
\end{verbatim}
to specify the empty-value type for an array type \code{A...}.

For every array type \code{A...} used in the Cogent program (not only those generated by mapping a C type) Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[ARREMPTY(A...)]
  dispose[ARREMPTY(A...)]
\end{verbatim}

Both functions also support multidimensional array types of the form \code{A'<size>'UA'<size>'...\_El}.

\subsubsection{Modifying Arrays}

Since array types are always abstract, all modifications of array values must be performed using abstract functions.

The type constructors \code{ModFun}, \code{ModTypeFun}, and \code{ModPartFun} can be applied to array types with the 
usual intended semantics. 

Gencot provides no equivalent for the Cogent take and put operations for array elements. It would be
necessary to statically encode the set of array indices for which the elements have been taken in the type expression,
this is not feasible.

\subsubsection{Initializing and Clearing Arrays}

An array initialization function sets a valid value for every element. An array clearing function clears every element, 
clearing and disposing all linear values contained in elements. Since all elements are of the same type, they can all be
treated in the same way by an initialization or clearing function for the element type. Initializing and clearing an element
can be done ``in-place'' by passing a pointer to the element to the element initialization or clearing function. As usual,
an additional input given to the array function is passed through to every invocation of the element function. 

It could be useful to also know the element index in the element function. This could by supported by passing the index
as additional input to the elemet functions. However, this implies that the normal initialization and clearing functions
for the element type cannot be used as element functions here, since they do not expect the index as additional input.
Therefore the functions automatically supported by Gencot for initializing and clearing array do not pass the index 
to the element functions. If needed, such functions can be defined manually.

Gencot defines generic types for array initialization and clearing functions in \code{include/gencot/Memory.cogent}:
\begin{verbatim}
  type ArrIniFun evt vvt epe vpe arg =
    IniFun evt vvt (IniFun epe vpe arg, arg)
  type ArrClrFun vvt evt vpe epe arg =
    ClrFun vvt evt (ClrFun vpe epe arg, arg)
\end{verbatim}
where \code{evt} is the empty-value array type, \code{vvt} is the valid-value array type, \code{epe} is the empty-value
element pointer type and \code{vpe} is the valid-value element pointer type. \code{arg}
is the type of the additional input for the element function. All types besides \code{arg} are uniquely determined by the 
array type \code{vvt}, although this cannot be expressed by Cogent type constraints. Therefore Gencot  defines in 
\code{include/gencot/Memory.cogent} the preprocessor macros
\begin{verbatim}
  ARRINIFUN(size,k,EL,AIT)
  ARRCLRFUN(size,k,EL,AIT)
\end{verbatim}
for the types of initialization and clearing functions for an array type \code{A} with additional input of type \code{AIT}.
The array type \code{A} is determined by the number of elements \code{size} and the element type 
\code{EL}. The additional parameter \code{k} specifies the kind of the element type. It may be empty for a primitive type,
\code{F} for a function pointer type, \code{R} for a boxed record type, \code{U} for an unboxed record type, or \code{P} for 
all other pointer types. 

For example the macro call \code{ARRINIFUN(16,,U32,())} expands to the initialization function type
\begin{verbatim}
  IniFun TA'16'_U32 A'16'_U32 TP_U32 P_U32 ()
\end{verbatim}
and the macro call \code{ARRCLRFUN(300,U,R,Arg)} expands to the clearing function type
\begin{verbatim}
  ClrFun A'300'U_R TA'300'U_R R (R take (..)) Arg
\end{verbatim}

Gencot defines the polymorphic functions
\begin{verbatim}
  initArr: all(evt,vvt,epe,vpe,arg:<S). 
     ArrIniFun evt vvt epe vpe arg
  clearArr: all(vvt,evt,vpe,epe,arg:<S). 
     ArrClrFun evt vvt epe vpe arg
\end{verbatim}
Since the additional input of type \code{arg} is passed to every invocation of the initialization or clearing function
it must be sharable.
By using these functions with an explicit type specified by one of the macros above the Cogent type checker can be employd 
for checking the type consistency of the function use.

For example an array \code{a} of type \code{TA'16'\_U32} can be initialized by setting all elements to \code{5} with typechecks by 
the Cogent expression
\begin{verbatim}
  initArr[ARRINIFUN(16,,U32,())] (a,(initPtr,5))
\end{verbatim}

Gencot provides instances of these functions also for multidimensional array types of the form \code{A'<size>'UA'<size>'...\_El}.

\subsubsection{Accessing Array Elements}

If an array is seen as a structured value, its elements are its parts.
Then all operations for accessing parts of a structured value are nontrivial. Since elements are specified by an index value
Gencot provides polymorphic functions for all five operations
\begin{verbatim}
  getArr : all(arr,idx,el). (arr!,idx) -> Option el!
  setArr : all(arr,idx,el:<D). (arr,idx,el) -> arr
  exchgArr : all(arr,idx,el). (arr,idx,el) -> (arr,el)
  accessArr : all(arr,idx). (arr!,idx) -> Option pel!
  modifyArr : all(arr,idx,pel,arg:<D). 
    ModFun arr (idx,(el,arg)->el,arg)
\end{verbatim}
The type variable \code{arr} denotes the array type, \code{idx} denotes the index type,
\code{el} denotes the array element type, and \code{pel} denotes the type of pointers to elements. 
The result type of \code{getArr} uses the generic type \code{Option} defined in
the Cogent standard library. All functions take the element index as second argument.

Instances of these functions are only defined if \code{arr} is a Gencot pointer type. Type \code{idx}
must be one of \code{U8, U16, U32} according to the \code{<size>} of the array. Types \code{el} and
\code{pel} must be as determined by \code{arr}. \code{arg} may be an arbitrary type.

Function \code{getArr} retrieves the indexed element as readonly. If the specified index 
is not in the range \code{0..<size>-1} the function returns \code{None}.

Function \code{setArr} is only defined for a discardable element type. 
It simply discards the old value of the indexed element and sets it to the specified value.
If the specified index is not in the range \code{0..<size>-1} the function returns the unmodified array.

Function \code{exchgArr}
replaces the element at the specified position by the element passed as parameter and returns the old element in the result.
If the specified
index is not in the range \code{0..<size>-1} the function returns the same element which has been
passed as input, together with the unmodified array. 

Function \code{accessArr} returns a pointer to the element in the array without copying the element. This is safe since 
both the array and the result
type are readonly. If the specified index is not in the range \code{0..<size>-1} the function returns \code{None}. 

Function \code{modifyArr} modifies the element at the specified position in-place by applying the element modification function,
which is passed as the third parameter, to a pointer to the element. 
If the specified
index is not in the range \code{0..<size>-1} the function returns the unmodified array. Since in this case the 
additional input to the modification function is discarded, its type \code{arg} must be discardable.

The type of \code{modifyArr} is similar to a \code{ModPartFun}, but it differs because in addition to the element modification 
function and its argument the element index must be passed as argument.
Note that it is not possible
to pass the array or parts of it as additional information in the parameter of type \code{a}, since that would always be
a second use of the array of linear type. If several elements must be modified together, a specific modification function
must be defined and used instead of \code{modifyArr}.

Gencot does not provide instances of these functions for multidimensional array types of the form \code{A'<size>'UA'<size>'...\_El}.

