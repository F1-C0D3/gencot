\documentclass[a4paper]{report}
\usepackage[bookmarks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % needed for italic curly braces

\newcommand{\code}[1]{\textnormal{\texttt{#1}}}

\begin{document}

\title{Gencot User Manual}
\author{Gunnar Teege}

\maketitle

\chapter{Introduction}

Gencot (GENerating COgent Toolset) is a set of tools for generating Cogent code from C code. 

Gencot is used for parsing the C sources and generating Cogent sources, 
antiquoted C sources, and auxiliary C code. It does not perform a fully automatic translation, it is
intended to be used in combination with several manual steps of pre- and post-processing. These
steps are described in this manual.

The manual assumes that you are familiar with C and Cogent and know how to work with both.

\section{Rationale}
\label{intro-rationale}

Normally, Cogent is intended to implement from scratch a program which both compiles to a C implementation
and can be used as a high-level specification for formally verifying semantic properties.
Cogent generates a formal proof that the C implementation is a refinement of the high-level specification,
thus all proven semantic properties also hold for the C implementation.

Gencot is intended for the case where there already exists a legacy C implementation for a task. To apply
Cogent as described above, the task must be re-implemented in Cogent. Gencot supports this re-implementation 
by translating most parts of the legacy C program to Cogent code. This should help developers
to produce the re-implementation, especially if they have more experience in C programming than in Cogent.

However, Gencot does not provide the following:
\begin{itemize}
\item a guarantee, that the translation to Cogent is equivalent to the legacy C program. There is no formal
proof for such an equivalence and Gencot itself is not verified. Also, parts of the re-implementation may
require manual intervention, so no automatic evidence can be provided.

If you are lucky, there is a test suite for the legacy C program. Then you can apply the test suite to the 
Cogent re-implementation and get some evidence, that there is no difference in relevant behaviors. Even if
there is no test suite, building on the legacy C program should be easier and faster than to begin a
re-implementation from scratch. In any case, the formal verification starts at the Cogent program and does not 
extend to the legacy C program.

\item a guarantee that the translation to Cogent is type-safe and respects the constraints of the uniqueness
type system. Gencot translates the types as they are specified in the C program. It maps some memory safety
properties to the Cogent type system, but it does not make unsafe parts safe. In particular, if the legacy
C program shares and discards pointers, so will the translation to Cogent. 

The advantage is that the Cogent typechecker will statically detect all theses cases and signal them as an
error, so that the developer can concentrate on them. The Cogent program or the original C program must then be
refactored to avoid such cases, until the Cogent program  can be successfully processed by the Cogent compiler.

\item a guarantee that the translation to Cogent is useful for formally verifying the desired semantic properties. 
The Cogent program generated by Gencot has the same overall structure as the legacy C program. If this structure
is not adequate for formal proofs, e.g., because it massively depends on reading and modifying a global state,
the generated Cogent program (or the legacy C program) must be refactored to better support formal verification.
\end{itemize}

\section{Gencot Distribution}
\label{intro-dist}

The Gencot distribution consists of the following folders:
\begin{description}
\item[manual] this manual,
\item[bin] the main command scripts \code{gencot}, \code{auxcog}, \code{items}, and \code{parmod} and many auxiliary commands used by them,
\item[include] Cogent include files used by the generated code,
\item[c] C code implementing abstract types and functions used by the generated code,
\item[examples] example C programs used in this manual for introducing Gencot,
\item[src] the Haskell source code of Gencot components,
\item[doc] a comprehensive documentation of Gencot design and implementation.
\end{description}

Gencot is a command line tool. To use it make sure that you can invoke the commands \code{gencot}, \code{auxcog},
\code{parmod}, and \code{items} (e.g., by linking them in a folder in your command path or by adding the \code{bin} folder
of the Gencot distribution to your command path).

Additionally you have to set the environment variable \code{\$GENCOT\_HOME} to the root folder of the Gencot
distribution.

We also assume that you have a working distribution of Cogent and can invoke the cogent compiler using the
command \code{cogent}.

All example folders contain a UNIX Makefile. You can either run the examples by manually typing the commands
to process them or by using \code{make} with a separate target for each step.

\section{First Encounter}
\label{intro-first}

As usual we will start with a ``Hello World'' example. Go to \code{examples/helloworld}. Ignoring the other files,
look at \code{hello.c}. It contains the C program
\begin{verbatim}
  #include <stdio.h>

  int main() {
    puts("Hello World");
  }
\end{verbatim}

\begin{description}
\item[Step 1:] (make run)

Try it: compile the program with a C compiler, name it \code{hello} and run it. It should do what you expect.

\item[Step 2:] (make cogent)

Prepare the use of Gencot by executing the command
\begin{verbatim}
  items used
\end{verbatim}

Now use Gencot to translate the program to Cogent. Enter the command
\begin{verbatim}
  gencot cfile hello.c
\end{verbatim}
It creates the file \code{hello.cogent}. Look at it. It contains
\begin{verbatim}
  cogent_main : SysState -> ( U32, SysState )
  cogent_main io =
     (0
     , let (_
           , io) = cogent_puts ("Hello World"
                               , io)
     in io)
\end{verbatim}
This is a Cogent function corresponding to the C function \code{main}.

The command also creates the file \code{hello-entry.ac}. It contains a replacement for the original \code{main}
function, implemented in C with embedded Cogent code (``antiquoted C''). It simply invokes the function
\code{cogent\_main}.

Next enter the command
\begin{verbatim}
  gencot unit
\end{verbatim}
It creates the file \code{all.cogent} and three files \code{all-externs.cogent}, \code{all-exttypes.cogent}, 
and \code{all-dvdtypes.cogent} where the latter two are empty and can be ignored for this example. File 
\code{all-externs.cogent} contains
\begin{verbatim}
  cogent_puts : ( String, SysState ) -> ( U32, SysState )
\end{verbatim}
which is also valid Cogent code and declares \code{cogent\_puts} as an abstract function. That makes it possible
to invoke it by Cogent code in \code{cogent\_main}, although it is not implemented in Cogent. File \code{all.cogent}
includes all generated Cogent files and is the main source file to be processed by the Cogent compiler.

The command also creates the file \code{all-externs.ac} (Not yet implemented! Provided with the example). It contains
an implementation of \code{cogent\_puts} in antiquoted C which simply invokes the C function \code{puts}.

\item[Step 3:] (make c)

To see that it works, process \code{all.cogent} by the Cogent compiler. Enter the command
\begin{verbatim}
  cogent -o all-gen -g all.cogent \
      --infer-c-funcs="all-externs.ac hello-entry.ac" \
\end{verbatim}
% use \textquotesingle here to allow copy-paste it to a shell.
% The ' in verbatim is mapped to \textquoteright instead.
\vspace*{-4mm}\hspace*{11mm}\code{-{}-cpp-args=\textquotesingle -x c \$CPPIN -o \$CPPOUT -P\textquotesingle}

\vspace*{4mm}\noindent
The last line is required for some implementations of the C preprocessor \code{cpp}, depending on the \code{cpp} in your
system it may be possible to omit it.

The command creates the files \code{all-gen.c} and \code{all-gen.h} and two \code{\_pp\_inferred.c} files generated from
the \code{.ac} files. 

Gencot is required to perform some postprocessing steps. Enter the command
\begin{verbatim}
  auxcog -I. unit
\end{verbatim}
It creates the file \code{all.c} which includes \code{all-gen.c} and other files generated by \code{auxcog}. It wraps together
the C program generated from the Cogent program by the Cogent compiler and the Gencot postprocessing step. Additionally
it creates \code{hello-entry.c} and \code{all-externs.c} from the \code{\_pp\_inferred.c} files and also includes them
into \code{all.c}. Additionally, \code{all.c} includes the files \code{all-gencot.h} and \code{all-cogent-common.c} which
are also provided by \code{auxcog} in the current directory.

\item[Step 4:] (make cogent-run)

Try whether it still works. Compile \code{all.c} with a C compiler, setting the include path to the current directory,
name the compilation result \code{cogent-hello} and run it, for example using the commands
\begin{verbatim}
  cc -o cogent-hello -I. all.c
  ./cogent-hello
\end{verbatim}
The result should be the same as in Step 1.

\item[Step 5:] (make clean)

Clean up all generated files. If you like you can perform the steps again.
\end{description}

\chapter{C Program Structure}
\label{struct}

\section{Single Source File}
\label{struct-single}

The simplest case is a C program which consists of a single \code{.c} file, such as the ``Hello World'' program
introduced in Section~\ref{intro-first}. If the C file is named \code{foo.c} the command to process it by Gencot is
\begin{verbatim}
  gencot cfile foo.c
\end{verbatim}
It creates the following files:
\begin{description}
\item[\code{foo.cogent}] The content of \code{foo.c} translated to Cogent.
\item[\code{foo-entry.ac}] ``Entry wrapper'' functions for all functions defined in \code{foo.c} 
with external linkage.
\end{description}

An ``entry wrapper'' converts from the original C function API to the Cogent function API, which is usually different 
since Cogent functions always take one argument and return one value. Functions in \code{foo.cogent} are automatically
renamed so that they do not collide with the entry wrappers after translation back to C by Cogent. For a standalone
C program there is atleast an entry wrapper \code{main} for the translated main program. Using the entry wrappers, all
translated C functions can still be invoked from a C program according to their original API.

Additionally, Gencot must be invoked using the command
\begin{verbatim}
  gencot unit
\end{verbatim}
It reads the file \code{all.unit} which must contain the name of the C source file (\code{"foo.c"}) in a single line. 
It creates the following files:
\begin{description}
\item[\code{all-externs.cogent}] Abstract definitions of all external functions used by the C program.
\item[\code{all-exttypes.cogent}] Type definitions for all external types used by the C program.
\item[\code{all-dvdtypes.cogent}] Type definitions for all derived types used in the C program.
\item[\code{all-externs.ac}] (*Not yet implemented*) ``Exit wrapper'' functions for all functions defined in 
\code{all-externs.cogent}.
\item[\code{all.cogent}] The main Cogent source file which includes all other Cogent sources.
\end{description}
An external function is used by the C program if it is actually invoked. Such functions must be declared in C, usually
the declarations are contained in standard include files. In the ``Hello World'' example the file \code{hello.c} includes
\code{stdio.h} where function \code{puts} is declared. Here, Gencot reads \code{stdio.h} to generate the abstract definition for
\code{gencot\_puts} and the corresponding exit wrapper. Although there are many functions declared in \code{stdio.h}, Gencot
does not generate definitions for them, since they are not invoked by the C program.

An external type is a type defined in a standard include file. Again, Gencot provides a Cogent type definition in 
\code{all-exttypes.cogent} for only those types which are actually used by the C program. 

The external functions and types used by the C program are determined seperately using the command
\begin{verbatim}
  items used
\end{verbatim}
It creates the file \code{all-external.items} which is read by most other Gencot commands. Therefore it should be executed
before any other command is issued to make the file available.

A derived type is a pointer type, an array type, or a function type in C. For 
some of them Gencot generates auxiliary type definitions in \code{all-dvdtypes.cogent}. In the ``Hello World'' example 
both files are empty.

An ``exit wrapper'' is similar to an ``entry wrapper'', it converts from the Cogent function API back to the C function API.
Exit wrappers are also renamed so that they do not collide with the originally invoked C function.

All generated files are named using the ``unit name'' \code{all}. A different unit name may be specified with the option 
\code{-u} for the \code{gencot} command (and also the \code{items} command), such as in
\begin{verbatim}
  gencot -u other unit
\end{verbatim}
Then it reads the file \code{other.unit} and creates files \code{other.cogent}, \code{other-externs.cogent}, 
\code{other-exttypes.cogent} etc.

\section{Single Source File with Include Files}
\label{struct-include}

Often, a C program consists of a \code{.c} file with function definitions and an included \code{.h} file for data type 
definitions. In this case Gencot must additionally be invoked for translating the \code{.h} file in the form
\begin{verbatim}
  gencot hfile foo.h
\end{verbatim}
It will create the additional file \code{foo-incl.cogent} which contains the translated content of \code{foo.h}. The 
include directive in \code{foo.c} will automatically be adapted, so that \code{foo.cogent} includes \code{foo-incl.cogent}.
So the resulting Cogent program has a similar source file structure as the C program.

If there are several \code{.h} files included by the \code{.c} file gencot must be invoked for every \code{.h} file
separately.

The other files are translated as before, however, the path must be specified where to look for the included files, even
if they are in the same directory. It is specified with an option \code{-I} as for \code{cpp}. Several such options may 
be specified if included files are in different directories. Include paths may be specified relative to the current 
directory. Do not append a slash \code{/} at the end. Paths for system include files cannot be specified, the \code{cpp} 
default is used for accessing them.

Together, the commands for translating the C program are
\begin{verbatim}
  items -I. used
  gencot hfile foo.h
  ... <other .h files> ...
  gencot -I. cfile foo.c
  gencot -I. unit
\end{verbatim}
where \code{all.unit} still contains only the name \code{foo.c} and not \code{foo.h} (because that is automatically
read together with \code{foo.c} which includes it).

\subsection{Example}

The example program in \code{examples/cards} consists of the file \code{cards.c} and the included files \code{cards.h}
and \code{rank.h}. The translation step (\code{make cogent}) corresponds to the commands
\begin{verbatim}
  items -I. used
  gencot hfile cards.h
  gencot hfile rank.h
  gencot -I. cfile cards.c
  gencot -I. unit
\end{verbatim}

Note that the function declarations in the \code{.h} files are not translated to Cogent. However, the comments specified 
there are moved to the function definitions in the translation of the \code{.c} file. This feature depends on the order of
processing the \code{.h} files before the \code{.c} file. Otherwise, the ordering of the commands is irrelevant.

The resulting files are \code{cards-incl.cogent}, \code{rank-incl.cogent}, and \code{cards.cogent} as translations of the
C source files and the files \code{all.cogent} and \code{all-externs.cogent} together with the empty files \code{all-exttype.cogent}
and \code{all-dvdtypes.cogent}. The translation step to C \code{make c} applies the Cogent compiler to \code{all.cogent},
the execution step \code{make run-cogent} compiles the resulting C program and runs it, it should have the same effect
as running the original C program by step \code{make run}.

\section{Multiple Source Files}
\label{struct-multi}

A larger C program often consists of several \code{.c} files. Every \code{.c} file is a separate translation unit and
must be translated by the C compiler to a seperate \code{.o} file. The \code{.o} files are then linked together to
yield the executable program binary.

To process such a program by Gencot every \code{.c} file must be processed on its own in the form
\begin{verbatim}
  gencot -I. cfile foo.c
\end{verbatim}
and yields a separate Cogent source file \code{foo.cogent}. All these translations together comprise a single
Cogent program which is compiled by the Cogent compiler in a single step and results in a single C compilation unit.

The file \code{all.unit} read by \code{gencot unit} must now contain the names of all \code{.c} files, each in a 
separate line.

Together, the commands for translating the C program are
\begin{verbatim}
  items -I. used
  gencot hfile foo.h
  ... <other .h files> ...
  gencot -I. cfile foo.c
  ... <other .c files> ...
  gencot -I. unit
\end{verbatim}
The generated file \code{all.cogent} includes all translations of \code{.c} files. As before, it is the 
file to be processed by the Cogent compiler.

\subsection{Example}

In the example program in \code{examples/cards2} the contents of \code{card.c} from \code{examples/cards} has been 
distributed to the three files \code{main.c}, \code{cards.c} and \code{rank.c}, which are listed in \code{all.unit}.
The translation step (\code{make cogent}) corresponds to the commands
\begin{verbatim}
  items -I. used
  gencot hfile cards.h
  gencot hfile rank.h
  gencot -I. cfile cards.c
  gencot -I. cfile rank.c
  gencot -I. cfile main.c
  gencot -I. unit
\end{verbatim}
The resulting file \code{all.cogent} includes all three Cogent sources \code{cards.cogent}, \code{rank.cogent}, and
\code{main.cogent}.

The entry wrappers are now distributed in the same way to the three files \code{cards-entry.ac}, \code{rank-entry.ac},
and \code{main-entry.ac}. All three must be specified now for the option
\code{--infer-c-funcs} in the Cogent compilation step (\code{make c}) and are included by the final C source
\code{all.c}.

\section{Partial Translation}
\label{struct-partial}

Gencot supports partially translating a C program to Cogent, if the C program consists of multiple \code{.c} source
files. In this case, some of the \code{.c} files are translated to Cogent and together yield a syntactically complete 
Cogent program. When translated back by the Cogent compiler it results in a single C compilation unit, which must be
linked with the remaining \code{.c} files to be executed.

In this way it is possible to incrementally translate a large C program to Cogent, starting with a single \code{.c} 
source and then extending it to more and more \code{.c} files until eventually all \code{.c} files have been translated.
At every intermediate step the program should still be executable after processing the translated part with the Cogent
compiler and can be tested whether it still behaves in the same way as the original C program.

To partially translate a C program, proceed as before, but put into \code{all.unit} only the names of those \code{.c}
files which shall be translated. You need only translate those \code{.h} files which are (directly or transitively)
included by the translated \code{.c} files. 

For a partially translated C program Gencot generates entry wrappers only for the translated functions, but it now
generates exit wrappers for all functions in the remaining \code{.c} files which are invoked from the translated functions.
In this way function invocations between the translated part and the remaining part are supported in both directions.
Additionally, Gencot translates all data types in a binary compatible way (not yet implemented for structs! requires Dargent 
or modification of Cogent), so that data can be passed back and forth between the translated and remaining part.

\subsection{Example}

The example program in \code{examples/cards2} can be partially translated by applying Gencot only to the files \code{main.c}
and \code{rank.c} and using the resulting Cogent program together with the original \code{cards.c}. The example provides
the file \code{part.unit} with the content
\begin{verbatim}
  rank.c
  main.c
\end{verbatim}
To work with this file instead of \code{all.unit} explicitly specify the unit name \code{part} in all commands.

The partial translation step (\code{make UNIT=part cogent}) corresponds to the commands
\begin{verbatim}
  items -I. -u part used
  gencot -u part hfile cards.h
  gencot -u part hfile rank.h
  gencot -I. -u part cfile rank.c
  gencot -I. -u part cfile main.c
  gencot -I. -u part unit
\end{verbatim}
The resulting file \code{part.cogent} includes only the Cogent sources \code{rank.cogent}, and
\code{main.cogent}. Note that you still have to translate \code{cards.h} because it is also included by \code{main.c}.

To execute the partially translated program, first edit the Cogent files (\code{make UNIT=part edit}) so that they contain
the following Cogent code:
\begin{verbatim}
rank.cogent:
  #include "rank-incl.cogent"

  cogent_ranking_to_string : Cogent_hand_ranking_t -> String
  cogent_ranking_to_string r =
    if r == cogent_STRAIGHT_FLUSH then "STRAIGHT_FLUSH" else
    if r == cogent_FOUR_OF_A_KIND then "FOUR_OF_A_KIND" else
    if r == cogent_FULL_HOUSE then "FULL_HOUSE" else
    if r == cogent_FLUSH then "FLUSH" else
    if r == cogent_STRAIGHT then "STRAIGHT" else
    if r == cogent_THREE_OF_A_KIND then "THREE_OF_A_KIND" else
    if r == cogent_TWO_PAIR then "TWO_PAIR" else
    if r == cogent_PAIR then "PAIR" else
    if r == cogent_NOTHING then "NOTHING" else
    "Invalid"
\end{verbatim}

\begin{verbatim}
main.cogent:
  #include "cards-incl.cogent"
  #include "rank-incl.cogent"

  cogent_main : () -> U32
  cogent_main () =
    cogent_puts("Just a test:");
    cogent_print_card(cogent_card_from_num(42));
    cogent_puts("  is card no 42");
    cogent_print_card(cogent_card_from_letters('Q', 'd'));
    cogent_puts("  is diamonds queen");
    0
\end{verbatim}

Then compile and postprocess the Cogent program (\code{make UNIT=part c}):
\begin{verbatim}
  cogent -o part-gen -g part.cogent \
     --cogent-pp-args="-I$GENCOT_HOME/include" \
     --infer-c-funcs="part-externs.ac main-entry.ac rank-entry.ac"
  auxcog -u part unit
\end{verbatim}

Compile the resulting C program \code{part.c} with the C compiler to yield \code{part.o},
compile the original \code{cards.c} to yield \code{cards.o}, and link both files to the binary
\code{cogent-cards} (\code{make UNIT=part cogent-binary}). When executing this binary it should
behave like the original C program.

\chapter{Translation of Types}
\label{types}

Gencot is able to translate most C types to a corresponding Cogent type. In this chapter we will look at the way 
how Gencot does this.

The goal of Gencot is to translate C types to ``binary compatible'' Cogent types. This means, if the type is 
translated back to C by the Cogent compiler, it must have the same memory layout. This property is required
for partial translation (see Section~\ref{struct-partial}): it must be possible to pass values between 
translated Cogent parts and original C parts at runtime without need for conversion.

\section{Automatic Type Translation}
\label{types-auto}

For every C type Gencot has a basic way how to automatically translate it to a binary compatible Cogent type. 

\subsection{Example}
\label{types-auto-example}

To get a first impression, go to \code{examples/types}. The file \code{types.c} contains example type definitions
for several different kinds of C types. Use Gencot to translate this file, as described in Section~\ref{struct-single} 
(\code{make cogent}):
\begin{verbatim}
  items used
  gencot cfile types.c
  gencot unit
\end{verbatim}

Now look at the generated file \code{types.cogent}. For every C type definition in \code{types.c} it contains 
a Cogent type definition where the type expression on the right-hand side is the translation of the original C type.

\subsection{Direct Types}
\label{types-auto-direct}

A C type is called a ``direct type'', if it is primitive, or an enumeration, a struct or a unit type.

As you can see from the examples, primitive C types are directly translated to primitive Cogent types, if they are
integral types. For floating point types an error specification is generated which is not a syntactically valid 
Cogent type and will be signaled as an error by the Cogent compiler. Floating point types must be translated manually
by the developer.

Note that Gencot generates Cogent type names of the form \code{Cogent\_<name>} where \code{<name>} is the ``typedef
name'' used in C. 

Enumeration types are always translated to type \code{U32}. According to the C standard, enumeration types are always
equivalent to type \code{int}, irrespective how many values are declared for them. Gencot additionally introduces
a Cogent constant for every declared enumeration value. If the enum type has a tag, Gencot introduces an additional
type alias of the form \code{Enum\_Cogent\_<tag>}.

Structure types are translated to Cogent record types. If the struct type has a tag, Gencot introduces a type alias
of the form \code{Struct\_Cogent\_<tag>}. For an anonymous struct (without a tag), Gencot instead introduces a type alias
of the form \code{Struct<line>\_<file>} using the line number and source file name where the struct definition occurs.

Although the struct type corresponds to an unboxed record type in Cogent, the type definition defines an alias for the 
boxed record type instead. The unbox operator is applied to all \textit{references} to the type alias, as you can see 
for the fields in the record \code{Struct\_Cogent\_line}.

Union types are translated to abstract types, omitting the fields. Semantically, the corresponding Cogent types would
be variant types, however, these are not binary compatible. Therefore Gencot leaves the translation of union types to
the developer, it only generates type aliases in a similar way as for struct types.

\subsection{Derived Types}
\label{types-auto-derived}

In C there are three kinds of types called ``derived types'': function types, pointer types, and array types.

As you can see from the examples, C function types are directly translated to Cogent function types. Note that these
are not binary compatible, however, this is not a problem since in C functions cannot occur in data structures (in
contrast to function \textit{pointers}).

In Cogent every function has a single value as parameter and a single value as result. Gencot wraps multiple parameters
in a tuple and uses the unit value, if a C function has no parameter or no result value (specified as \code{void}).
A C function declared to take a variable number of parameters (a ``variadic'' function) is translated as if the 
additional parameters would always be a single value. The used pseudo type alias is not defined and will be signaled
as an error by the Cogent compiler, this must be handled manually by the developer.

The only pointer types directly supported by Cogent are boxed record types, which correspond to pointers to structs.
Accordingly, pointers to a struct type are translated to boxed record types in Cogent. The difference from the translation
of a struct type can be seen at the fields in the example \code{Struct\_Cogent\_sphere}: for the struct pointer no
unbox operator is applied. 

However, instead of an unbox operator, the generic type \code{MayNull} is applied to the referenced pointer type. In 
Cogent, a value of a boxed record type must be guaranteed to be not \code{NULL}. Since this is not the case for an 
arbitrary C pointer type, both are not strictly binary compatible. Gencot defines the generic type \code{MayNull}
and applies it to all translated C pointer types. Gencot provides an abstract data type for \code{MayNull} which allows
access to the record only after an explicit test whether the pointer is not \code{NULL}. Like the unbox operator,
Gencot does not apply \code{MayNull} in the type definition, but instead to all references of the defined type alias.

C pointer types where the base type is a primitive type, an enum type, or another pointer type, are translated with the
help of the generic type \code{CPtr}. Gencot defines a corresponding abstract type with functions to access the 
referenced value. Again, whenever such a type is used, the \code{MayNull} type is applied to it to care for \code{NULL} 
values.

C function pointers are treated in a different way by Gencot. Since there is no binary compatible Cogent type for them 
(function type values are represented by integers numbering all known functions in Cogent), Gencot translates function pointer
types to abstract Cogent types. To support a unique correspondence, the C function type expression is encoded into
the name used for the abstract Cogent type. As an exercise, you may try to find out the encoding scheme by looking
at the examples. The example defines function pointer types for all function types defined previously in the same example. 
The additional example \code{Cogent\_funHigher\_t} shows that this also works for higher order functions: as specified by the 
C standard, a parameter of function type is ``adjusted'' to function pointer type and translated accordingly by Gencot.

Translated C function pointer types are always used with an unbox operator applied. Thus they behave in the same way as 
primitive types in Cogent. This is correct, since although the values are pointers, they cannot be dereferenced in 
a Cogent program. Instead, Gencot provides functions to convert between these pointers and values of the corresponding
Cogent function type.

C array types are translated to corresponding Cogent builtin array types. Gencot
uses generic types of the form \code{CArr<size>} where the array size (number of elements) is encoded into the type name.
This works for all kinds of element types.

Depending on its use, an array in C may be represented by a pointer to the first element or by the sequence of all elements.
Accordingly, Gencot translates an array type either to the boxed type (corresponding to pointer values) or it
applies the unbox operator (corresponding to the sequence of elements). In the example this can be seen in the types 
\code{Struct56\_types\_c} and \code{Cogent\_funArray\_t}: when used as a struct member, the array type is used in its unboxed
form and the sequence of elements is embedded in-place; when used as a function parameter, the array type is used in 
its boxed form corresponding to a pointer, because according to the C standard the array type is ``adjusted'' to an array
pointer type.

Finally, the example shows that multidimensional arrays are translated to array-of-array. Again, the unboxed form is used
since the elements of the inner array are directly embedded in the outer array.

\subsection{Auxiliary Types}
\label{types-auto-gen}

We have seen that Gencot uses some auxiliary types when it translates C ``derived types'' to Cogent. For some of them, like 
\code{MayNull} and \code{CPtr}, the Gencot distribution includes their definitions. However, the abstract types
used for function pointer types and the types used for array types depend on the translated C program. Where
are their definitions provided?

Look at the file \code{all-dvdtypes.cogent} in \code{examples/types}. As described in Section~\ref{struct-single} it was 
generated by the command
\begin{verbatim}
  gencot unit
\end{verbatim}
It contains all program dependent auxiliary type definitions required for translated derived C types. 

Note that for every array
size used in the program a single type of the form \code{CArr<size>} is defined, even if several types of this
size with different element types are used in C. You can also see that \code{CArr<size>} is defined as a synonym
for the corresponding Cogent builtin array type. For technical reasons it is ``wrapped'' in
a record with a single component named \code{arr}. To actually embed the array in the record an unboxed array type
of the form \code{el\#[<size>]} is used. 

As a convenience, for every function pointer type alias a similar alias for the corresponding function type is 
defined. This is intended to be used when converting between both.

\subsection{Continuing the Example}

To verify that the type definitions generated in Section~\ref{types-auto-example} can actually be processed by the 
Cogent compiler, you may perform the following steps:

\begin{description}
\item[Step 2:] (make edit)

Remove all type definitions generated from the floating point types and variadic function types 
from the files \code{types.cogent} and \code{all-dvdtypes.cogent}

\item[Step 3:] (make c)

Now you can process \code{all.cogent} by the Cogent compiler. Enter the command
\begin{verbatim}
  cogent -o all-gen -g all.cogent \
     --cogent-pp-args="-I$GENCOT_HOME/include" \
     --infer-c-funcs="all-externs.ac types-entry.ac"
\end{verbatim}
It creates the files \code{all-gen.c} and \code{all-gen.h} and two (empty) \code{\_pp\_inferred.c} files. 

The option \code{--cogent-pp-args} adds the directory \code{\$GENCOT\_HOME/include} to the include path
used by Cogent. It is needed to load the definitions for the types \code{MayNull} and \code{CPtr} from
the Gencot distribution. 

The corresponding include directives can be found in the file \code{gencot-incl.cogent}
which is provided with the example. Whenever Gencot finds a file with this name in the current directory it 
includes it in the generated file \code{all.cogent}. By adding include directives to \code{gencot-incl.cogent}
all types and functions predefined by Gencot can be made available.

As usual, enter the command
\begin{verbatim}
  auxcog unit
\end{verbatim}
for postprocessing.

\item[Step 4:] (make cogent-binary)

Compile \code{all.c} with a C compiler to an object file, such as in 
\begin{verbatim}
  cc -c -I`cogent --libgum-dir` -I$GENCOT_HOME/c all.c
\end{verbatim}
This should work and produce \code{all.o}, however, it is of no much interest,
since Cogent does not translate most of our type definitions to C, because they are not used in functions.

\item[Step 5:] (make clean)

Clean up all generated files.
\end{description}

\section{Default Item Properties}
\label{types-dfltprops}

The basic way of Gencot's type translation can be affected with the help of ``item properties''. An item is 
every unit in the C program which has a type (such as variables, functions, parameters, struct members, \ldots).
Gencot identifies items by specific path names. Using these path names item properties can be declared outside
the C program which affect how the item's type is translated by Gencot.

Some item properties (the ``default properties'') are automatically derived from the C program. Instead of directly
using the information for Gencot's type translation, it is externalized in the form of item property declarations. 
Thus it is possible for the developer to modify it before it is used by Gencot.

\subsection{Example}
\label{types-dfltprops-example}

To see how it works, go to \code{examples/items}. The file \code{items.h} contains example type definitions
which demonstrate the impact of default item properties. Translate this file with Gencot, as described in 
Section~\ref{struct-include} (\code{make h-cogent}): 
\begin{verbatim}
  items -u part used
  gencot -u part hfile items.h
\end{verbatim}
and save the resulting file \code{items-incl.cogent} as \code{items-incl-auto.cogent}. Now derive the default 
properties for \code{items.h} with the command (\code{make h-props}):
\begin{verbatim}
  items -u part file items.h > items.h-itemprops
\end{verbatim}
and translate \code{items.h} again with the same command as above. 

Now look at the generated file \code{items-incl.cogent}. You can see the effect of the default properties by 
comparing it to the saved \code{items-incl-auto.cogent}. When Gencot translates a source file \code{x} it looks
for a file named \code{x-itemprops} in the current directory. If it finds it, it uses it for its type translations.
Therefore the two translation results differ.

\subsection{Read-Only Types}
\label{types-dfltprops-readonly}

The first group of type definitions in \code{items.h} demonstrates the generation of read-only types in Cogent.
If the base type of a pointer is \code{const} qualified in C, as for \code{intCP\_t} in the example, Gencot makes
the translated type read-only. This works for all kinds of base types, such as structures (example: \code{coord3dCP\_t})
and for all kinds of items, such as function parameters and results (examples: \code{funBinPtr\_t, funResPtr\_t}).

But why does it not work for \code{sphereP\_t}, although its base type is \code{const} qualified? The reason is that 
\code{struct sphere} contains a member \code{center} which is a pointer without \code{const} qualified base
type. In Cogent a value comprises \textit{all} parts which can be transitively accessed following pointers. Gencot
only translates a type as read-only if all these pointers have a \code{const} qualified base type and thus no part 
of the Cogent value may be modified. This is demonstrated by \code{sphereCP\_t} in the example.

Array types are treated like pointers: if the element type is \code{const} qualified (and also all transitively 
accessible pointers and arrays), Gencot translates the array type as read-only. However, as described in 
Section~\ref{types-auto-direct} for the unbox operator, for array types the bang operator is only applied to type 
name references, not in the type definition. In the example you can see this for type \code{intCA\_t}, the read-only
form occurs when it is used in the translated \code{funArrPar\_t}. The reason for this behavior is that translated 
array types may also occur in the unboxed form, as in the translation of \code{arrstr\_t}, there the bang operator
is omitted.

The next group of type definitions shows a special case: a \code{const} qualified \code{char} pointer is translated 
to the Cogent type \code{String}. (You have already seen this behavior in earlier examples, there the default item 
property files have been provided with the example.)

\subsection{Additional Function Results}
\label{types-dfltprops-addresult}

The last two groups show a feature provided for function types: for all parameters translated to a linear type (i.e.~a
a type which is or transitively accesses a pointer or array without \code{const} qualified base type) an additional
component is added to the result. It is assumed that such parameters will be modified by the function and the modified
value must be explicitly returned in Cogent.

For a function type the result type is changed to a tuple, if necessary, where the first component is the original 
function result. For a function pointer type, this property is encoded in the type name (an \code{"M"} marks 
``modifyable'' parameters, an \code{"R"} marks ``read-only'' parameters).

\subsection{Processing the Item Property Files}
\label{types-dfltprops-process}

To use the item properties for Gencot's type translation you have to generate item property files before using the 
\code{gencot} command to translate C sources. First, for every C source file \code{foo.h} or \code{foo.c} 
to be translated by \code{gencot} process the file with the \code{items} command:
\begin{verbatim}
  items -I. file foo.h > foo.h-itemprops
  items -I. file foo.c > foo.c-itemprops
\end{verbatim}
The include path option \code{-I} is required in all cases in which it is required for the \code{gencot} command as 
described in Section~\ref{struct-include}. Here we assume that all included (non-system) files are in the current 
directory.

Additionally, properties may be required for external items. The default properties for all external items used in the 
translated files are generated in file \code{all.unit-itemprops} with the command:
\begin{verbatim}
  items -I. unit > all.unit-itemprops
\end{verbatim}

For generating the additional Cogent sources with command \code{gencot unit} the file \code{all.unit-itemprops} must
also contain properties for \code{all} items in all translated source files. These are provided by mergin all the files created 
before in \code{all.unit-itemprops}. Merging two item property files is done by 
\begin{verbatim}
  items merge <f1>-itemprops <f2>-itemprops > <f3>-itemprops
\end{verbatim}

Together, the commands for creating all required item property files are:
\begin{verbatim}
  items -I. used
  items -I. file foo.h > foo.h-itemprops
  ... <other .h files> ...
  items -I. file foo.c > foo.c-itemprops
  ... <other .c files> ...
  items -I. unit > all.unit-itemprops
  items merge all.unit-itemprops foo.h-itemprops > hfile
  mv hfile all.unit-itemprops
  ... <other .h-itemprops files> ...
  items merge all.unit-itemprops foo.c-itemprops > hfile
  mv hfile all.unit-itemprops  
  ... <other .c-itemprops files> ...
\end{verbatim}
Note that you cannot output the result of \code{items merge} directly to \code{all.unit-itemprops},
this would clear the file before it is read.

\section{Manual Item Properties}
\label{types-manprops}

The developer can modify the way Gencot translates C types by manually adding or removing item properties. In the example
look at the file \code{items.h-itemprops} which has been generated in Section~\ref{types-dfltprops-example}. Every line
names an item by its path name and specifies properties for it. Every property has a two-letter code, \code{"ro"} specifies
a read-only type, \code{"ar"} specifies an additional result for a function parameter. Note that, if both are specified 
for an item, \code{"ro"} has higher priority and \code{"ar"} is ignored.

It should be relatively straightforward to identify the items from their pathnames. A slash is used as separator, for struct 
members a dot is used. Function parameters are identified by their position number, starting with position 1, if the name
is not available. Function results are identified by \code{()}.

As you can see, items are listed even if no properties are specified for them. This is a convenience for the developer. Gencot
always lists the pathnames for \textit{all} items which occur in a C source file. The developer can then add properties for
an item without first constructing its pathname.

\subsection{Example}
\label{types-manprops-example}

Open the file \code{items.h-itemprops} in a text editor. Add the \code{ro} property for the type item \code{intP\_t} and
remove the \code{ar} property from the first parameter of the type item \code{funLinPar1\_t} (\code{make dflt-edit}). Then 
remove \code{items-incl.cogent} and translate \code{items.h} once more. Now the Cogent type \code{Cogent\_intP\_t} will
be read-only and the Cogent type \code{Cogent\_funLinPar1\_t} will not have an additional result component anymore.

In \code{examples/items} additionally
generate the item property file for \code{items.c} with the command (\code{make c-props}):
\begin{verbatim}
  items -I. -u part file items.c > items.c-itemprops
\end{verbatim}

In file \code{items.c-itemprops} you can see how functions are identified as items. For static functions the file name where
they are defined is prepended to the function name, so that the item identifier should be unique, even if the same name 
is reused for static functions in different files.

Next, generate the default property declarations for all used external items with the command (\code{make e-props}):
\begin{verbatim}
  items -I. -u part unit
\end{verbatim}

Look at the output. It lists entries for the items \code{allocArr} and \code{allocInt} defined in file \code{alloc.c} (which 
are extern, because this file is not listed in \code{part.unit}) and for the item \code{printf} declared in the system
include file. From the declaration of \code{printf} the properties for the first parameter are derived as usual. Note that,
as described in Section~\ref{struct-single} for the translation, only those external items are listed which are actually used in the 
source files specified in \code{part.unit}.

\subsection{Read-Only Property}
\label{types-manprops-ro}

The main application of manual read-only properties is the case where an item is actually not modified in the C program, 
although it would be possible to do so according to its type. In this case a read-only property may be added to reflect
the read-only behavior in the item's Cogent type.

A typical case is that a function parameter is a pointer without \code{const} qualified base type, but the function 
never modifies the data referenced by the pointer. Specifying the read-only property for the parameter item makes 
the parameter's type read-only in Cogent.

Another typical case is a pointer or array type \code{t} where the base type is \code{const} qualified but it transitively contains
a pointer or array where this is not the case, because it has been forgotten in C or not considered relevant, although
the referenced data will never be modified through this reference path. Specifying the read-only property for the type
item \code{t} will translate it as read-only, corresponding to the intended semantics.

\subsection{Add-Result Property}
\label{types-manprops-ar}

The main application of manual add-result properties is the case where no additional result for a parameter is required, although
the parameter translates to a linear type. In this case the add-result property generated by Gencot should be removed 
to suppress the additional result component.

A typical case is when the parameter is already returned as the function result or as a part of it in C, as for the function
\code{memcpy} in the C standard library. 

Another case is when the function's semantics is to actually discard the parameter by deallocating the pointer. The most
apparent example is the function \code{free} in the C standard library.

Adding add-result properties usually makes no sense. Gencot generates them for all parameters of linear type, for all others
an additional result component is of no use.

\subsection{No-String Property}
\label{types-manprops-ns}

The no-string property is used to suppress the translation to the Cogent type \code{String}. It is never generated by Gencot
and may be manually specified as \code{"ns"}, such as in 
\begin{verbatim}
  item-path-name: ns
\end{verbatim}
If the item has type \code{const char *} it is translated to type \code{(MayNull (CArr U8))!} instead of type \code{String}.
For items of a type which is not translated to \code{String} the property is ignored.

In the example, add the \code{ns} property for the type item \code{charCP\_t} (\code{make ns-edit}). Then 
remove \code{items-incl.cogent} and translate \code{items.h} once more. Now the Cogent type \code{Cogent\_charCP\_t} will
be defined as \code{(CArr U8)!} instead of \code{String} (as usual, the \code{MayNull} type is only applied to
references to \code{Cogent\_charCP\_t}).

\subsection{Not-Null Property}
\label{types-manprops-nn}

The not-null property is used to suppress the addition of Cogent type \code{MayNull} for translated pointer types (see 
Section~\ref{types-auto-derived}). It is never generated by Gencot and may be manually specified as \code{"nn"}, such as in 
\begin{verbatim}
  item-path-name: nn
\end{verbatim}
If the item has type \code{int *} it is translated to type \code{CPtr U32} instead of type \code{MayNull (CPtr U32)}.
For items which are no pointers the property is ignored.

The not-null property can be used to express that an item's value is never \code{NULL} in the C program. A possible reason
is that it is immediately initialized and every pointer to be assigned to it is tested to be not \code{NULL} before. 
Thus the not-null property is used to statically remember this fact for the item in Cogent with the help of the Cogent
type.

In the example, add the \code{nn} property for the struct member item \code{sphereC.center} (\code{make nn-edit}). Then 
remove \code{items-incl.cogent} and translate \code{items.h} once more. Now the Cogent type of field \code{center} in
the Cogent record type \code{Struct\_Cogent\_sphereC} will be \code{Cogent\_coord3dCP\_t!} instead of 
\code{(MayNull Cogent\_coord3dCP\_t)!}.

\chapter{Preprocessor Directives}
\label{directives}

\end{document}
 
