In some cases the mapped data type definitions generated by Gencot according to Section~\ref{design-types} must be manually
adapted by editing the corresponding \code{x-incl.cogent} files. Here we describe typical cases where an adaptation is
necessary.

\subsection{NULL Pointers}
\label{app-transtype-null}

A value of linear type in Cogent corresponds in C to a pointer which is not \code{NULL}. 
If a value of linear type is used in the program at a place where in the C program it is not known to be non-null, it's type
must be changed. The natural choice for a linear type \code{T} is the type \code{Option T} using the Cogent standard library.
However, this type is not binary compatible to \code{T}. If the value is also used outside the Cogent compilation unit 
in the remaining C program, the type \code{(MayNull T)} (see Section~\ref{design-operations-null}) must be used instead.

A good hint for the property that a value may be null is if it is tested for being null in the C program. If not, however,
this case may have been overlooked. This will show up if the value's type is not changed and during the manual translation
of the function bodies an assignment of \code{NULL} must be translated for it.

A linear value may occur in the Cogent program as a function parameter, a function result, or a field in a record. In each case
all occurrences of the value must be analyzed to find out whether the type must be changed or not.

If the value is a field in a record the null pointer may also be represented in a binary compatible way by the field being
taken. This is possible when 
it is statically known for each occurrence of the record in the Cogent program, whether the field value is null or not. 
Then the type of the record can be changed to the type with the field taken for all cases where the field value is null.
A typical application case is when the field is initialized at a specific point in the program and never set to null
afterwards.

If the value is the parameter or result of a function pointer, a type name must be introduced 
for the \code{MayNull} type instance and then used to consistently rename the type in the function type encoding used
for the function pointer type. For example, if a C function pointer has type
\begin{verbatim}
  int (*)(some_struct *p)
\end{verbatim}
it is mapped by Gencot to have the abstract type
\begin{verbatim}
  F_XStruct_Cogent_some_structX_U32
\end{verbatim}
If parameter \code{p} may be null, its type should be changed to a new abstract type introduced by:
\begin{verbatim}
  type F_XMayNull_Cogent_some_structX_U32
  type MayNull_Cogent_some_struct = 
    MayNull Struct_Cogent_some_struct
\end{verbatim}

\subsection{Grouping Fields in a Record}
\label{app-transtype-group}

Sometimes in a C struct type several members work closely together by pointing to memory
shared among them. Then in Cogent it would be possible to take the corresponding record fields separately,
resulting in shared values of linear type. Instead, the fields should only be operated on by specific functions
for which the correct handling of the fields can be proven. To avoid taking the fields separately, these
functions should be defined on the record as a whole. Then it can be statically checked that the fields
are never accessed or taken/put outside these functions.

To make this more explicit, the corresponding record fields can be grouped into an embedded unboxed
record in Cogent. This is binary compatible if the members of the original struct are consecutive and in
the same order and are no bitfields. For example in the record type \code{R} as defined in 
\begin{verbatim}
  type R = {f1: A1, f2: A2, f3: A3, f4: A4, f5:A5}
\end{verbatim}
the fields \code{f2} and \code{f3} can be grouped by introducing the new record type \code{E}:
\begin{verbatim}
  type E = {f2: A2, f3: A3}
  type R = {f1: A1, embedded: #E, f4: A4, f5:A5}
\end{verbatim}
This is translated by Cogent to an embedded struct.

Now operations working on some or all of the grouped fields can be defined on the type \code{E} instead
of \code{R}, guaranteeing that the functions cannot access the other fields of \code{R}.

Note that it is still possible to take the fields separately by first taking \code{embedded} from \code{R}
and then accessing the fields in the taken value. This can now be prevented by checking that the field
\code{embedded} is never accessed or taken/put directly in a value of type \code{R}.

Instead, using the conceptual operations \code{getref} and \code{modref} as defined in 
Section~\ref{design-operations-parts} it is possible to apply the functions defined on \code{E} 
in-place without copying the field values. This requires to manually define abstract polymorphic functions
\begin{verbatim}
  getrefFldEmbedded: all(rec,pfld). rec! -> pfld!
  modrefFldEmbedded: all(rec,pfld,arg,out). ModPartFun rec pfld arg out
\end{verbatim}
and use their instances \code{getrefFldEmbedded[R,E]} and \code{modrefFldEmbedded[R,E,A,O]} for the required 
types \code{A} and \code{O}. The functions are implemented in antiquoted C using the address operator \code{\&} and should
be the only ways how to access the field \code{embedded}.

To provide even more shielding, the type \code{E} can be defined as abstract, providing the definition
as a struct in C:
\begin{verbatim}
  typedef struct {A f2; A f3; } E;
\end{verbatim}
Then it is guaranteed that the fields can never be accessed in the Cogent program. However, then also 
all function working on type \code{E} must be defined as abstract functions which are implemented in C.

\subsection{Using Pointers for Array Access}
\label{app-transtype-arrpoint}

A common pattern in C programs is to explicitly use a pointer type instead of an array type for referencing an array,
in particular if the array is allocated on the heap. This is typically done if the number of elements in the
array is not statically known at compile time. The C concept of variable length array types can sometimes be
used for a similar purpose, but is restricted to function parameters and local variables and cannot be used for
structure members.

In C the array subscription operator can be applied to terms of pointer type. The semantics is to access an element 
in memory at the specified offset after the element referenced by the pointer. This makes it possible to use 
a pointer as struct member which references an array as in
\begin{verbatim}
  struct ip {... int *p, ...} s;
\end{verbatim}
and access the array elements using the subscription operator as in \code{s.p[i]}.

Gencot translates the struct type to a record type of the form
\begin{verbatim}
  type Struct_Cogent_ip = {... p: CPtr U32, ...}
\end{verbatim}
and does not generate instances of the array access functions defined in Section~\ref{design-operations-array}. 

The main problem here is the unknown array size. In the C program, however, for working with the array it must be
possible to determine the array size in some way at runtime. If this way is translated to Cogent, an explicitly
sized array (see Section~\ref{design-operations-esarray}) and the corresponding access functions provided by
Gencot can be used, by constructing values of type \code{CArrES U32} on the fly as pairs \code{(p,<size>)}
or using the macro \code{MKCAES}. The only additional requirement is to mark the pointer type as an array by
replacing the generic type \code{CPtr} by the generic type \code{CArrPtr}:
\begin{verbatim}
  type Struct_Cogent_ip = {... p: CArrPtr U32, ...}
\end{verbatim}

This approach can be improved by reorganizing the type of the surrounding record \code{Struct\_Cogent\_ip}. We
assume that it shall be binary compatible to the original C struct \code{ip} and distinguish two approaches how 
this is done.

\subsubsection{Self-Descriptive Array}

In the first case the array size can always be determined from the array content. Then the pointer to the first 
element is always sufficient for working with the array. The two typical patterns of this kind either use a 
stop element to mark the array end, such as the zero character ending C strings, or store the array size in a
specific element or elements, such as in the header part of a network package represented as a byte array.

Working with the array is supported by manually defining and implementing a data type for the array as follows.
Let \code{tt} be a unique name for the specific kind of array (how its size is determined) and let \code{El} be the
name of the array element type. We use \code{CArr\_tt\_El} as type name for the array, thus the 
type of \code{p} must be manually changed as follows:
\begin{verbatim}
  type Struct_Cogent_ip = {... p: CArr_tt_El, ...}
\end{verbatim}

The type \code{CArr\_tt\_El} is defined as a synonym for the array pointer type
\begin{verbatim}
  type CArr_tt_El = CArrPtr El
\end{verbatim}
Since the array size is determined from the array content this will usually be specific for the type of elements,
so a non-generic type is defined here.

For the type \code{CArr\_tt\_El} the polymorphic function \code{create} cannot be used since no instance has been
generated by Gencot for it. Gencot cannot do this because the array size is unknown to it. Instead, the function
\code{createCAES} can be used (see Section~\ref{design-operations-esarray}) by specifying the array size explicitly. 
The resulting explicitly sized array has type \code{EVT\_CAES(,El)} which is equivalent to \code{EVT(CArrPtr El),U64)},
and the first component is equivalent to \code{EVT(CArr\_tt\_El)}.
As usual, it denotes the type of the uninitialized array, realized in the same way as described for \code{CPtr}. 
Corresponding abstract functions for initializing and freeing the array elements must be provided manually.

For disposing values of the type \code{CArr\_tt\_El} the usual polymorphic function \code{dispose} can be used, 
Gencot is able to automatically provide a correct C implementation for all types for which it is used.

Element access functions for single elements can now be defined as instances of the operations for accessing parts 
of structured values described in Section~\ref{design-operations-parts} in the specific form for arrays as described
in Section~\ref{design-operations-array}. The type \code{UNN} used for the index
values must be chosen by the developer so that it can represent all sizes which are used for the array.
\begin{verbatim}
  getCArr_tt_El : (CArr_tt_El!,UNN) -> El!
  getCArrChk_tt_El : (CArr_tt_El!,UNN) -> Result El! ()
  setCArr_tt_El : ModFun CArr_tt_El (UNN,El) ()
  exchngCArr_tt_El : ModFun CArr_tt_El (UNN,El) (UNN,El)
  modifyCArr_tt_El : all(arg,out). 
    ModFun CArr_tt_El (UNN, ChgFun El arg out, arg) out
  getrefCArr_tt_El : (CArr_tt_El!,UNN) -> CPTR(<knd>,El)!
  getrefCArrChk_tt_El : (CArr_tt_El!,UNN) -> Result CPTR(<knd>,El)! ()
  modrefCArr_tt_El : all(arg,out). 
    ModFun CArr_tt_El (UNN, ModFun CPTR(<knd>,El) arg out, arg) out
\end{verbatim}
where \code{setCArray\_tt\_El} can only be defined if the element type \code{El} is discardable. All these functions
must be defined as abstract and implemented in C, since they access elements outside the Cogent record for \code{CArrPtr El)}.
They cannot use the corresponding access function for the explicitly sized array, because they already need to access
array elements to determine the size.

\subsubsection{Externally Described Arrays}

In the second case the array size is determined by additional information separate from the pointer to the array.
Either the size is specified as an integer value as in 
\begin{verbatim}
  struct ip {... int *p, int psize; ...} s;
\end{verbatim}
or it is specified by a second pointer, e.g., pointing to the last element as in
\begin{verbatim}
  struct ip {... int *p, int *pend; ...} s;
\end{verbatim}
In general there may be additional information, such as pointers into the array which are used to reference
``current'' positions in the array. We assume that all this information is provided by a sequence of members
in the surrounding struct:
\begin{verbatim}
  struct ip {...; t1 m1;...tn mn; ...} s;
\end{verbatim}

These members can be grouped into an embedded struct as described in Section~\ref{app-transtype-group}. If they
are consecutive and are grouped in the same order the modified record type should be binary compatible.
We propose to name the embedded record type \code{SArr\_tt\_El} (``structured array'') in analogy to the
array type name for self-descriptive arrays. It can either be defined as a record type in Cogent:
\begin{verbatim}
  type SArr_tt_El = { m1: T1, ... Mn: Tn }
\end{verbatim}
where the element pointer type \code{Ti} uses the generic type \code{CArrPtr} instead of \code{CPtr}
or, providing additional shielding as a wrapped abstract type 
\begin{verbatim}
  type SArr_tt_El = { cont: #USArr_tt_El }
\end{verbatim}
with a C definition:
\begin{verbatim}
  typedef struct { t1 m1;...tn mn; } USArr_tt_El;
\end{verbatim}
Note that in both cases \code{EVT(SArr\_tt\_El)} yields a usable empty-value type.

Now the single fields in the original structure can be replaced by a field of the embedded structured array type:
\begin{verbatim}
  type Struct_Cogent_ip = {... a: #SArr_tt_El, ...}
\end{verbatim}

To access and modify the group in the struct in-place the abstract polymorphic functions
\begin{verbatim}
  getrefFldA: all(rec,sarr). rec! -> sarr!
  modrefFldA: all(rec,sarr,arg,out). 
    ModPartFun rec sarr arg out 
\end{verbatim}
must be defined and used in the same way as described in Section~\ref{app-transtype-group}.

Initialization and clearing functions for \code{SArr\_tt\_El} must be implemented manually, they always need the
heap for allocating or disposing the actual array. 

The element access functions for single elements can be defined as abstract instances of the operations for accessing parts 
in the same way as for self-descriptive arrays, although the implementations will differ because they have to 
take into account the fields of \code{SArr\_tt\_El}. Since they do not need to access the array for determining its size
they can always be implemented in Cogent by calculating the size using the fields of \code{SArr\_tt\_El}, then constructing
an explicitly sized array and then using the access function provided by Gencot.

Usually, additional functions will be required for working
with values of type \code{SArr\_tt\_El}, such as for moving an internal pointer to a ``current'' element.
If such a function modifies some of the fields of \code{SArr\_tt\_El} it must be defined as a modification function
which can be applied with the help of \code{modrefFldA}.
