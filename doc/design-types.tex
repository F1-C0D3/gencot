
Here we define rules how to map common C types to binary compatible Cogent types. Since the usefulness of a mapping
also depends on the way how values of the type are processed in the C program, the resulting types may require manual 
modification.

For every mapped type Gencot also defines a dummy expression of that type. It is used as a replacement for the actual 
body when translating C functions (see Section~\ref{design-fundefs}).

\subsection{Numerical Types}
\label{design-types-prim}

The Cogent primitive types are mapped to C types in \code{cogent/lib/cogent-defns.h} which is included by the Cogent compiler
in every generated C file with \code{\#include <cogent-defns.h>}. The mappings are: 
\begin{verbatim}
  U8 -> unsigned char
  U16 -> unsigned short 
  U32 -> unsigned int
  U64 -> unsigned long long
  Bool -> struct bool_t { unsigned char boolean }
  String -> char*
\end{verbatim}
The inverse mapping can directly be used for the unsigned C types. For the corresponding signed C types to be binary
compatible, the same mapping is used. Differences only occur when negative values are actually used, this must be handled by using specific functions for numerical operations in Cogent.

In C all primitive types are numeric and are mapped by Gencot to a primitive type in Cogent. Note that in C the representation 
of numeric types may depend on the C version and target system architecture. However, the main goal of Gencot is only to generate
Cogent types which are, after translation to C, binary compatible with the original C types. Hence it is sufficient for the numerical 
types to simply invert the Mapping used by the Cogent compiler.

Together we have the following mappings:
\begin{verbatim}
char, unsigned/signed char -> U8
short, unsigned/signed short -> U16
int, unsigned/signed int -> U32
long int, unsigned/signed long int -> U64
long long int, unsigned/signed long long int -> U64
\end{verbatim}

The only mapping not determined by the Cogent compiler mapping is that for \code{long int}. For the gcc C version 
it depends on the architecture and is either the same as \code{int} (on 32 bit systems) or \code{lon long int}
(on 64 bit systems). Gencot assumes a 64 bit system and maps it like \code{long long int}.

The dummy expression used for all target types is the literal \code{0}.

\subsection{Enumeration Types}
\label{design-types-enum}

A C enumeration type of the form \code{enum e} is a subset of type \code{int} and declares enumeration 
constants which have type \code{int}. According to the C99 standard, an enumeration type may be implemented
by type \code{char} or any integer type large enough to hold all its enumeration constants.

A natural mapping for C enumeration types would be Cogent variant types. However, the C implementation
of a Cogent variant type is never binary compatible with an integer type (see below). 

Therefore C enumeration types must be mapped to a primitive integer type in Cogent. Depending on the C
implementation, this may always be type \code{U32} or it may depend on the value of the last enumeration
constant and be either \code{U8}, \code{U16}, \code{U32}, or maybe even \code{U64}. Under Linux, both cc
and gcc always use type \code{int}, independent of the value of the last enumeration constant. 
Therefore Gencot always maps enumeration types to Cogent type \code{U32}.

If an enumeration type has a tag, Gencot preserves the tag information for the programmer and uses
a type name of the form \code{Enum\_tag}, as described in Section~\ref{design-names}. For tagless enums
no type names are introduced, they are directly mapped to type \code{U32}.

The rules for mapping enumeration types are
\begin{verbatim}
  enum { ... } -> U32
  enum e { ... } -> Enum_e
  enum e -> Enum_e
\end{verbatim}

The enumeration constants must be mapped to Cogent constant definitions of the corresponding type. In 
C the value for an enumeration constant may be explicitly specified, this can easily be mapped to
the Cogent constant definitions.

An enumeration declaration of the form \code{enum e \{C1, C2, C3=5, C4\}} is translated as
\begin{verbatim}
  cogent_C1: U32
  cogent_C1 = 0
  cogent_C2: U32
  cogent_C2 = 1
  cogent_C3: U32
  cogent_C3 = 5
  cogent_C4: U32
  cogent_C4 = 6
\end{verbatim}
Note that the C constant names are mapped to Cogent names as described in Section~\ref{design-names}.

The dummy expression for all mapped enumeration types is the literal \code{0}.

\subsection{Structure and Union Types}
\label{design-types-struct}

A C structure type of the form \code{struct \{ ... \}} is equivalent to a Cogent unboxed record type \code{\#\{ ... \}}.
The Cogent compiler translates the unboxed record type to the C struct and maps all fields in the same order.
If every C field type is mapped to a binary compatible Cogent field type both types are binary compatible as a whole.

A C structure may contain bit-fields where the number of bits used for storing the field is explicitly specified.
Gencot maps every consecutive sequence of bit-fields to a single Cogent field with a primitive Cogent type.
The Cogent type is determined by the sum of the bits of the bit-fields in the sequence. It is the smallest 
type chosen from \code{U8, U16, U32, U64} which is large enough to hold this number of bits. 
***--> test whether this is correct.
The name of the
Cogent field is \code{cogent\_bitfield}<n> where <n> is the number of the bit-field sequence in the C structure.
Gencot does not generate Cogent code for accessing the single bit-fields. If needed this must be done manually in Cogent.
However, Gencot adds comments after the Cogent bitfield showing the original C bit-field declarations.

A C union type of the form \code{union \{ ... \}} is not binary compatible to any type generated by the Cogent compiler.
The semantic equivalent would be a Cogent variant type. However, the Cogent compiler translates every variant type
to a \code{struct} with a field for an \code{enum} covering the variants, and one field for every variant. Even if a variant
is empty (has no additional fields), in the C \code{struct} it is present with type \code{unit\_t} which
has the size of an \code{int}. Therefore Gencot maps every union type to an unboxed abstract Cogent type.

Another semantic equivalent would be a Cogent record type, where always all fields but one are taken. However,
this type is not binary compatible either, it is translated to a normal struct where every member has another
offset. Even if the translated type in C is manually changed to a union, the Cogent take and put operations cannot
be used since they respect the field offsets. 

Together we have the mapping rules:
\begin{verbatim}
  struct s -> #Struct_s
  union s -> #Union_s
\end{verbatim}
where \code{Struct\_s} is the Cogent name of a record type corresponding to \code{struct s} and \code{Union\_s} is the
name of the abstract type introduced for \code{union s}.

As explained in Section~\ref{design-names}, Gencot always introduces a Cogent type name for each struct and union,
even if no tag is present in C. Since the tag name is either defined to name a Cogent record or an abstract type,
it is always linear and names a boxed type which corresponds to a pointer. Hence, the type name generated for a struct
is always used to refer to the type ``pointer to struct'', the struct type itself is translated to the type name 
with the unbox operator applied. The same holds for union types.

To be able to provide a dummy expression for mapped structure and union types, Gencot automatically defines an 
abstract function from the unit type to the target type:
\begin{verbatim}
  struct s -> dummy_Unbox_Struct_s: () -> #Struct_s
  union s -> dummy_Unbox_Union_s: () -> #Union_s
\end{verbatim}
Since the dummy expressions are intended to be eliminated before compiling the 
C code generated by the Cogent compiler, Gencot does not provide C definitions for these abstract functions. 

Then the dummy expression for type \code{\#Struct\_s} is \code{dummy\_Unbox\_Struct\_s ()} and analogously
for mapped union types. 

\subsection{Array Types}
\label{design-types-array}

A C array type \code{t[n]} has the semantics of a consecutive sequence of n instances of type \code{t}. A value
of type \code{t[n]} is a pointer to the first element and therefore compatible to type \code{t*}.

Basically, Cogent does not support accessing elements by an index value in an array. 
This is an important security feature since the index value is computed at runtime and cannot be statically 
compared to the array length by the compiler. Therefore, a C array type can only be mapped to an abstract type 
in Cogent, which prevents accessing its elements in Cogent code. Element access must be implemented externally 
with the help of abstract functions.

The Cogent standard library includes three abstract data types for arrays (\code{Wordarray, Array, UArray}). 
However, they cannot be used as a binary compatible replacement for C arrays, because they are implemented by 
pointers to a \code{struct} containing the array length together with the pointer to the array elements. 
Only if the C array pointer is contained in such a struct, it is possible to use the abstract data types. 
In existing C code the array length is often present somewhere at runtime, but not in a single \code{struct}
directly before the array pointer.

As of December 2018 there is an experimental Cogent array type written \code{T[n]}. It is binary compatible 
with the C array type \code{t[n]}. It is not linear, however it only supports read access to the array elements, 
the element values cannot be replaced. Thus it can be used as replacement for a pure abstract type, if the array 
is never modified and if it does not contain any pointers (directly or indirectly). If it is modified, replacing
elements can be implemented externally with the help of abstract functions.

In C the incomplete type \code{t[]} can be used in certain places. It may be completed statically, e.g. 
when initialized. Then the number of elements is statically known and the type can be mapped like \code{t[n]}.
If the number of elements is not statically known the type cannot be mapped to a Cogent array, it must be mapped 
to an abstract type.

Since the Cogent array type is still under development, the current version of Gencot does not use it for
mapping C array types. Instead, all C array types are mapped to Cogent with the help of generated names for 
abstract types.

\subsubsection{Mapping Array Types}

A C array type \code{t[n]} has two slightly different meanings. When it is used for allocating space in memory,
it is used to determine the required space as \code{n * sizeof(t)}. When it is used as declared type for an 
identifier, it means that the identifier names a value of type \code{t*}, since C arrays are always represented
by a pointer to the first element. In Cogent both cases must be supported. However, since the first case 
corresponds to a nonlinear (unboxed) type and the second case corresponds to a linear type, different Cogent
types must be used. Since the linear type is not the derived pointer type of the nonlinear type, the 
difference cannot be implemented by using a single type name with the unbox operator applied or not. Therefore
Gencot uses two different type names to represent both cases for a C array type in Cogent.

The names are constructed as specified in Section~\ref{design-names}. For the array type \code{t[n]} the two
type names have the form
\begin{verbatim}
  UA'n'_T
  A'n'_T
\end{verbatim}
where the first name is used for the nonlinear case. It is used with the unbox operator applied.
In antiquoted C it is implemented by the original array type. The second name is used for the linear
case, always without unbox operator applied. In antiquoted C it is implemented by the ``pointer to
element'' type. Thus the corresponding implementations in antiquoted C are
\begin{verbatim}
  typedef t UA_primen_prime_T[n]
  typedef t *A_primen_prime_T
\end{verbatim}

The name \code{UA'n'\_T} without unbox operator applied is translated by Cogent to the corresponding 
pointer type in C, which is a pointer to array. Gencot uses it to map this kind of types (see 
Section~\ref{design-types-pointer}).
The name \code{A'n'\_T} with unbox operator applied would be translated by Cogent to type \code{t}.
It is thus redundant and should not be used in this form.

If the element type \code{t} is again an array type, the meaning in C is a multidimensional array. The
element type corresponds to the nonlinear case, therefore the type name constructed with \code{"U"}
must be used for mapping the element type. For example, the C type \code{t[2][7]} is mapped to the
two Cogent type names
\begin{verbatim}
  UA'2'UA'7'_T
  A'2'UA'7'_T
\end{verbatim}

It would be nice to use two generic types for all C array types, instead of generating new names for every 
C array type. Then the element type need not be mapped to a type name, it may be mapped
to an arbitrary Cogent type expression. A generic type for
C arrays could have the form
\begin{verbatim}
  type CArrayOf e
\end{verbatim}
Then a single mapping in antiquoted C would be sufficient to map all instances of the generic type to their 
C equivalents. The Cogent compiler would be used to generate a monomorphic type for every usage in a program. 
The common antiquoted C typedef for the nonlinear case would need to have the form 
\begin{verbatim}
  typedef e $ty:(CArrayOf e) []
\end{verbatim}
However, the Cogent compiler does not support antiquoted type definitions of this form. Therefore Gencot has to
generate the monomorphic types on its own. 

Moreover, when a C array type is used for a field in a record, after translation from Cogent to C a type
must be used which includes the array size. To be able to specify a corresponding C typedef for the 
Cogent abstract type name, array types with different size specifications must be mapped to different 
Cogent abstract type names. This is the reason why the size specification is encoded into the type name,
as described in Section~\ref{design-names}. 

Together we have the following mapping rule for C arrays with element type \code{el} and size 
specification \code{<size>}:
\begin{verbatim}
  el[<size>] -> A'<size>'_El , #UA'<size>'_El
  el[] -> A_El , #UA_El
\end{verbatim}
where El is the result of mapping the element type \code{el} to a Cogent type name. If the size specification
is too complex (not a literal or single identifier) it is omitted and the type must be handled manually. If the
element type is again a derived type the underscore is omitted.

If \code{el} is mapped to a type name with the unbox operator applied, which is not a function pointer type,
a letter ``\code{U}'' is prepended to \code{El} in the form of an additional derivation step. This can happen for 
struct and union types and is equivalent to the case where \code{el} is another array type.

\subsubsection{Support for Working with Arrays}

The abstract types generated for arrays with known size are complemented by Gencot by abstract functions for working with
arrays. For these functions Gencot automatically generates the Cogent function definitions and the 
implementations in antiquoted C. For array types of the form \code{A\_El} no such support is provided.

Gencot only supports arrays which are allocated on the heap. In C, arrays can also be introduced by defining
them as global or local variable, but Cogent has no language constructs which support this.

Gencot represents array values in Cogent always by a linear type of the form \code{A'<size>'\_El}.
Hence Cogent does not provide a language construct to create such values. Gencot provides the function
\begin{verbatim}
  create_A'<size>'_El : () -> TA'<size>'_El
\end{verbatim}
to create a new array of type \code{A'<size>'\_El}. The function is implemented by simply allocating the
required space on the heap, internally using the translation of type \code{\#UA'<size>'\_El} to specify
the amount of space. 

Gencot uses as result type the additional type \code{TA'<size>'\_El}, with a similar meaning as a Cogent
record with all fields taken. It statically marks the array as uninitialized. The developer must manually provide
an abstract initialization function with type \code{TA'<size>'\_El -> A'<size>'\_El}. The additional type
is automatically defined by Gencot and is mapped to the same C type as \code{A'<size>'\_El}.

Since the Cogent type \code{A'<size>'\_El} is linear, values of it may not be discared. Another abstract 
Cogent function is required for
disposing such values, implemented in antiquoted C by using the C standard function \code{free}:
\begin{verbatim}
  dispose_A'<size>'_El : TA'<size>'_El -> ()
\end{verbatim}
Again, the type for the uninitialized array is used. The developer has to provide an additional function
of type \code{A'<size>'\_El -> TA'<size>'\_El} which in particular has the task of seperately disposing 
all linear values which are array elements or parts of array elements.

For read and write access to array elements Gencot distinguishes two cases, depending on whether the array element
type is linear (contains pointers) or not.

If the element type is nonlinear Gencot provides the abstract functions
\begin{verbatim}
  get_A'<size>'_El : (A'<size>'_El!,UNN) -> Option El
  put_A'<size>'_El : (A'<size>'_El,UNN,El) -> A'<size>'_El
\end{verbatim}
with the expected semantics. The type \code{UNN} is one of \code{U8, U16, U32} according to the size of the array.
The \code{get}-function return type uses the generic type \code{Option} defined in
the Cogent standard library. If the specified index is not in the range \code{0..<size>-1} the 
\code{get}-function returns \code{None}, the \code{put}-function returns the unmodified array. The \code{get}-function 
expects a readonly array, so it may only be used in a context where
the array has been made readonly. The alternative would be a function which returns the array together with the element.
However, this would be cumbersome in many applications and misleading for proofs, since the function never modifies
the array. Note that the result type is not readonly although it is taken from a readonly array. Since it is nonlinear
there is no difference between being readonly or not.

If the element type is linear Gencot provides the abstract functions
\begin{verbatim}
  replacein_A'<size>'_El : (A'<size>'_El,UNN,El) -> (A'<size>'_El,El)
  modifyin_A'<size>'_El : (A'<size>'_El,UNN,#F_'El'_El) -> A'<size>'_El
\end{verbatim}
which are implemented in antiquoted C using the C array subscription operator \code{[]}. The first function
replaces the element at the specified position by the element passed as parameter and returns the old element in the result.
The second function applies the function pointer passed as parameter to the element at the specified position.
Note that both functions cause no sharing or discarding for the linear array element values. If the specified
index is not in the range \code{0..<size>-1} the \code{replacein}-function returns the same element which has been
passed as parameter and both functions return the unmodified array.

No equivalent for the Cogent take and put operations are provided for arrays with linear element type. It would be
necessary to statically encode the set of array indices for which the elements have been taken in the type expression,
this is not feasible.

For a readonly array it is possible to access elements directly, even if they are of linear type. Gencot provides
the abstract function
\begin{verbatim}
  get_A'<size>'_El : (A'<size>'_El!,UNN) -> Option El!
\end{verbatim}
for this purpose. Here the bang operator for the result type is relevant. The function is implemented by returning
the pointer to the element in the array without copying the element. This is safe since both the array and the element
type are readonly. If the specified index is not in the range \code{0..<size>-1} the function returns \code{None}.

\subsubsection{Dummy Expressions for Array Types}

Since dummy expressions are only used for function results and the result type of a C function may not be an array 
type, Gencot does not define a C expression for mapped array types.

\subsection{Function Types}
\label{design-types-function}

C function types of the form \code{t (...)} are used in C only for declaring or defining functions or
when a typedef name is defined for a function type. In all other
places they are either not allowed or automatically adjusted to the corresponding function pointer type
of the form \code{t (*)(...)}. 

In Cogent the distinction between function types and function pointer types does not exist. 
A Cogent function type of the form \code{T1 -> T2} is used both when
defining functions and when binding functions to variables. If used in a function definition, it is mapped by
the Cogent compiler to the corresponding C function type.

\subsubsection{Mapping Function Pointers}

In other places, however, Cogent does not translate its function types to C function pointers. Instead, it uses 
a C enumaration type where 
every known function has an associated enumeration constant. Whenever a function is bound to a variable, passed 
as a parameter or is invoked through a function pointer, it is represented by this enumeration constant in C, i.e., by an integer value.
For function invocation Cogent generates dispatcher functions which receive the integer value as an argument
and invoke the corresponding C function. 

Binary compatibility is only relevant when a function is stored, then it is always represented by the enumeration
constant in C generated from Cogent. Thus, a C function pointer type cannot be 
mapped by Gencot to a Cogent function type,
since this will not be binary compatible. Instead, it must be mapped to a Cogent abstract type together with 
abstract functions which translate between the abstract type and the Cogent function type (needed when invoking 
the function in Cogent).

Together, Gencot treats C function types and C function pointer types in completely different ways. It maps
C function types to Cogent function types and it maps C function pointer types to Cogent abstract types.

Mapping all C function pointer types to Cogent abstract types is the reason why names are generated for them, as
described in Section~\ref{design-names}. The goal is to use the same name for every occurrence of a C 
function pointer type. Thus it is infeasible to generate the name from 
the occurrence position (file name and line number). If an arbitrarily generated name would be used, 
Gencot could not separately compile different C files. If the parameter types would not be encoded in
the name, it would not be possible to define abstract Cogent functions for translating between the
abstract type and the Cogent function type.

Although the C function pointer is a pointer, the pointer target value (the machine code implementing the function) 
normally cannot be modified. Hence, semantically a function pointer type does not correspond to a linear type
in Cogent, it could be represented by a readonly type or by an unboxed type. Gencot uses an unboxed type
since all other types are also mapped to either boxed or unboxed types. 

Together the rule for mapping a function pointer type is
\begin{verbatim}
  t0 (*)(t1, ..., tn) -> #F_'T1'...'Tn'_T0
\end{verbatim}
where \code{Ti} is the name to which \code{ti} is mapped.
If a \code{ti} is mapped to a type name with the unbox operator applied, which is not a function pointer type,
a letter ``U'' is prepended to \code{Ti} in the form of a derivation step. This can only happen for struct and union types
since array and function types are adjusted to pointer types when used as parameter type, and are not allowed as 
function result types in C. In particular, if a parameter type \code{ti} is an array type, it is mapped to
the name for the linear case. For example, the C function pointer type \code{int (*)(int, int[10])} is mapped to
\begin{verbatim}
  #F_'U32'A'10'_U32'_U32
\end{verbatim}

\subsubsection{Translating Function Pointer Values}

For the values of the abstract type for function pointers in Cogent there are two relevant operations: invoking
it as a function and converting a Cogent function to a value of that type. Both are supported by Gencot
by automatically defining abstract functions for the task.

The latter operation is supported for every mapped function pointer type by the abstract function
\begin{verbatim}
  to_<name>: <Cogent function type> -> <name>
\end{verbatim}
where \code{<name>} is the mapped name of the function pointer type.

Invoking a function can be supported in two different ways. The first approach is by an abstract function
\begin{verbatim}
  from_<name>: <name> -> <Cogent function type>
\end{verbatim}
which translates the function pointer to the Cogent function (equivalent to the enumeration value) which
then can be invoked in the usual way in Cogent. The second approach is by an abstract function 
\begin{verbatim}
  invk_<name>: (<name>, <argument types>) -> <result type>
\end{verbatim}
which internally translates and invokes the function and returns its result.

If the first approach is used, all functions which are passed to Cogent as a parameter or as a field in a record must be known to
Cogent so that there is an enumeration constant for it. It is not possible to pass a pointer to an arbitrary 
C function to Cogent, the function must either be defined in Cogent or it must be defined as an abstract function 
in Cogent. Moreover, if no function of the \code{<Cogent function type>} is defined in the Cogent program, the
generated C code from an invocation in Cogent is incomplete, since it invokes the dispatcher function which does
not exist.

The second approach always causes correct C code to be generated by the Cogent compiler, however, since the functions
invoked from function pointers are not known to Cogent, they cannot be taken into account by Cogent proofs.

For simplicity, the current Gencot version only supports the second approach.

Hence for example the C type
\begin{verbatim}
  int *()(int, short)
\end{verbatim}
is translated to the definitions
\begin{verbatim}
  type F_'U32'U16'_P_U32
  to_F_'U32'U16'_P_U32: ((U32,U16) -> P_U32) -> #F_'U32'U16'_P_U32
  invk_F_'U32'U16'_P_U32: (#F_'U32'U16'_P_U32,U32,U16) -> P_U32
\end{verbatim}

\subsubsection{Mapping Function Parameters}

In Cogent every function
has only one parameter. To be mapped to Cogent, the parameters of a C function with more than one parameter must
be aggregated in a tuple or in a record. A C function type \code{t (void)} which has no parameters is mapped
to the Cogent function type \code{() -> T} with a parameter of unit type.

The difference between using a tuple or record for the function parameters is that the fields in a 
record are named, in a tuple they are not. In 
a C function definition the parameters may be omitted, otherwise they are specified with names in a prototype.
In C function types the names of some or all parameters may be omitted, specifying only the parameter type.

It would be tempting to map C function types to Cogent functions with a record as parameter, whenever parameter 
names are available in C, and use a tuple as parameter otherwise. However, in C it is possible to assign a 
pointer to a function which has been defined 
with parameter names to a variable where the type does not provide parameter names such as in 
\begin{verbatim}
  int add (int x, int y) {...}
  int (*fun)(int,int);
  fun = &add;
\end{verbatim}
This case would result in Cogent code with incompatible function types.

For this reason we always use a tuple as parameter type in Cogent. Cogent tuple types are equivalent, if they
have the same number of fields and the fields have equivalent types. To preserve the C parameter names in 
a function definition, the parameter is matched with a tuple pattern containing variables of these
names as fields.

C function types where the parameters are omitted, such as in \code{t ()} (``incomplete function type'') 
or where a variable number of
parameters is specified such as in \code{t (...)} (``variadic function type'') cannot be mapped to a Cogent 
function type in this way. 
They can only be mapped using an abstract type as parameter type. This can again lead to incompatible 
Cogent types if a function pointer is assigned where parameters have been specified, these cases must 
be treated manually in specific ways. Gencot maps incomplete function types to a Cogent function type with the
single abstract parameter type \code{Unknown_Cogent_Parameters}. The corresponding function pointer types
have the form \code{F\_Unknown\_Cogent\_Parameters\_<result type>}. Gencot maps variadic function types
with an additional last parameter type \code{Variadic\_Cogent\_Parameters} (without unbox operator applied).

All function pointers are represented by an integer in Cogent, hence a C function pointer type could be 
mapped (through the from/invk/to translation functions) to an arbitrary Cogent function type.
Of course, to be useful the types of the parameters and result should be mapped as well. This is done
in the same way as described above for function types.

Together the rules for mapping function types (and function pointer types through the from/invk/to translation 
functions) are
\begin{verbatim}
  t(t1, ..., tn) -> (T1, ..., Tn) -> T
  t(void) -> () -> T
  t(t1,...,tn,...) -> (T1, ..., Tn, Variadic_Cogent_Parameters) -> T
  t() -> Unknown_Cogent_Parameters -> T
\end{verbatim}

\subsubsection{Linear and Readonly Parameter Types}

Like every other type, the type of a function parameter may be readonly because this property can be derived
from the C type information, as described in Section~\ref{design-types-readonly}. However, in a C program 
often a parameter is actually never modified, although this property cannot be derived from the C type information.
Since this is an important property for working with linear types in Cogent, Gencot tries to capture these
cases as well and make the parameter type readonly.

For a parameter with linear type, the function can only be defined in Cogent if the parameter is not discarded,
i.e. it must be part of the result. Gencot assumes the most simple handling of this case, where the result
is a tuple consisting of the original result of the C function together with a component for every parameter
of linear type. To avoid these extra result components, Gencot tries to make all parameters with linear type
readonly and add only the remaining parameters to the result type.

A parameter of linear type may not be discarded in Cogent, but it may be passed to an abstract function which discards
it. In this case the parameter must not be returned, although it does not have readonly type.

Gencot determines the information about parameter modification and parameter discarding in a semi-automatic way
as described in Section~\ref{design-parmod}. It uses this information to make parameter types readonly or
add parameters to the function result, according to the following rules:
\begin{itemize}
\item If the C type of a parameter is not linear according to Section~\ref{design-types-readonly}, or if it
is discarded according to Section~\ref{design-parmod}, it is translated as described before.
\item Otherwise, if the C type of the parameter is readonly according to Section~\ref{design-types-readonly}, or
is not modified according to Section~\ref{design-parmod} its translated type is made readonly by applying the
bang operator \code{!}. For a single such parameter of type \code{r} the translation rule becomes
\begin{verbatim}
  t(t1, ... r, ... tn) -> (T1, ... R!, ... Tn) -> T
\end{verbatim}
\item Otherwise, if the parameter is already returned as result of the function, it is translated as described before.
\item Otherwise, the function result is changed to a tuple and the parameter is added as component to that tuple.
For a single such parameter of type \code{l} the translation rule becomes
\begin{verbatim}
  t(t1, ... l, ... tn) -> (T1, ... L, ... Tn) -> (T,L)
\end{verbatim}
\end{itemize}

If the result is modified to a tuple, the first component is the original function result and the remaining components
are the parameters of linear type in their order as they occur in the parameter tuple.

The dummy result expression is then built as a tuple with a dummy result as the first component and the unmodified
parameters as the remaining components.

\subsubsection{Linear and Readonly Parameter Types for Function Pointers}

Since function pointer types shall be translated to function types through the from/invk/to translation functions, the 
information about linear and readonly parameter types must also be available for them. Moreover, the same C function
pointer type may be mapped to two different Cogent types depending on whether a certain parameter is modified or not. 

To support this the information about linear and readonly parameter types is coded into the Cogent type name as follows.
If the parameter type is readonly or it is linear but the parameter is not modified by the function the mapped
parameter type is prepended with a letter ``\code{R}'' in the form of an additional derivation step (i.e. separated by 
an underscore if the parameter type is not derived). Otherwise, if the parameter type is linear and the parameter is 
neither discarded nor returned as the function result, the mapped parameter type is prepended with a 
letter ``\code{L}'' in the same way. Otherwise, the mapped parameter type is unchanged.

Note that the result tuple used for linear parameter types is not coded directly into the type, it must be 
reconstructed from the parameter type information (all parameters with a prepended ``\code{L}''). 

As an example consider the C function pointer type
\begin{verbatim}
  int (*)(char[4], const char*)
\end{verbatim}
where the first parameter may be modified by the function referenced by a pointer of that type.
The type is translated to the Cogent type name
\begin{verbatim}
  F_'LA'4'_U8'RP_U8'_U32
\end{verbatim}
which is translated by the from/invk/to functions to the Cogent function type
\begin{verbatim}
  (A'4'_U8,P_U8!) -> (U32,A'4'_U8)
\end{verbatim}
If the first parameter is known to be never modified, the Cogent typename instead will be
\begin{verbatim}
  F_'RA'4'_U8'RP_U8'_U32
\end{verbatim}
and the corresponding Cogent function type will be
\begin{verbatim}
  (A'4'_U8!,P_U8!) -> U32
\end{verbatim}

\subsubsection{Dummy Expressions for Function Types}

In the same way as for struct and union types, Gencot automatically defines an 
abstract function from the unit type to every abstract Cogent type \code{FT} for a C function pointer type:
\begin{verbatim}
  dummy_FT: () -> #FT
\end{verbatim}

Then the dummy expression for type \code{\#FT} is \code{dummy\_FT ()}. Since dummy expressions are only used 
for function results and the result type of a C function may not be a function
type, Gencot only defines dummy expressions for C function pointer types.

\subsection{Pointer Types}
\label{design-types-pointer}

In general, a C pointer type \code{t*} is the kind of types targeted by Cogent linear types. The linear type 
allows the Cogent compiler to statically guarantee that pointer values will neither be duplicated nor 
discarded by Cogent code, it will always be passed through. 

If a pointer points to a C \code{struct} there is additional support for field access available in Cogent by 
mapping the pointer to a Cogent boxed record type. For all other pointer types this support can be employed by
mapping the type to a Cogent record with a single field of the type referenced by the pointer.

\subsubsection{Mapping Pointer Types}

A pointer to a function type is mapped to an unboxed abstract type, as described above.

A pointer type \code{t*} to a struct is mapped to the corresponding boxed type, 
that means, it is mapped like the struct type \code{t}, but the unbox operator is omitted.

A pointer type \code{t*} where \code{t} is a union type is mapped in the same way to the corresponding
boxed type, omitting the unbox operator from the mapped type \code{t}. Thus no support for accessing
the referenced union is provided. The reason is, that access to the union as a whole is mostly useless
and furthe access to the union mebers cannot be provided. For consistency, Gencot treats union types
in the same way as struct types.

A pointer type \code{t*} where \code{t} is an array type is mapped in a similar way as for struct and
union types. As described in Section~\ref{design-types-array}, the array type name for the nonlinear case is
used omitting the unbox operator. The reason is, that access to the array yields the unboxed array for
which there is no support for working with it. In C, arrays cannot be asssigned as a whole, therefore
the array cannot be bound to a variable in Cogent.

A pointer type \code{t*} where \code{t} is a primitive type, an enum type, 
or again a pointer type is mapped to a boxed record with a single field \code{cont} of the type to which \code{t} is 
mapped. For every such type a name is introduced as described in Section~\ref{design-names}. This makes the 
Cogent program slightly more readable and the name is required as parameter type name in mapped function pointer 
types as described in Section~\ref{design-types-function}. For the same reason Gencot does not use a single generic type for all 
such pointer types. Instead, like for arrays, it creates a monomorphic type for every pointer type used in the program.

The resulting type is defined in the form
\begin{verbatim}
  type P_<type name> = { cont: <type name> }
\end{verbatim}
If the \code{<type name>} is a mapped derived type the underscore is omitted.

Values of such types are binary compatible to the C pointer type and they can be dereferenced with the help of
the Cogent take and put operations, thus supporting the full functionality of the C pointer.

Finally, a pointer to \code{void} is mapped to the abstract type
\begin{verbatim}
  type P_Void
\end{verbatim}
Here the type of the referenced data is unknown and no support for dereferencing it can be provided in Cogent,
all processing must be implemented by specific abstract functions.

Together we have the mapping rules for pointer types:
\begin{verbatim}
  void * -> P_Void
  r (*)(...) -> #F_'...'_R
  struct s * -> Struct_s = { ... }
  union s * -> Union_s
  (*el)[...] -> UA'...'_El
  otherwise: t * -> P_T = { cont: T }
\end{verbatim}
where \code{Struct\_s} and \code{Union\_s} are the names introduced for the struct or union types and \code{R}, \code{El} 
and \code{T} are the Cogent type names to which \code{r}, \code{el} and \code{t} are mapped, respectively. If \code{El} 
and \code{T} are derived, the underscore is omitted.

\subsubsection{Creating and Disposing Pointers}

Since all pointer types are mapped to Cogent linear types, Cogent does not provide support for creating values
of these types. In C a pointer can be created using the address operator \code{\&} or by allocating data on
the heap using a C standard function such as \code{malloc}. The address operator is supported by Gencot
only for data on the heap, as explained in Section~\ref{app-trans-addrop}. Therefore, the basic functionality
for pointer creation is allocation on the heap. This must be provided as an abstract Cogent function implemented
in antiquoted C.

Since values of a linear type cannot be discarded in Cogent, another abstract Cogent function is required for
disposing such values, implemented in antiquoted C by using the C standard function \code{free}.

Gencot automatically generates the Cogent abstract function definitions and their implementations in antiquoted
C for every linear non-abstract type \code{T} (i.e., every record type) used in the Cogent program as follows:
\begin{verbatim}
  create_T : () -> T take (..)
  dispose_T : T take (..) -> ()
\end{verbatim}
The \code{create\_T} functions only allocate space on the heap but do not initialize it, hence the result is 
represented in Cogent by a record with all fields taken. They can be filled using the Cogent put operation.
The \code{dispose\_T} functions expects a record with all fields taken and simply frees the heap space. In particular,
this forces that all fields of linear type must have been taken and must be disposed separately.

Linear abstract types are used for unions, arrays and void pointers. Functions for creating and disposing pointers
to unions are not provided by Gencot. Functions for creating and disposing arrays are described in 
Section~\ref{design-types-array}.
For type \code{P\_Void}, as for dereferencing, no
automatic support for creating and disposing these pointers can be provided by Gencot.

\subsubsection{Dummy Expressions for Pointers}

To be able to provide dummy expressions for pointer types, Gencot automatically defines an 
abstract function from the unit type to all used pointer target types:
\begin{verbatim}
  struct s * -> dummy_Struct_s: () -> Struct_s
  union s * -> dummy_Union_s: () -> Union_s
  dummy_UA'...'_El: () -> UA'...'_El
  dummy_P_T: () -> P_T
\end{verbatim}
Again, as for structure and union types, Gencot does not 
provide C definitions for these abstract functions.

The dummy expression for type \code{Struct\_s} is \code{dummy\_Struct\_s ()} and analogously
for mapped union pointer types. The dummy expression for type \code{UA'...'\_El} is 
\code{dummy\_UA'...'\_El ()} and for type \code{P\_T} it is \code{dummy\_P\_T ()}.

\subsection{Defined Type Names}
\label{design-types-typedef}

In C a typedef can be used to define a name for every possible type. In principle, it would be possible to
map a typedef name by resolving it to its type and then mapping this type as described above. However, the
typedef name often bears information for the programmer, hence the goal for Gencot is to preserve this information
and map the typedef name to the corresponding Cogent type name which is defined by translating the typedef
to a Cogent type definition.

A typedef name can be used in C to derive a pointer type from it. The mapping of pointer types depends on 
the kind of base type, as described above. If the base type is a struct, union, or array type, 
the pointer type is mapped to the mapped typedef name omitting the unbox operator. If the base type is a function type,
the pointer type is mapped to the mapped typedef name with the unbox 
operator applied (as for all function pointer types). Otherwise, a type name of the form 
\code{P\_T} is used where \code{T} is the mapped typedef name.

Always mapping pointer types derived from typedef names with the help of \code{P\_T} would result in
the following situation for the case where a typedef name is defined for a struct:
\begin{verbatim}
  typedef struct s snam
  mapping: struct s -> #Struct_s
  mapping: struct s * -> Struct_s
  mapping: snam -> Cogent_snam
  mapping: snam * -> P_Cogent_snam
\end{verbatim}
where \code{Struct\_s} is the name of the Cogent record type corresponding to \code{struct s}. The problem here
is that \code{snam *} is mapped using \code{P\_T}, resolving to the Cogent type \code{P\_\#Struct\_s}
instead of \code{Struct\_s}, preventing access to the record in Cogent.

Therefore Gencot treats every typedef name resolving to a struct, union, or array type as if 
it would resolve to the corresponding pointer type. The plain name is mapped with the unbox operator 
applied, the pointer type derived from it is mapped without unbox operator applied. 

A typedef name resolving to a function type is also treated as if it would resolve to the corresponding 
function pointer type. The pointer type derived from it is mapped to the mapped typedef name with the
unbox operator applied (since it is a function pointer type). This implies that the plain name cannot
be mapped. However, that is no restriction, since a C typedef name for a function type can only be used
for constructing the corresponding C function pointer type, either explicitly or implicitly by adjustment.
In particular, it cannot be used for defining a function of that type, since a definition must always 
include the parameter names.

The resulting mapping rules are for function type names:
\begin{verbatim}
  tn -> #TN
  tn* -> #TN
\end{verbatim}
for names of function pointer types:
\begin{verbatim}
  tn -> #TN
\end{verbatim}
for names of a struct, union, or array type:
\begin{verbatim}
  tn -> #TN
  tn* -> TN
\end{verbatim}
and for all other type names:
\begin{verbatim}
  tn -> TN
\end{verbatim}
where \code{TN} is the name mapping of \code{tn}.

This implies, that also the Cogent type definitions generated from a C typedef have to be modified, if
the target type is a struct, union, or array type. In this case Gencot translates the typedef 
to a Cogent type definition which defines the mapped typedef name as a synonym 
for the corresponding boxed type in Cogent.

If the target type is a function type Gencot translates typedef to a Cogent type definition which
defines the mapped typedef name as a synonym for the translated function pointer type. Here, the unbox
operator can be applied either to the righthand side of the type definition or to every occurrence
of the mapped typedef name or both. Gencot applies it to both to make it apparent that in both cases
the type is not linear.

If the target type in a typedef is another typedef name Gencot resolves it to the final target type
before applying the rules above.

The type referred to by a typedef name may be external to the Cogent compilation unit, then the typedef name
is translated to an abstract Cogent type. Then also the function for the dummy expression of the referred
type is not available. Therefore, Gencot automatically defines abstract functions for the unboxed and 
boxed type for every translated typedef name definition in the same way as for structure and union types.
If the target type name is \code{TN} the abstract function definition is
\begin{verbatim}
  dummy_TN: () -> TN
\end{verbatim}
and for a function pointer type \code{FN}
\begin{verbatim}
  dummy_FN: () -> #FN
\end{verbatim}
and the dummy expression is \code{dummy\_TN ()} in both cases.

For a mapped struct or union type additionally the abstract function definition
\begin{verbatim}
  dummy_Unbox_TN: () -> #TN
\end{verbatim}
is generated. For an array or function type the unbox form is not generated because these types cannot occur
as function result types.

Then the dummy expression for type \code{TN} is \code{dummy\_TN ()} or \code{dummy\_Unbox\_TN ()} if 
TN is a mapped struct or union type.

\subsection{Linear and Readonly Types}
\label{design-types-readonly}

C types can be qualified as \code{const}. This means, the values of the type are immutable and could be stored in 
a readonly memory. A variable declared with a readonly type is initialized with a value and cannot be modified 
afterwards. The immutability of an aggregate type also implies that values cannot be modified by modifying parts: 
for a struct the fields cannot be modified and for an array the elements cannot be modified. This behavior corresponds 
to the behavior of all primitive and unboxed types in Cogent. 

If a C type is not qualified as \code{const}, stored values of the type may be modified. This may have non-local
effects if the stored value is shared (part of several other values). In Cogent, values of primitive and unboxed types
cannot be shared (only copies can be part of other values). Therefore a modification of the C value always corresponds to
replacing the value bound to a variable in Cogent. This can be represented by binding the new value to a variable
of the same name which will shadow the previous binding. Together, this means that a \code{const} qualifier is
irrelevant whenever a C type is translated to a primitive or unboxed type in Cogent.

The situation is different for C pointer types which are translated to linear types in Cogent. Values of linear types
may be modified using put and take operations in Cogent, but they are restricted in their use. Put and take operations
correspond to modifications of the value referenced by the pointer. Thus, a \code{const} qualification of the pointer
type is still irrelevant for them, however, a \code{const} qualification of the pointer's \textit{base type} means
that put and take operations are not possible. This case is supported by Cogent as readonly types, which are not
restricted in their use in the same way as linear types.

Note, however, that Cogent does not separate between pointers and their referenced values: the referenced value
is treated as part of the linear value. If the referenced value itself contains references, the values referenced
by them are also treated as part of the overall value. This implies, that a readonly type in Cogent corresponds to
a C pointer type with \code{const} qualified base type where all components with a pointer type recursively have
the same property.

It further implies, that a C type also corresponds to a linear type in Cogent, if it directly or indirectly 
\textit{contains} pointers where the base type is not \code{const} qualified. This may be the case for struct or union
types (members may have such pointer types) or for array types (the elements may have such a pointer type).

An exception are C pointers to functions. It is assumed that the function code cannot be modified, hence a C pointer 
to function is treated like a primitive type in Cogent.

Gencot tests every C type for being a pointer or containing a pointer. If this is the case, the translated Cogent 
type is known to be linear. The C type is then further tested whether all pointers have a \code{const} qualified
base type. If this is the case, the type is translated to a Cogent readonly type,
by applying the bang operator \code{!} to the type after translating it as described in Section~\ref{design-types-pointer}.

In particular, the readonly property is valid for all pointer types where the base type contains no pointers, such as
\code{const char*}.



% For a \code{const} qualified C structure type the fields may not be modified. This is equivalent to the behavior
% of an unboxed record in Cogent, the same mapping is used here.
% 
% For a \code{const} qualified C union type the fields may not be modified. This is equivalent to the behavior
% of all unboxed values in Cogent, the same mapping is used here.
% 
% An array of type \code{const t []} cannot be modified, hence it is fully supported by the corresponding 
% Cogent array type.
% 
% The primitive Cogent type \code{String} is mapped to C type \code{char*}. It is used to pass the usual 
% null terminated C strings through Cogent code. The characters in the string cannot be accessed in Cogent, 
% neither for replacing them nor for reading them. Thus, if the characters are not accessed, Cogent type
% \code{String} is a useful mapping for all kinds of C character arrays.
% 
% \begin{verbatim}
%   char[n], char[], unsigned char[n], unsigned char[], 
%      const char[n], const char[],
%      const unsigned char[n], const unsigned char[] -> String
%   char*, unsigned char*, const char*, const unsigned char* 
%      -> String, if used to access a C string
%   const el[n], const el[], const el* 
%      -> El[n], if n can be statically determined
%   const el[], const el* 
%      -> abstract type, if array size cannot be statically determined
%   el[n], el[], el* -> abstract type
%   const t* -> T[1], if t contains no pointers
% \end{verbatim}
% 
% For a C pointer there are two cases of readonly types. A ``pointer to const'' type of the form \code{const t*}
% means that the data structure pointed to cannot be modified, whereas the pointer itself can be replaced 
% (if, e.g., it is stored in a variable of that type). A ``constant pointer'' type of the form \code{t* const}
% instead means that the pointer itself cannot be modified, whereas the data structure pointed to can. In Cogent 
% no difference is made between the pointer and its target, both together are always immutable, which corresponds 
% to the combination of both C cases. However, for linear types, Cogent internally supports modification of the
% data structure using \code{put} and \code{take}. The Cogent readonly types prevent this, therefore they correspond
% to the first case in C. The second case is always respected by Cogent, if a pointer should be replaced, this 
% must be implemented by an adequate processing approach in Cogent. 
% 
% In C a \code{t*} pointer can be assigned to a \code{const t*} pointer, but not vice versa. This corresponds to
% the Cogent property that a linear value may be made readonly, but not the other way round.

