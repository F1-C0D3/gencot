The goal of this step is to translate a single C source file which is part of the translation set to Cogent.
This is done by first using Gencot to translate the file to Cogent with embedded partially translated C code,
and then manually translating the embedded C code.

The translated file is either a \code{.c} file which can be seperately compiled by the C compiler as a compilation unit,
or it is a \code{.h} file which is a part of one or more compilation units by being included by other files. In both cases
the file can include \code{.h} files, both in the package and standard C include files such as \code{stdio.h}.

\subsection{Automatic Translation by Gencot}
\label{app-trans-auto}

To be translated by Gencot the C source file must first be prepared for being read by Gencot as described in
Section~\ref{app-prep}. Then the parameter modification descriptions for all functions and function types defined 
in the source file must be created and evaluated as described in Section~\ref{app-parmod-defined}. 

A \code{.c} file is translated using the command
\begin{verbatim}
  gencot [options] cfile file.c [<parmod>]
\end{verbatim}
where \code{file.c} is the file to be translated and \code{<parmod>} is the file containing the parameter modification 
descriptions. If it is not provided, Gencot assumes for all functions and function types, that linear parameters 
may be modified. The result of the translation is stored as \code{file.cogent} in the current directory.

An \code{.h} file is translated using the command
\begin{verbatim}
  gencot [options] hfile file.h [<parmod>]
\end{verbatim}
where \code{file.h} is the file to be translated and \code{<parmod>} is as above. The result of the translation is 
stored as \code{file-incl.cogent} in the current directory.

Special support is provided for translating configuration files. A configuration file is a \code{.h} file mainly
containing preprocessor directives for defining flags and macros, some of which are deactivated by being ``commented
out'', i.e., they are preceded by \code{//}. If such a file is translated using the command
\begin{verbatim}
  gencot [options] config file.h [<parmod>]
\end{verbatim}
it is translated like a normal \code{.h} file, but before, all \code{//} comment starts at line beginnings are 
removed, and afterwards the corresponding Cogent comment starts \code{--} are re-inserted before the definitions.

\subsection{Manual Translation of C Function Bodies}
\label{app-trans-manbody}

The manual part of the translation is mainly required for the bodies of all C functions defined in the C source file.
A \code{.h} file normally does not contain function or object definitions, then it may be the case that no manual actions 
are necessary. But some \code{.h} files define functions, typically as \code{static inline}, then also their bodies
must be translated manually.

The manual translation is done by modifying the \code{.cogent} file generated by the automatic translation in an 
editor. As described in Section~\ref{design-fundefs-body}, the result of automatically translating a function
definition has the form
The generated Cogent function definition has the form
\begin{verbatim}
  <name> :: (<ptype1>, ..., <ptypen>) -> <restype>
  <name> (<pname1>, ..., <pnamen>) = <dummy result>
  {- <compound statement> -}
\end{verbatim}
where the \code{<compound statement>} is plain C code with global names mapped to Cogent. The task of the manual
translation is to replace the \code{<dummy result>} by a Cogent expression equivalent to the \code{<compound statement>}.

In the following sections we provide some patterns how to translate typical C constructs occurring in a
\code{<compound statement>}.

\subsection{Function Pointer Invocation}
\label{app-trans-funpointer}

In C a function pointer may be \code{NULL}, therefore it is typically tested for being valid before the
referenced function is invoked, such as in 
\begin{verbatim}
  if( fptr == NULL ) ...
  else fptr( params );
\end{verbatim}
We assume that fptr shall have a type which is binary compatible to the function pointer type in C.
This prevents to use a Cogent type \code{Option a} as the natural equivalent of a value that may be undefined.
\code{Option a} is a Cogent variant type and is not binary equivalent to the C function pointer type.

If \code{fptr} is a member of a C struct, it would be possible to use a Cogent record with a taken field,
if the function pointer is undefined. Then it would be clear from the record type whether the function pointer
is valid and can be invoked. However, this would require two implementations for all functions with such a records 
as parameter, which is usually infeasible.

The generic type \code{MayNull} (see Section~\ref{app-trans-null} cannot be used for function pointers since
it is linear and the corresponding abstract functions expect values of the boxed type, whereas function pointers
are always represented by an unboxed type.

The simplest solution is to assume that function pointers are always defined. Instead of using the value 
\code{NULL}, they must then be set to point to a default function. Then no test is required, the function
can simply be invoked in Cogent.

Note that to be binary compatible the Cogent type of \code{fptr} is an abstract type of the form \code{\#F\_...}.
To invoke the referenced function the translation function \code{invkFunPtr} must be used (see 
Section~\ref{design-types-function}). 

For example, if the function pointer is declared in C as 
\begin{verbatim}
  int (*fptr)(int arg1, const char *arg2);
\end{verbatim}
the corresponding invocation in Cogent would be
\begin{verbatim}
  invkFunPtr (fptr,arg1,arg2)
\end{verbatim}
with result type \code{U32}.

\subsection{The Null Pointer}
\label{app-trans-null}

Translating C code which uses the \code{NULL} pointer is supported by the abstract data type \code{MayNull} defined
in \code{include/gencot/MayNull.cogent} (see Section~\ref{design-operations-null}).

A typical pattern in C is a guarded access to a member of a struct referenced by a pointer:
\begin{verbatim}
  if (p != NULL) res = p->m;
\end{verbatim}
In Cogent the value \code{p} has type \code{MayNull R} where \code{R} is the record type with field \code{m}. 
Then a translation to Cogent is
\begin{verbatim}
  let res = roNotNull p 
            | None -> dflt
            | Some s -> s.m
      !p
\end{verbatim}
Note that a value \code{dflt} must be selected here to bind it to res if the pointer is \code{NULL}. Also note that the access is
done in a banged context for p. Therefore it is only possible if the type of \code{m} is not linear, since otherwise the result
cannot escape from the context.

Another typical pattern in C is a guarded modification of the referenced structure:
\begin{verbatim}
  if (p != NULL) p->m = v;
\end{verbatim}
A translation to Cogent is
\begin{verbatim}
  let p' = notNull p 
           | None -> null ()
           | Some s -> mayNull s{m = v}
\end{verbatim}
where the reference to the modified structure is bound to \code{p'}. Note that in the none-case the result cannot be specified as 
\code{p} since this would be a second use of the linear value \code{p} which is prevented by Cogent.

Alternatively this can be translated using the function \code{modifyNull}:
\begin{verbatim}
  let p' = fst (modifyNull (p, (setMInP, v)))
\end{verbatim}
where the function used for modifying the structure is defined as
\begin{verbatim}
  setMInP: ModFun P M ()
  setMInP (s,v) = (s{m = v}, ())
\end{verbatim}
and \code{M} is the type of field \code{m}.

\subsection{The Address Operator \code{\&}}
\label{app-trans-addrop}

The address operator \code{\&} is used in C to determine a pointer to data which is not yet accessed through a 
pointer. The main use cases are
\begin{itemize}
\item determine a pointer to a local or global variable as in the example
\begin{verbatim}
  int i = 5;
  int *ptr = &i;
\end{verbatim}

\item determine a pointer to a member in a struct as in the example
\begin{verbatim}
  struct ii { int i1; int i2; } s = {17,4};
  int *ptr = &(s.i2);
\end{verbatim}

\item determine a pointer to an array elemnt as in the example
\begin{verbatim}
  int arr[20];
  int *ptr = &(arr[5]);
\end{verbatim}

determine a pointer to a function as in the example
\begin{verbatim}
  int f(int p) { return p+1; }
  ...
  int *ptr = &f;
\end{verbatim}
\end{itemize}

In all these cases the pointer is typically used as reference to pass it to other functions or store it
in a data structure.

The binary compatible Cogent equivalent of the pointer is a value of a linear type. However, there is
no Cogent functionality to create such values. Hence it must be implemented by an abstract function.

\subsubsection{Address of Variable}

In the first use case there are several problems with this approach. First, there is no true equivalent
for C variables in Cogent. Second, it is not possible to pass the variable to the implementation of the
abstract function, without first determining its address using the address operator. Third, if the address
operator is applied to the variable in the implementation of the abstract function, the Isabelle c-parser
will not be able to process the abstract function, since it only supports the address operator when 
the result is a heap address.

All these problems can be solved by allocating the variable on the heap instead. Then the variable definition
must be replaced by a call to the (abstract) creation function for the corresponding linear type 
(see Section~\ref{design-types-pointer}) and 
at the end of its scope a call to the (abstract) dispose function must be added. Then the address
operator need not be translated, since the creation function already returns the linear value which can be 
used for the same purposes. The resulting Cogent code would be
\begin{verbatim}
  let ptr = create[P_U32] () {cont = 5}
  in dispose (...ptr...)
\end{verbatim}
where the argument of \code{dispose} is an expression which uses and returns the \code{ptr} in the 
usual way for a value of linear type.

\subsubsection{Address of Struct Member}

The second use case cannot be translated in this way, since the referenced data is a part of a larger structure.
If it is separated from the structure and allocated on the heap, the structure is not binary compatible any more.

If the overall structure is not allocated on the heap, the same three problems apply as in the first use case.
This can be solved in the same way, by moving the overall structure to the heap. Then it can be represented
by the linear Cogent type
\begin{verbatim}
  type Struct_Cogent_ii = { i1: U32, i2: U32 }
\end{verbatim}

If the overall structure in Cogent is readonly an abstract function of the form
\begin{verbatim}
  accessI2InCogent_ii : Struct_Cogent_ii! -> P_U32!
\end{verbatim}
can be used to access the Cogent field through a pointer. This is an instance of the general \code{access} operation
for records as described in Section~\ref{design-operations-record}.

If the overall structure is modifyable, determining a pointer to the field would introduce sharing for the
field, since it can be modified through the pointer or by modifying the structure. A safe solution is an 
abstract function of the form
\begin{verbatim}
  modifyI2InCogent_ii : all(arg,out). 
    ModPartFun Struct_Cogent_ii P_U32 arg out
\end{verbatim}
which is an instance of the general \code{modify} operation
for records as described in Section~\ref{design-operations-record}.

\subsubsection{Address of Array Element}

The third use case is similar to the second. It often occurs if the array itself is represented by a pointer to its first
element (see Section~\ref{app-trans-arrpoint}). This case can simply be replaced by using the element index instead of a 
pointer to the element. The array index is nonlinear and thus easier to work with. However, this solution is not binary
compatible, if the element pointer is also accessed outside the Cogent compilation unit.

A binary compatible solution can be achieved in a similar way as for struct members. The first prerequisite for it is
to allocate the array on the heap.

Then the polymorphic functions \code{accessArr} and \code{modifyArr} (see Section~\ref{design-types-array}) can be used
for working with pointers to elements.

\subsubsection{Address of Function}

The last use case is translated in a specific way for function pointers, using the translation function
\code{toFunPtr} (see Section~\ref{design-types-function}), which is generated by Gencot for all function
pointer types. The resulting Cogent code has the form
\begin{verbatim}
  Cogent_f : U32 -> _U32
  Cogent_f p = p+1
  ...
  let ptr = toFunPtr Cogent_f
  in ...
\end{verbatim}
In this case \code{ptr} has the nonlinear type \code{\#F\_'U32'\_U32} in Cogent and may freely be copied and
discarded in its scope.

\subsection{Using Pointers for Array Access}
\label{app-trans-arrpoint}

A common pattern in C programs is to explicitly use a pointer type instead of an array type for referencing an array,
in particular if the array is allocated on the heap. This is typically done if the number of elements in the
array is not statically known at compile time. The C concept of variable length array types can sometimes be
used for a similar purpose, but is restricted to function parameters and local variables and cannot be used for
structure members.

In C the array subscription operator can be applied to terms of pointer type. The semantics is to access an element 
in memory at the specified offset after the element referenced by the pointer. This makes it possible to use 
a pointer as struct member which references an array as in
\begin{verbatim}
  struct ip {... int *p, ...} s;
\end{verbatim}
and access the array elements using the subscription operator as in \code{s.p[i]}.

Gencot translates the struct type to a record type of the form
\begin{verbatim}
  type Struct_Cogent_ip = {... p: P_U32, ...}
\end{verbatim}
and does not generate abstract functions which allow to treat \code{p} as an array, this must be done manually.

The main problem here is the unknown array size. In the C program, however, for working with the array it must be
possible to determine the array size in some way at runtime. Here we distinguish two approaches how this is done.

In the first case the array size can always be determined from the array content. Then the pointer to the first 
element is always sufficient for working with the array. The two typical patterns of this kind either use a 
stop element to mark the array end, such as the zero character ending C strings, or store the array size in a
specific element or elements, such as in a network package represented as a byte array.

Working with the array is supported by manually defining and implementing an abstract data type for the array as follows.
Let \code{tt} be a unique name for the specific kind of array (how its size is determined) and let \code{El} be the
name of the array element type. We use \code{CArray\_tt\_El} as type name for the array, thus the 
type of \code{p} must be manually changed as follows:
\begin{verbatim}
  type Struct_Cogent_ip = {... p: CArray_tt_El, ...}
\end{verbatim}

For the type \code{CArray\_tt\_El} the polymorphic function \code{create} cannot be used since no instance has been
generated by Gencot for it. An abstract function of the form
\begin{verbatim}
  create_CArray_tt_El : UNN -> TCArray_tt_El
\end{verbatim}
must be defined and implemented manually. It takes the actual array size (number of elements) as argument. The type \code{UNN} must be
chosen by the developer so that it can represent all sizes which are used for the array. It is also used for the index
values below. The type 
\code{TCArray\_tt\_El} is used for the uninitialized array, corresponding abstract functions for initializing
and freeing the array elements must be provided.

The implementation in antiquoted C has the following form:
\begin{verbatim}
  typedef el *CArray_tt_El, *TCArray_tt_El;
  
  $ty:TCArray_tt_El $id:create_CArray_tt_El($ty:U32 size) { 
    return calloc(size,sizeof(el));
  }
\end{verbatim}

For disposing values of the array type the usual polymorphic function \code{dispose} can be used, its implementation in
antiquoted C automatically provides instances for all types for which it is used.




The element access functions are defined in the same way as for array types (see Section~\ref{design-types-array}. 
In the case of a non-linear element type they are:
\begin{verbatim}
  get_CArray_tt_El : (CArray_tt_El!,UNN) -> Option El
  put_CArray_tt_El : (CArray_tt_El,UNN,El) -> CArray_tt_El
\end{verbatim}
and for a linear element type:
\begin{verbatim}
  get_CArray_tt_El : (CArray_tt_El!,UNN) -> Option El!
  replacein_CArray_tt_El : 
        (CArray_tt_El,UNN,El) -> (CArray_tt_El,El)
\end{verbatim}
Functions for accessing the element through a pointer (see Section~\ref{app-trans-addrop}) are in both cases:
\begin{verbatim}
  access_CArray_tt_El : (CArray_tt_El!,UNN) -> Option P_El!
  modify_CArray_tt_El : all(a). ModFun CArray_tt_El (UNN,(P_El,a)->P_El, a)
\end{verbatim}

In the second case the array size is determined by additional information separate from the pointer to the array.
Either the size is specified as an integer value as in 
\begin{verbatim}
  struct ip {... int *p, int psize; ...} s;
\end{verbatim}
or it is specified by a second pointer, e.g., pointing to the last element as in
\begin{verbatim}
  struct ip {... int *p, int *pend; ...} s;
\end{verbatim}
In general there may be additional information, such as pointers into the array which are used to reference
``current'' positions in the array. We assume that all this information is provided by a sequence of members
in the surrounding struct:
\begin{verbatim}
  struct ip {...; t1 m1;...tn mn; ...} s;
\end{verbatim}
When working with the array all additional information is required, therefore it must be included in the abstract
type. This is achieved by replacing the sequence of variables containing information about the array by a single
field of the array type in Cogent:
\begin{verbatim}
  type Struct_Cogent_ip = {... a: #SArray_tt_El, ...}
\end{verbatim}
with the array type being defined in C as
\begin{verbatim}
  typedef struct { t1 m1;...tn mn; } SArray_tt_El;
\end{verbatim}
This makes the Cogent type \code{Struct\_Cogent\_ip} binary compatible with the C type \code{struct ip} and it allows
to represent several groups of related members in the struct by a common abstract type. Of course this approach is 
only possible if the members are contiguous in the struct.

To modify the group in the struct the abstract modification function 
\begin{verbatim}
  modifyAInStruct_Cogent_ip: all(a). 
    ModPartFun Struct_Cogent_ip SArray_tt_El 
               ((Struct_Cogent_ip take a)!,a)
\end{verbatim}
is used in the same way as described in Section~\ref{app-trans-addrop}.

The functions for working with the array now look different from those above, since type \code{SArray\_tt\_El}
does not correspond to a pointer to the array elements, but to a pointer to the substructure with members describing
the array. The specific form and functionality of these functions depend on the actual members and their use.

