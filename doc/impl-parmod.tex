As described in Section~\ref{design-parmod} Gencot uses a parameter modification description in JSON format 
to be filled in collaboration with the developer to determine which function parameters may be modified during
a function call. 

\subsection{Description Structure}
\label{impl-parmod-struct}

This
description is structured as follows. It is a list of JSON objects, where each object is an entry which describes a function using
the following attributes:
\begin{verbatim}
    { "f_name" : <string>
    , "f_comments" : <string>
    , "f_def_loc" : <string>
    , "f_num_params" : <int> or <string>
       <parameter descriptions>
    , "f_num_invocations" : <int>
    , "f_invocations" : <list of invocation descriptions>
    }
\end{verbatim}

The attribute \code{f\_name} specifies a unique identifier for the function, as described in Section~\ref{impl-parmod-ids}.
The attribute \code{f\_comments} is not used by Gencot, it can be used by the developer to add arbitrary textual
descriptions to the function entry. The attribute \code{f\_def\_loc} specifies the name of the C source file containing
the definition of the function or functionn pointer (or its declaration, when the function entry has been 
generated for closing the JSON description). 

The attribute \code{f\_num\_params} specifies the number of parameters. In the case of a variadic function or a function
with incomplete type (which may be the case if the entry has been generated from a declaration), it is specified
as \code{"variadic"} or \code{"unknown"}, respectively.

All known parameters of the function are described in the \code{<parameter descriptions>}. 
Every parameter description consists of a single attribute where the parameter identifier (see Section~\ref{impl-parmod-ids})
is the attribute name. The value is one of the following strings:
\begin{description}
\item[\code{"nonlinear"}] According to its type the parameter is not a pointer and its value does not contain pointers directly or
indirectly.
\item[\code{"readonly"}] The parameter is not \code{"nonlinear"} but according to its type all pointers in the parameter have a \code{const} qualified referenced type.
\item[\code{"yes"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"} and it is directly modified by the function.
\item[\code{"discarded"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"} and it is directly discarded 
(``freed'') by the function. 
\item[\code{"depends"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"}, it is neither modified 
or discarded directly, but it may be modified by an invoked function. 
\item[\code{"no"}] None of the previous cases applies to the parameter.
\item[\code{"?"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"}, but the remaining properties are unconfirmed.
\item[\code{"?depends"}] The parameter is neither \code{"nonlinear"} nor \code{"readonly"} and it may be modified by an invoked function,
but the remaining properties are unconfirmed.
\end{description}

Gencot only generates parameter descriptions with the values \code{"nonlinear"}, \code{"readonly"}, \code{"yes"}, \code{"?"}, and \code{"?depends"}.
The first two can be safely determined from the C type. If Gencot finds a direct modification, it sets the description to 
\code{"yes"}. Otherwise, if it finds a dependency on an invocation, it sets the description to \code{"?depends"}. Otherwise
it sets it to \code{"?"}.

The task for the developer is to check all unconfirmed parameter descriptions by inspecting the source code. If a local modification
is found, the value must be changed to \code{"yes"}. Otherwise, if the description was \code{"?depends"} it must be confirmed 
by changing it to \code{"depends"}. Otherwise, if a dependency is found, the value \code{"?"} must be chaged to \code{"depends"},
otherwise it must be set to \code{"no"}.

Discarding a parameter is normally only possible by invoking the function ``free'' in the C standard library. No other function
can directly discard one of its parameters. However, a parameter may be discarded by invoking an external function which indirectly
invokes free. The task for the developer is to identify all these cases where an external function (where the entry has been
generated during closing the JSON description) discards one of its parameters and set its parameter description to \code{"discarded"}.

The attribute \code{f\_num\_invocations} specifies the number of function invocations found in the body of the described function.
If the same function is invoked several times, it is only counted once. The attribute \code{f\_invocations} specifies a list
of JSON objects where each object describes an invocation. If the function entry describes a function pointer or an external
function, no body is available, so no invocations can be found and both attributes are omitted. If no parameter depends on
any invocation, the second attribute (invocation list) is omitted, only the number of invocations is specified.

An entry in the list of invocations describes an invocation using the following attributes:
\begin{verbatim}
    { "name" : <string> 
    , "num_params" : <int> or <string>
      <argument descriptions>
    }
\end{verbatim}

The attribute \code{"name"} specifies the function identifier of the invoked function. The attribute \code{"num\_params"}
specifies the number of parameters according to the type of the invoked function, in the same way as the attribute
\code{"f\_num\_params}. If an invoked function has no parameters, no entry for it is added to the invocation list.

The \code{<argument descriptions>} describe all known arguments of invocations of the function. When Gencot creates an
invocation description, it inserts argument descriptions according to the maximal number of arguments found in an 
invocation of this function. Thus, also for invocations of incompletely defined or variadic functions, an argument
description is present for every actual argument used in an invocation.

Every argument description consists of a single attribute where the attribute name is the parameter identifier of the 
parameter corresponding to the argument. The value is one of the strings \code{"nonlinear"} or \code{"readonly"}
(according to the type of the parameter of the invoked function), or a list of parameter identifiers.

If the value is \code{"nonlinear"} or \code{"readonly"} parameter dependencies on this argument are irrelevant, since
the invoked function cannot modify or discard it. Otherwise, the list specifies parameters of the \textit{invoking}
function for which the modification or discarding depends on whether the invoked function modifies or discards this
argument.

The task for the developer is for all unconfirmed parameter descriptions of the invoking function to check whether
there are (additional) dependencies on arguments of invoked functions and add these dependencies to the argument 
descriptions.

\subsection{Identifiers for Functions and Parameters}
\label{impl-parmod-ids}

In the JSON description unique identifiers are needed for all described functions, so that they can be referenced by
invocations.

Functions can always be identified by their name. However, for functions with internal linkage the name is only unique
per compilation unit, whereas the JSON description may span several compilation units. Therefore, functions with 
external linkage are identified by their plain name (which is an unstructured C identifier), functions with
internal linkage are identified in the form
\begin{verbatim}
    <source file name> : <function name>
\end{verbatim}
If the source file name has extension \code{".c"} the extension is omitted, otherwise (typically in the case of \code{".h"})
it is not omitted, resulting in identifiers such as \code{"app.h:myfunction"}.

As source file name only the base name is used. C packages with source files of the same name in different directories are
not supported by the current Gencot version.

Function pointers can be identified by the pointer name. Note that several different functions may be invoked through
a function pointer at different times. However, for the analysis of parameter modifications \textit{all} functions
invokable through the pointer must be taken into account and together be described. Therefore a single id for the function
pointer is sufficient. To inform the developer that it is a function pointer, we prepend a star to the pointer name:
\begin{verbatim}
    * <function pointer name>
\end{verbatim}

A function pointer may be globally defined, then it may have external or internal linkage. In the latter case we
prepend the source file name to make it unique, as described above:
\begin{verbatim}
    <source file name> : * <function pointer name>
\end{verbatim}

A function pointer may also be locally defined in another function. To get a unique identifier we prepend the 
identifier of the containing function:
\begin{verbatim}
    <function identifier> / * <function pointer name>
\end{verbatim}
The JSON description contains only entries for functions which are defined or invoked. Function invocations can only
occur in function definitions which have a body. Therefore local function pointers are only relevant in defined
functions which cannot be function pointers themselves. This implies that a local function pointer id is always 
one-level consisting of a global function id and a function pointer name.

A function pointer may also be a member of a struct or union type. Here we do not differentiate between different instances 
of this type, we describe the members of all such instances together using an identifier of the form
\begin{verbatim}
    <tag> . * <member name>
\end{verbatim}
where \code{<tag>} is the tag name of the struct or union type. 

There are other cases of function pointers, such as function pointer members in anonymous struct or union 
types which are not named by a tag, or function pointer which are an array element. Gencot does not generate identifiers
for them and ignores invocations of such function pointers. It is the task of the developer to identify such invocations,
determine whether they are relevant for parameter modification dependencies, create a unique identifier for them and
add them manually to the JSON description. 

Whenever Gencot reads and processes a JSON parameter modification description it treats all function identifiers as
opaque unique strings, hence manually created function identifiers need not conform to the schema described above.

In the JSON description unique identifiers are also needed for all described function parameters, so that they can 
be referenced by argument descriptions. Since these references are always local in a function description, parameter
identifiers need only be unique per function. Therefore the C parameter name is usually sufficient as id in the 
JSON description.

However, the parameter name is not always available: If the function has an incomplete type no parameter names are
specified, if the function is variadic, only the names of the non-variadic parameters are specified. Therefore
Gencot always uses the position number as parameter id, where the first parameter has position 1. To make the JSON
description more readable for the developer, Gencot appends the parameter name whenever it is available. Together,
a parameter id is a string with one of the forms
\begin{verbatim}
    <pos>
    <pos>-<name>
\end{verbatim}
where \code{<pos>} is the position number and \code{<name>} is the declared parameter name.

Since all parameter identifiers are strings they can be used as JSON attribute names and since they always
start with a digit they can be recognized and do not conflict with other JSON attribute names. 

When Gencot reads and processes a JSON parameter modification description it removes the optional name from 
all parameter identifiers and uses only the position. Hence parameter identifiers are considered equal if they
begin with the same position.

\subsection{Example}

The following example illustrates the format of the parameter modification descriptions. It consists of two
function descriptions, one for a defined function with internal linkage and one for a function pointer parameter
invoked by that function.
\begin{verbatim}
[
    { "f_name" :"app:somefun" 
    , "f_comments" :"" 
    , "f_def_loc" :"app.c" 
    , "f_num_params" :5
    , "1-f_sort" :"nonlinear" 
    , "2-desc" :"readonly" 
    , "3-input" :"?depends" 
    , "4-size" :"nonlinear" 
    , "5-result" :"yes" 
    , "f_num_invocations" :2
    , "f_invocations" :
        [ 
            { "name" :"memcpy" 
            , "num_params" :3
            , "1-__dest" :[ "3-input" ]
            , "2-__src" :"readonly" 
            , "3-__n" :"nonlinear" 
            } 
        , 
            { "name" :"app:somefun/*f_sort" 
            , "num_params" :3
            , "1-arr" :[ "3-input" ]
            , "2-h" :[]
            , "3-len" :"nonlinear" 
            } 
        ] 
    } 
, 
    { "f_name" :"app:somefun/*f_sort"
    , "f_comments" :"" 
    , "f_def_loc" :"app.c" 
    , "f_num_params" :3
    , "1-arr" :"?" 
    , "2-h" :"?" 
    , "3-len" :"nonlinear" 
    } 
]
\end{verbatim}
The description is not closed, since it does not contain an entry for the invocation \code{memcopy}. This
invocation is required, since parameter \code{input} of \code{somefun} depends on its first argument
which is neither nonlinear nor readonly. If the description of parameter \code{input} is changed
to \code{"yes"}, the description is closed, since now the invocation \code{memcopy} is not required
anymore.

\subsection{Reading and Writing Json}
\label{impl-parmod-json}

Input and output of JSON data is done using the package \code{Text.Json}. There is another package \code{Data.Aeson} for
Json processing which supports a much more flexible conversion between JSON and Haskell types, but this is not
needed here.

The package \code{Text.Json} uses the type \code{JSValue} to represent an arbitrary JSON value. It provides the functions
\code{encode} and \code{decode} to convert between \code{JSValue} and the JSON string representation. Depending
on the kind of actual value, a \code{JSValue} can be converted from and to corresponding Haskell types using
the functions \code{readJSON} and \code{showJSON}. A JSON object is converted to the type \code{JSObject a} where
\code{a} is the type of attribute values, usually this is again \code{JSValue}. A \code{JSObject a} can be further
processed by converting it from and to an attribute-value list of type \code{[(String,a)]} using the functions
\code{fromJSobject} and \code{toJSObject}.

The Gencot parameter modification description is represented as a list of Json objects of type \code{[JSObject JSValue]}.
The same representatiom is used for the contained invocation description lists. For internal processing the objects
are converted to attribute-value lists. All processing of JSON data is directly performed on these lists.

A parameter modification description is read by applying the \code{decode} function to the input to yield a
list of \code{JSObject JSValue}. It is output by applying the \code{encode} function to such a list. 

Additionally,
the resulting string representation is formatted using the general prettyprint package \code{Text.Pretty.Simple}.
The function \code{pStringNoColor} is used since it does not insert control sequences for colored represenation
and produces a plainly formatted text representation. Its result is of type \code{Text} and must be converted to a
string using the function \code{unpack} from package \code{Data.Text}.

\subsection{Evaluating a Description}
\label{impl-parmod-eval}

A parameter modification description is complete, if all paremeter descriptions are confirmed and the description 
is ``closed'', i.e., has no required invocations. This implies that whenever a parameter is dependent on an invocation argument,
there is a function description present for the invoked function where the corresponding parameter is described.
This allows to eliminate all parameter dependencies by following them until an independent parameter description is found.
This process is called ``evaluation'' of the parameter modification description.

The result of evaluation is a simplified parameter modification description where the value \code{"depends"} does not 
occur anymore as parameter description. Additionally, all information about function invocations is removed, since it is
no more needed.

Evaluation only terminates, if there are no cyclic parameter dependencies. This property is checked by Gencot. If there
are cyclic parameter dependencies in the C code they must be eliminated manually by the developer by removing enough dependencies 
to break all cycles.

A parameter may have several dependencies, which may result in different description values. This cannot be the case for
the values \code{"nonlinear"} and \code{"readonly"}: If the parameter of the invoked function has nonlinear type, this
also holds for the passed parameter, no dependency can exist in this case. If the parameter of the invoked function has
a readonly type, the passed parameter can still have a linear type which is not readonly. But it cannot be modified by the
function invocation, hence no dependency can exist in this case either.

Thus, after evaluation, a parameter may have any subset of the values \code{"yes"}, \code{"discarded"}, and \code{"no"}, meaning 
that it may be modified by some invocations, discarded by some invocations, and not modified by others. This is reduced to
a single value as follows. The value \code{"no"} is only used if none of the other two is present. If both \code{"yes"}
and \code{"discarded"} are present, Gencot cannot decide whether the parameter is always discarded (perhaps after modification),
or always modified (perhaps after discarding and reallocating it). In this case it always assumes a modification and
uses the single value \code{"yes"}. If this is not correct it must be handled manually by the developer.

The reason for this treatment is that before evaluation Gencot gives a local modification a higher priority than a dependency,
to reduce the number of required invocations. This may hide a dependency which results in discarding the parameter. To
be consistent, Gencot also prefers modifications resulting from dependencies after evaluation over discarding. 

Since in evaluated parameter modification descriptions all parameter descriptions are still confirmed, the only values
possible for a parameter description are \code{"nonlinear"}, \code{"readonly"}, \code{"yes"}, \code{"discarded"}, and \code{"no"}.
This information is used by Gencot when translating function parameter and result types, as described in Section~\ref{design-parmod}.
