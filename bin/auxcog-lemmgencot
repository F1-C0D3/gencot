#! /bin/sh

# Generate an Isabelle theory for the Gencot lemma library for the HOL-tupled shallow embedding. Intended to be applied to 
# X_ShallowShared_Tuples.thy generated by Cogent.
# This is a filter from stdin to stdout with an additional filename argument.
# The argument file must contain a sequence of lines of the form
#   <id>: <id>

if [ $# != 1 ]
then
  echo "Error: Single file name expected as argument."
  exit 0
fi

awk \
'BEGIN { 
   cfile = ARGV[1]; delete ARGV[1]
   gencot_theories = "CArray"
   common_theories = "common"
   nr_sizes = 0
   nr_funs = split("getArr setArr modifyArr modrefArr", funs)
   nr_afuns = split("siz vld elm elm_update elm_modified elms_fill elms_list", afuns)
   nr_lems = split("unfold elm_commUpd_elm elm_distUpd elm_sameUpd eqArr eqElmUpd eqElmsFill elm_modified_def elms_list_def", lems)
   nr_cfuns = split("toCAES fromCAES", cfuns)
   nr_clems = split("inverse apply", clems)
 } 
{
  if ($1 == "theory" && NF == 2) {
    if ($2 ~ /_ShallowShared_Tuples$/) { tup = "_Tuples"; prfnam = substr($2,1,length($2)-21) }
    else {
      printf("Error: auxcog-lemmgencot input must be a theory named X_ShallowShared_Tuples.\n")
      exited = 1
      exit 1
    }
    printf("theory %s_Shallow_Gencot_Lemmas\n", prfnam)
    printf("  imports \"%s_Shallow_Gencot_Tuples\"\n", prfnam)
    while ((getline cline < cfile) > 0) { 
      if (2 == split(cline,a)) { 
        if (a[1] == "gencot:" && match(gencot_theories,a[2])) printf("  \"Gencot_%s_Lemmas\"\n", a[2])
        if (a[1] == "common:" && match(common_theories,a[2])) printf("  \"CogentCommon_%s_Lemmas\"\n", a[2])
      } 
    }
    close(cfile) 
    printf("begin\n\n")
  } else if ($1 == "type_synonym" && substr($3,1,4) == "CArr" && $7 == "FixedList") {
    size = substr($3,5,length($3)-12)
    nr_sizes += 1
    sizes[nr_sizes] = size
    printf("interpretation CArrLems%s: CArrLems arr%s\\<^sub>T\\<^sub>f CArr%s.make\n", size, size, size)
    printf("  by (unfold_locales, unfold CArr%s.make_def arr%s\\<^sub>T\\<^sub>f_def, auto)\n", size,size)
    printf("adhoc_overloading %s CArrLems%s.%sFxd\n", afuns[1], size, afuns[1])
    for (i=2; i <= nr_afuns; i++) printf("  and %s CArrLems%s.%sFxd\n", afuns[i], size, afuns[i])
    printf("\n")
  }
}
END {
  if (exited == "") {
    if (nr_sizes > 0) {
      for (i=1; i<=nr_lems; i++) {
        printf("lemmas %sFxd =\n", lems[i])
        for (j=1; j<=nr_sizes; j++) printf("  CArrLems%s.%s\n", sizes[j], lems[i])
      }
      printf("\n")
      for (i=1; i<=nr_funs; i++) {
        printf("lemmas sem_%sFxd[sem] =\n", funs[i])
        for (j=1; j<=nr_sizes; j++) printf("  CArrLems%s.sem_%s\n", sizes[j], funs[i])
        printf("lemmas errsem_%sFxd =\n", funs[i])
        for (j=1; j<=nr_sizes; j++) printf("  CArrLems%s.errsem_%s\n", sizes[j], funs[i])
      }
      printf("\n")
      for (i=1; i<=nr_clems; i++) {
        for (k=1; k<=nr_cfuns; k++) {
          printf("lemmas %s_%s =\n", cfuns[k], clems[i])
          for (j=1; j<=nr_sizes; j++) printf("  CArrLems%s.%s_%s\n", sizes[j], cfuns[k], clems[i])
        }
      }
      printf("\n")
      for (i=1; i<=nr_cfuns; i++) {
        printf("lemmas sem_%s[sem] =\n", cfuns[i])
        for (j=1; j<=nr_sizes; j++) printf("  CArrLems%s.sem_%s\n", sizes[j], cfuns[i])
      }
      printf("\n")
    }
    print "end"
  }
}' $1

# documentation:
#
# The generated theory has the following form:
# - the name of the input theory must be X_ShallowShared_Tuples.
#   Otherwise an error message is written to stderr.
# - the name of the output theory is X_Shallow_Gencot_Lemmas.
# - the output theory imports X_Shallow_Gencot_Tuples
#   and for every line 
#     gencot: id
#   in the argument file for which id is in gencot_theories the theory Gencot_id_Lemmas, and for every line
#     common: id
#   in the argument file for which id is in common_theories the theory CogentCommon_id_Lemmas.
# - the output theory contains for every type synonym definition of the form
#     type_synonym 'el CArr<size>\<^sub>T = ...
#   in the input theory a locale interpretation of the form
#     interpretation CArrLems<size>: CArrLems arr<size>\<^sub>f CArr<size>.make
#       by (unfold_locales, unfold CArr<size>.make_def
#       arr<size>\<^sub>T\<^sub>f_def, auto)
#   and an adhoc overloading of the form
#     adhoc_overloading siz CArrLems<size>.sizFxd
#       and vld CArrLems<size>.vldFxd
#       ...
#   for all abstracted array operations siz, vld, elm, elm_update, elm_modified, elms_fill,
#   and lemma collections of the form
#     lemmas <lem>Fxd = CArrLems<size1>.<lem> CArrLems<size2>.<lem> ...
#   for all <sizei>, and all following lemmas <lem>:
#     unfold elm_commUpd_elm, elm_distUpd, elm_sameUpd, eqArr, eqElmUpd, eqElmsFill, elm_modified_def,
#     sem_<fun>, errsem_<fun>
#   for all Gencot array functions <fun>.
#   and lemma collections of the form
#     lemmas <lem> = CArrLems<size1>.<lem> CArrLems<size2>.<lem> ...
#   for all <sizei>, and all following lemmas <lem>:
#     <cfun>_inverse, <cfun>_apply, sem_<cfun>
#   for all Gencot array conversions <cfun>.
#
#   For all lemma collections sem_<fun>, sem_<cfun> the [sem] option is set.
#
# The list of theories which can be imported is specified by the string variables 
# gencot_theories and common_thories as a sequence of words separated by blanks.
# The list of array functions is specified in the array funs of length nr_funs,
# the list of abstracted array functions is specified in the array afuns of length nr_afuns,
# the list of array lemmas is specified in the array lems of length nr_lems.
# The list of array conversions is specified in the array cfuns of length nr_cfuns,
# the list of array conversion lemmas is specified in the array clems of length nr_clems.
#
# The input is read until a line of the form "theory <name>" is found. Using the <name>, the tup-suffix
# is determined and the output theory header is generated. The argument file is read using getline to 
# generate the corresponding imports.
# 
# Then the rest of the input is read and for each matching type synonym definition the 
# interpretation and adhoc overloading is generated and the size is stored in the array sizes,
# counting the entries in nr_sizes.
# 
# In the END rule if nr_sizes is not 0 the lemma collections are generated and the theory is finished by an "end".
#
# Implementation in awk:
# - The filename argument for the comment file must be copied and removed from the argument list ARGV
#   to prevent its processing as normal input to awk. The argument file is explicitly read by getline.
# - The theory lists gencot_theories and common_thories are defined in the BEGIN rule.
# - The function and lemma arrays are filled in the BEGIN rule by splitting a string of words.
# - Since in '...' the ' cannot be escaped, we avoid using it in match expressions and print it 
#   by reusing parts of the input.
# - To test whether an entry from the argument file is a member of a theory list the awk builtin function
#   match is used. The theory list is specified as the string, the entry is used as regexp. If a match
#   is found the function returns the index of the first position of the match (which is equivalent to true),
#   otherwise it returns 0 (which is equivalent to false). Note that this works only if no theory name 
#   is a substring of another theory name in the list.
