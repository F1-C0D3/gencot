As described in Section~\ref{design-modular} there are several different Gencot components which process C code and generate 
target code.

\subsection{Filters for C Code Processing}
\label{impl-ccomps-filters}

All filters which parse and process C code are implemented in Haskell and read the
C code as described in Section~\ref{impl-ccode-read}.

The following filters always process the content of a single C source file and produce the content for a single 
target file.
\begin{description}
\item[\code{gencot-translate}] translates a single file \code{x.c} or \code{x.h} to the Cogent code to be put in file
\code{x.cogent} or \code{x-incl.cogent}. It processes typedefs, struct/union/enum definitions, and function
definitions. 
\item[\code{gencot-globals}] translates a single file \code{x.c} to the Cogent code to be put in file \code{x-globals.cogent}.
It processes all global variable definitions.
\item[\code{gencot-entries}] translates a single file \code{x.c} to the antiquoted C entry wrappers to be put in
file \code{x-entry.ac}. It processes all function definitions with external linkage.
\item[\code{gencot-abstypes}] translates a single file \code{x.c} or \code{x.h} to the C typedefs to be put in
file \code{x-abstypes.c} or \code{x-abstypes.h}. It processes typedefs and struct/union/enum definitions.
\item[\code{gencot-remfundef}] processes a single file \code{x.c} by removing all function definitions. The output
is intended to be put in file \code{x-globals.c}
\item[\code{parmod-gen}] processes a single file \code{x.c} and generates the Json template for specifying
function parameter modification (see Section~\ref{impl-parmod}).
\end{description}

All these filters take the name of the original source file as additional first
argument, since they need it to generate Cogent names for C names with internal linkage and for tagless C struct/union
types.

There are other target files which are generated for the whole package. The filters for generating these target files 
must always determine and process the external name references in a set of
C source files. This set is the subset of C sources in the <package> which is translated to Cogent and together yields
the Cogent compilation unit. There are different possible approaches how to read and process this set of source files.

The first approach is to use a single file which includes all files in the set. This file is processed as usual by
\code{gencot-include}, \code{gencot-remcomments}, and \code{gencot-rempp} which yields the union of all definitions
and declarations in all files in the set as input to the language-c parser. However, this input may contain conflicting
definitions. For an identifier with internal linkage different definitions may be present in different source files.
Also for identifiers with no linkage different definitions may be present, if, e.g., different \code{.c} files define
a type with the same name. The language-c parser ignores duplicate definitions for identifiers with internal linkage,
however, it treats duplicate definitions for identifiers without linkage as a fatal error. Hence Gencot does not use
this approach.

The second approach ist to process every file in the set separately and merge the generated target code. However, for
identifiers with external linkage (function definitions) the external references cannot be determined from the content
of a single file. A non-local reference is only external if it is not defined in any of the files in the set. It would
be possible to determine these external references in a separate processing step and using the result as additional input
for the main processing step. Since this means to additionally implement reading and writing a list of external references,
Gencot does not use this approach.

The third approach is to parse and analyse the content of every file separately, then merge the resulting semantic maps
discarding any duplicate definitions. This approach assumes that the external name references, which are relevant for
processing, are uniquely defined in all source files. If this is not the case, because conflicting definitions are used
inside the <package>, which are external to the processed file subset, this must be handled manually. Note that the
external references must be determined before the maps are merged, since they may occur in conflicting definitions
which are discarded during the merge. This approach is used by Gencot.

Due to the approach used, the Gencot ``filters'' for generating the files common to the Cogent compilation unit are
actually no filters, they take a list of file names as arguments and are called ``processors'' in the following.
Like all other input to the language-c parser their
content must have been processed by \code{gencot-include}, \code{gencot-remcomments}, and \code{gencot-rempp}.

Usually it is sufficient to specify only \code{.c} files in the set, since the information about all referenced 
identifiers must be provided in included \code{.h} files. However, for determining which references are external, the
\code{.h} files are needed as well, to distinguish between definitions provided by them and definitions provided
by other \code{.h} files not belonging to the set. The \code{.h} files need not be parsed, since their content is
already parsed together with the content of the \code{.c} files, only their names must be known. Hence the Gencot
processors distinguish the argument file names according to their file name extension: if the extension is 
\code{.gencot} a preprocessed \code{.c} file is expected to be parsed and processed, if the extension is \code{.h}
an original include file is expected and only its name is used for determining external name references.

Gencot uses the following processors of this kind:
\begin{description}
\item[\code{gencot-exttypes}] generates the content to be put in the file \code{<package>-exttypes.cogent}. It 
processes externally referenced typedefs, tag definitions and enum constant definitions.
\item[\code{gencot-absext}] generates the content to be put in the file \code{<package>-exttypes.c}. It 
processes externally referenced typedefs, tag definitions and enum constant definitions.
\item[\code{gencot-exit}] generates the exit wrappers to be put in the file \code{<package>-exit.ac}. It processes
the declarations of externally referenced functions.
\item[\code{gencot-exitabs}] generates the abstract function definitions to be put in the file 
\code{<package>-exit.cogent}. It processes the declarations of externally referenced functions.
\item[\code{gencot-extincludes}] generates the list of include directives to be put in the file
\code{<package>-extincludes.c}. It processes all external name references. 
\end{description}

\subsection{Main Translation to Cogent}
\label{impl-ccomps-main}

The main translation from C to Cogent is implemented by the filter \code{gencot-translate}. It translates \code{DeclEvent}s
of the following kinds:
\begin{itemize}
\item struct/union definitions
\item enum definitions with a tag
\item enum constant definitions
\item function definitions
\item type definitions
\end{itemize}
The remaining global items are removed by the predicate passed to \code{Gencot.Input.getDeclEvents}: all declarations, 
all object definitions, and all tagless enum definitions. No Cogent type name is generated for a tagless enum definition,
references to it are always directly replaced by type \code{U32}.

The translation does not use the callback handler to collect information during analysis. It only uses the semantics map
created by the analysis and processes the \code{DeclEvent} sequence created by preprocessing as described in 
Section~\ref{impl-ccode-read}.

The translation of the \code{DeclEvent} sequence is implemented by the function
\begin{verbatim}
  transGlobals :: [DeclEvent] -> FTrav [GenToplv]
\end{verbatim}
It performs the monadic traversal as described in Section~\ref{impl-ccode-trav} and returns the list of toplevel
Cogent definitions of type \code{GenToplv}.

A struct/union/enum definition corresponds to a full specifier, as described in Section~\ref{design-decls-tags}.
The language-c analyser already implements moving all full specifiers to separate global definitions and the
sorting step done by \code{Gencot.Input.getDeclEvents} creates the desired ordering. Therefore, only the translation
of the single struct/union/enum definitions has to be implemented by \code{gencot-translate}.

A struct/union definition is translated to a Cogent type definition where the type name is constructed as described 
in Section~\ref{design-names}. A struct is translated to a corresponding record type, a union is translated to an 
abstract type, as described in Section~\ref{design-types}.
In both cases the type name names the boxed type, i.e., it corresponds to the C type of a pointer to the struct/union.

An enum definition with a tag is translated to a Cogent type definition where the type name is constructed as described 
in Section~\ref{design-names}. The name is always defined for type \code{U32}, as described in Section~\ref{design-types}.

An enum constant definition is translated to a Cogent constant definition where the name is constructed as described 
in Section~\ref{design-names} and the type is always \code{U32}, as described in Section~\ref{design-types}.

A function definition is translated to a Cogent function definition, as described in Section~\ref{design-fundefs}.

A type definition is translated to a Cogent type definition as described in Section~\ref{design-decls-typedefs}.

All these single translations are implemented by the function
\begin{verbatim}
  transGlobal :: DeclEvent -> FTrav GenToplv
\end{verbatim}

A type reference is translated by the function
\begin{verbatim}
  transType :: Type -> FTrav GenType
\end{verbatim}

A type reference may be a direct type, a derived type, or a typedef name. For every typedef name a Cogent type
name is defined, as described in Sections~\ref{design-names} and~\ref{design-modular}. A direct type is either
the type \code{void}, a primitive C type, which is mapped to the name of a primitive Cogent type, or it is a 
struct/union/enum type reference for which Gencot also introduces a Cogent type name or maps it to the 
primitive Cogent type \code{U32} (tagless enums). Hence, both direct types and typedef names can always be mapped
to Cogent type names, with the exception of type \code{void}, which is mapped to the Cogent unit type \code{()}.

-------- todo: rest of subsection must be revised ---------
If a typedef name references (directly or indirectly) a struct or union type, the corresponding Cogent
type name references the boxed type. Therefore, it must be modified by applying the unbox operator. If a typedef
name references a primitive type, this is not necessary, since the corresponding Cogent type is always regular.
However, the abstract Cogent surface syntax always associates a ``sigil'' with a type name. Unnecessary
unbox operators are automatically suppressed by the Cogent prettyprint function. Therefore Gencot always 
associates an unbox sigil with the Cogent type name if it corresponds to a direct type or a typedef name
referencing a direct type.

A derived type is either a pointer type, an array type, or a function type. It is derived from a base type
which in case of a function type is the type of the function result. The base type may again be a derived
type, ultimately it is a direct type or a typedef name.

For a pointer type the translation depends on the base type. If it is a struct or union type or a typedef
name referencing a struct or union type, the pointer type is translated to the Cogent type name corresponding
to the base type. If it is a function type or a typedef name referencing a function type, the pointer type 
is translated to the translation of the base type. In all other cases, as described in Section~\ref{design-types}, 
the pointer type is translated to the name of an abstract type, which is introduced as described in 
Section~\ref{design-names}, using a name for the base type. 

For an array type, the translation also depends on the base type. If it is type \code{char}, the array 
type is translated to the primitive Cogent type \code{String}. In all other cases it is translated 
to the name of an abstract type, which is introduced as described in Section~\ref{design-names}, 
using a name for the base type. This is even done if the base type is a typedef name which references
type char, since Gencot assumes that in this case it is intended as a ``real'' array type and not
as a string type.

If an array type occurs as type of a function parameter, it is ``adjusted'' by C to a pointer type with
the same base type. This is also done by Gencot. 

A function type is always translated to the corresponding Cogent function type, where a tuple type is
used as parameter type if there is more than one parameter, and the unit type is used if there is
no parameter. 

If a pointer type or array type is translated to the name of an abstract type, a name is required for
the base type. If the base type is a direct type or a typedef name, a Cogent type name always exists 
and is used. The only exception is type \code{void}, here the name \code{Void} is used.
If the base type is a derived type, a name is constructed for it as described in Section~\ref{design-names},
even if the base type would normally be mapped to a type expression (which is the case for a function type)
or to its own base type (which is the case for pointer types to struct/union and function types). If the
base type is array of char, the name \code{String} is used for it. 

Note that for most cases where a typedef name occurs as reference or base type, it must be resolved to
the ultimate direct type or derived type referenced by it. This is implemented by the function
\begin{verbatim}
  resolveTypeDef :: TypeDefRef -> Type 
\end{verbatim}
The \code{GlobalDecls} map is not required here, since the language-c analyser puts the (directly) 
referenced type in the \code{TypeDefRef}. 

For a qualified C type Gencot only respects the \code{const} qualifier. For a direct type the \code{const}
qualifier is ignored, since in Cogent values of unboxed and regular types are always immutable. For
a function type the qualifier is also ignored since function types are regular in Cogent. For an array
of char it is ignored since it is translated to type \code{String} which is regular.

All other array types and all pointer types are translated to linear types which can be mutable in
Cogent. Whenever the C type contains no mutable pointer types, it is translated to a readonly Cogent type by 
applying a bang operator to it.

An array type contains mutable pointers if its base type does so. A function type never contains mutable pointers.
A pointer type contains mutable pointers if its base type is not \code{const} qualified or contains mutable pointers.
A primitive type and an enum type does not contain mutable pointers. A struct or union type contains mutable 
pointers, if the type of a member contains mutable pointers.

\subsection{Exit Wrapper Functions}
\label{impl-ccomps-exit}

For the exit wrapper functions Gencot generates the Cogent abstract function definitions and the implementations
in antiquoted C. Exit wrappers are generated for all functions which are invoked but not defined in the Cogent code. 
The information required for each of these functions is contained in the C function declaration.

The easiest approach would be to generate an exit wrapper for every function which is declared but 
not defined in the C program. However, often an
include C source file contains many function declaration where only some of them are invoked. Therefore, Gencot
determines the declarations of all actually invoked functions using \code{getInvocations} as described in 
Section~\ref{impl-ccode-callgraph}. Only for them declarations are translated.

The declarations of invoked functions are filtered as follows:
\begin{itemize}
\item Function definitions are omitted, since the function is not external.
\item If the type is a function pointer, invocations are translated to Cogent in a different way as 
described in Section~\ref{design-types-function}. Therefore we omit all function pointer invocations.
\item Variadic functions cannot be translated to a single Cogent function. Therefore we omit invocations of
variadic functions.
\item A function which is only declared may be incomplete, i.e., its parameters (number and types) are not known. 
We could translate such function declarations to Cogent abstract functions with Unit as argument type, however,
that would not be related to the invocations and thus be useless. Therefore we omit invocations
of incompletely declared functions.
\end{itemize}

An identifier seen by Gencot in a function invocation may also be a macro call which shall be translated by Gencot. 
In this case a dummy function declaration must be manually provided for it as part of the Gencot macro call conversion
(see Section~\ref{design-preprocessor-macros}), so that the language-c parser can parse the invocations. By 
using either an incomplete declaration or a complete declaration it can be controlled whether a Cogent abstract 
function definition is generated for it. If the macro is translated to a macro in Cogent, no abstract function
definition shall be generated and an incomplete dummy declaration must be used.

\subsubsection{Processor \code{gencot-extfuns}}

The processor \code{gencot-extfuns} generates the Cogent abstract function definitions. After determining the
declarations of all invoked external functions, it translates them using the function \code{transGlobals} of
module \code{Gencot.Cogent.Translate}. It translates C function declarations to abstract function definitions
in Cogent. The result is output using \code{prettyTopLevels} from module \code{Gencot.Cogent.Output}.

\subsubsection{Processor \code{gencot-extfunsac}}

The processor \code{gencot-extfunsac} generates the wrapper implementations in antiquoted C code.

\subsection{External Cogent Types}
\label{impl-ccomps-exttypes}

The filter \code{gencot-exttypes} generates the list of all Cogent type definitions which do not result from
translating a C type or tag definition. There are two cases:
\begin{itemize}
\item The type is a C derived type, i.e., a pointer type, array type or function type. As described in 
Section~\ref{design-types}, Gencot maps all derived types to abstract types in Cogent and generates type names for
them. Whereas in C derived types are used in the form of type expressions, in Cogent explicit type definitions are
required for all abstract types.
\item The type is a C type which is not defined in the C source files translated to Cogent. Currently Gencot assumes
that only the system include files are not translated to Cogent. 
\end{itemize}

C Types are used in a C source in the following cases:
\begin{itemize}
\item As type of a global or local variable.
\item As result type of a function.
\item As type of a function parameter.
\item As type of a field in a struct or union.
\item As defining type for a typedef name.
\end{itemize}
There are other uses of types in C, such as in \code{sizeof} expressions, these cases are ignored by Gencot and 
must be handled manually.

Gencot does not translate global or local variables, this must be done manually. To support the manual translation, 
however, Gencot provides the definitions for all derived and external types used for local and global variables.

Since Gencot always translates a derived type to an opaque type name, a type occurring in a derived type (e.g.,
as parameter type in a function type) is \textbf{not} required to be known in Cogent. Only the derived type
as a whole is used and must be collected. The same holds for union types which are translated to an opaque
abstract type name.

In the cases of struct types and defined type names, however, usage may be transitive. Gencot handles transitivity
of defined type names by fully resolving defined external type names to their ultimate definition. For externally
defined struct types all field types are treated as additional external used types. 

\subsubsection{Collecting External Types}

Since often only a small selection of the types defined by a system include file is needed by a program, Gencot performs 
an analysis determining all types used in the translated C source files. For all these types, if the definition is in a 
system include file, it is translated in the usual way and added to the filter output.

The used types are collected with the help of the callback handler during analysis, as described in 
Section~\ref{impl-ccode-read}. Types can only be used in declarations and definitions and the callback handler is
automatically invoked for all of them. Note that if a declaration consists of several declarators, the callback
handler is invoked for every declarator separately. 

Functions can be defined in the C source or they are only declared and invoked. In both cases the parameter and result
types must be known in Cogent. In the latter case they must be determined from the declaration. Gencot determines the
actually invoked external functions as described in Section~\ref{impl-ccomps-exit}. Only for them the declarations 
are inspected to collect the parameter and result types.

Gencot uses the callback handler
\begin{verbatim}
  collectUsedTypes :: DeclEvent -> Trav (Set Type) ()
\end{verbatim}
in module \code{Gencot.Util.Types}. For every \code{DeclEvent} which represents a definition that is
part of the <package>, all used types are added to the user state of the \code{Trav} monad. To determine whether
a C source code part belongs to the <package> the simple heuristics is used that the source file name is specified
as a relative pathname in the \code{nodeinfo}. System includes are typically accessed using absolute pathnames of the 
form \code{/usr/include/...}. If include paths are specified explicitly for Gencot, system include paths must be 
specified as absolute paths whereas include paths belonging to the <package> must be specified as relative paths
to make the heuristics work.

After the language-c analysis phase the declarations of all invoked external functions are determined with the
help of \code{getExtInvocations} as described in Section~\ref{impl-ccomps-exit} and the result and parameter 
types used by them are added to the set of used types.

The resulting set of types is filtered for derived types and for typedef and tag names defined in system include files
(determined according to the same heuristics as above). The latter types are then transitively completed: every typedef 
name is completely resolved and if the resulting type is not a primitive type it is added to the set. For every struct
type all nonprimitive field types are added to the set. The transitive closure is calculated by the function
\begin{verbatim}
  transCloseUsedTypes :: GlobalDefs -> Set Type -> Set Type
\end{verbatim}
in module \code{Gencot.Util.Types}. Note that by transitive closure all kinds of nonprimitive C types can be added to
the set, inluding derived types, and union and enum types.

For the types in the resulting set Cogent type definitions are generated as follows:
\begin{itemize}
\item For a derived type an abstract type definition is created for the generated Cogent type name.
\item For a typedef name a type definition is created which maps the translated name to the translation of the type
to which the typedef name transitively resolves.
\item For a struct, union, or enum type the type definition is retrieved and translated as described in 
Sections~\ref{design-types-enum} and~\ref{design-types-struct}.
\end{itemize}
This is implemented by the monadic action
\begin{verbatim}
  genTypeDefs :: [LCA.Type] -> FTrav [GenToplv]
\end{verbatim}
in module \code{Gencot.Cogent.Translate}.



\subsection{Declarations}
\label{impl-ccomps-decls}

The filter \code{gencot-deccomments} is used to provide the information about the positions of all declarations with
external linkage in
a translated file, as described in Section~\ref{impl-comments-decl}. This information is used to move declaration
comments to the corresponding definitions, as described in Section~\ref{design-comments-decl}.

Only global declarations are processed by this filter. Therefore the filter processes the list of \code{DeclEvents}
returned by \code{getDeclEvents} (see Section~\ref{impl-ccode-read}). The predicate for filtering the list
selects all declarations with external linkage (i.e. removes all object/function/enumeration/type definitions and 
all declarations with internal or no linkage). 
The main application case are functions declared as external, but moving the comments may also be useful for 
objects.

For processing the declarations we do not need a monad since every declaration can be processed on its own. This is implemented
be the function
\begin{verbatim}
  transDecl :: DeclEvent -> String
\end{verbatim}
in module \code{Gencot.Text.Decls}. It is mapped over the list of \code{DeclEvents} and the resulting string list
is output one string per line.

\subsection{Parameter Modification}
\label{impl-ccomps-parmod}

The filter \code{parmod-gen} is used to generate the Json parameter modification description from a C source file.
It may be invoked in two forms:
\begin{verbatim}
  parmod-gen <source file name>
  parmod-gen <source file name> close
\end{verbatim}
The second form runs the filter in ``closing mode''.

In normal mode the filter processes all \code{DeclEvent}s in the source file which are function
definitions or definitions for objects with function pointer type. Every such definition is translated to an
entry in the parameter modification description. A function definition is translated to the sequence of its
own description entry and the entries for all invoked local function pointers.

In closing mode the filter processes all \code{DeclEvent}s in the source file and in all included files which
are declarations for functions or function pointers
or type definitions for struct or union types. Every declaration is translated to an entry in the parameter
modification description. Every type definition is translated to the sequence of entries for all members of
function pointer type.

After analysing the C code as described in Section~\ref{impl-ccode} the call graph is generated as described
in Section~\ref{impl-ccode-callgraph}. Then another traversal is performed using the \code{CTrav} monad and
\code{runWithCallGraph} with action
\begin{verbatim}
  transGlobals :: [DeclEvent] -> CTrav [JSObject JSValue]
\end{verbatim}
defined in module \code{Gencot.Json.Translate}. The resulting list of JSON objects is postprocessed by adding
undeclared parameters (in case of functions with variadic or incomplete type) according to the maximal number
of arguments found in the invocations. Finally, the list is output as described in Section~\ref{impl-parmod-json}.





