For working with the mapped C datatypes, in particular for those mapped using abstract Cogent types, Gencot provides support by
defining and implementing polymorphic Cogent functions, some of which are abstract and some of which are implemented in Cogent.

Although the operations provided for different kinds of datatypes have different semantics, they have common properties
and most are represented by common polymorphic functions. Here the operations are first introduced conceptually, together with
the polymorphic functions, then they are presented for specific kinds of data types.
Gencot provides the polymorphic function definitions in separate Cogent files which can be
included in a Cogent source.

\subsection{Dummy Expressions}
\label{design-operations-dummy}

For every mapped type Gencot defines a dummy expression of that type. It is used as a replacement for the actual 
translation when Gencot does not support the translation of a C expression or statement, so that the resulting Cogent code is 
syntactically valid and can be processed and checked by the Cogent compiler.

For constructing dummy expressions Gencot provides in \code{include/gencot/DummyExpr.cogent} the polymorphic abstract function
\begin{verbatim}
  gencotDummy: all(a). String -> a
\end{verbatim}
from a string to every possible Cogent type. Since the dummy expressions are intended to be eliminated before compiling the 
C code generated by the Cogent compiler, Gencot does not provide C definitions for this abstract function. 

Every dummy expression has the form of an application of this function to a string literal, which is used to specify
the reason why Gencot could not translate the C code fragment. The C code is added in a comment, as described in 
Section~\ref{design-cstats-dummy}.

\subsection{Default Values}
\label{design-operations-default}

Conceptually, Gencot provides a default value for every regular non-function Cogent type. For the primitive numeric types it is 
\code{0}, for type \code{String} it is \code{""}, and for type \code{()} it is the unit value \code{()}.

For all Gencot function pointer types (see Section~\ref{design-operations-function}) the default value is the \code{NULL}
pointer (which cannot be denoted directly in Cogent).

For types of the form \code{MayNull P} (see Section~\ref{design-types-pointer} a useful default value would be the 
\code{NULL} pointer. However, since these types are the only linear types with a default value, and the \code{NULL} value
can be denoted by the function \code{null} defined in Section~\ref{design-operations-null}, Gencot does not support
a default value for such types.

For a regular tuple (which has no component of linear or readonly type) the default value is the tuple of default values. For a
regular unboxed record it is the record where all fields have their default value. For a regular variant type it is
the default value of the first (in the C implementation) variant. For a regular unboxed Gencot array type it is the 
array of default value elements.

Gencot defines the polymorphic abstract function
\begin{verbatim}
  defaultVal: all(out:<DSE). () -> out
\end{verbatim}
in \code{include/gencot/Default.cogent}. 

Gencot provides instances for all regular types which contain no Cogent functions.

\subsection{Creating and Disposing Boxed Values}
\label{design-operations-create}

Since all pointer types are mapped to Cogent linear types, Cogent does not provide support for creating values
of these types (``boxed values''). In C a pointer can be created using the address operator \code{\&} or by allocating data on
the heap using a C standard function such as \code{malloc}. The address operator is supported by Gencot
only for data on the heap, as explained in Section~\ref{app-transfunction-addrop}. Therefore, the basic functionality
for pointer creation is allocation on the heap. This must be provided as an abstract Cogent function.

Since values of a linear type cannot be discarded in Cogent, another abstract Cogent function is required for
disposing such values, implemented by using the C standard function \code{free}.

Gencot provides the polymorphic abstract functions defined in \code{include/gencot/Memory.cogent}:
\begin{verbatim}
  create : all(evt). Heap -> Result (evt,Heap) Heap
  dispose : all(evt). (evt,Heap) -> Heap
\end{verbatim}
for creating and disposing values of linear types. Gencot provides instance implementations for all linear
types, i.e. all (boxed) record types and abstract types. \code{Heap} is an abstract data type for modelling
the C heap where the data structures are allocated, it is defined in \code{include/gencot/Memory.cogent}.
\code{Result} is a variant type defined in the Cogent standard library (usually abbreviated as \code{R})
with variants for the success and error cases. In the success case \code{create} returns the newly allocated 
boxed value and the modified heap, in the error case it only returns the heap.

The \code{create} instances only allocate space on the heap but do not initialize it. To model this property in 
Cogent, Gencot uses two different Cogent types for every linear type to represent uninitialized (``empty'') and 
initialized (``valid'') values.
Conceptually, the instances of \code{create} and \code{dispose} are only defined for the empty-value types.
The function \code{create} returns empty values, the function \code{dispose} expects empty values. In particular,
empty values cannot contain linear parts (pointers to other memory regions) and can thus be safely discarded by 
deallocating their memory space. 

Note that according to their definition, the functions \code{create} and \code{dispose} are defined for arbitrary
types \code{evt}. However, Gencot only provides instances for (empty-value) linear types. Since it is not possible
to express this type property in Cogent, the use of unsupported instances of both functions are not detected by the 
Cogent compiler.

When Gencot maps a C type to a linear Cogent type, it always uses a Cogent record type (see Section~\ref{design-types}).
For these types the empty-value type is implemented by the record with all fields taken. Gencot defines in 
\code{include/gencot/Memory.cogent} the preprocessor macro
\begin{verbatim}
  EVT(vvt)
\end{verbatim}
which expands to the empty-value type \code{vvt take (..)} corresponding to the valid-value type \code{vvt}. 

It is not possible to define a generic type for this purpose, since in Cogent it is not possible to apply the 
\code{take} operator to a type variable.

The macro can be used to specify the correct
instances of \code{create} and \code{dispose} for all types implemented as Cogent record. For example, the 
\code{create} instance for a mapped pointer type \code{CPtr U32} can be specified as
\begin{verbatim}
  create[EVT(CPtr U32)]
\end{verbatim}

Note that although it is syntactically possible to use a type \code{MayNull P} as type argument for \code{create}
and \code{dispose}, it does not make sense, because a successful result of \code{create} is never \code{NULL} and
\code{dispose} need not be applied to \code{NULL}.

\subsection{Modifying Boxed Values}
\label{design-operations-modify}

Boxed records can be modified in Cogent by the put and take operations which in the simplest case have the form
\begin{verbatim}
  let r' = r { f = v } in ...
  let r' { f = p } = r in ...
\end{verbatim}
In the put operation \code{r} is the old record value, \code{f} is the field to be written, \code{r'} is the 
new (``modified'') record value and \code{v} is the new field value. The type of \code{r'} is either the same as 
for \code{r} or it differs, if field \code{f} was taken in \code{r}. In the take operation \code{r} is the old record value, \code{f} 
is the field to be taken, \code{r'} is the record without \code{f} and \code{p} is a pattern for binding the old 
field value. The type of \code{r'} is always different from that of \code{r}.

Note that in the C translation of this code the boxed records correspond to pointers to structs and for both operations
the pointers \code{r} and \code{r'} are the same.

We generalize this idea by defining operations for modifying boxed values in the form of Cogent functions.
To provide a common framework for modification operations, Gencot defines function types for such modification functions 
in \code{include/gencot/ModFun.cogent}. The basic function types are
\begin{verbatim}
  type ModTypeFun obj res arg out = (obj,arg) -> (res,out)
  type ModFun obj arg out = ModTypeFun obj obj arg out
\end{verbatim}
Here \code{obj} is the type of the value to be modified and \code{res} is its type after the modification.
Type \code{ModTypeFun} covers the general case where the type of the new value is different from that of the old value (although the pointer
values in C are the same!), \code{ModFun} covers the more special case where
the type is the same before and after the modification. In both cases a value of type \code{arg} is passed to the modification
function, it may provide information about how to modify the value, and the modification function additionally returns a value of
type \code{out}, e.g., an error code. The functions \code{fst} and \code{snd} defined in the Cogent standard library can be used
to retrieve the modified value and the additional output.

Note, that the additional property of a ``modification function'', that the result pointer must be the same as the argument pointer,
cannot be expressed in Cogent (or any other functional language). The type \code{ModTypeFun} is used by Gencot as an informal marker
for such functions. A function implemented in Cogent is a modification function, if it only applies take and put operations 
or other modification functions to its
first argument. An abstract Cogent function is a modification function
if the C implementation always returns the same pointer, without deallocating it in between.

For generality we extend the types \code{ModTypeFun} and \code{ModFun} to non-pointer types \code{obj} and \code{res}. There
they have the normal Cogent semantics and behave like the type \code{ChgFun} defined below. Note that the types \code{obj}
and \code{res} may still be linear if they correspond to structures containing pointers.

When the item property Modification-Function (see Section~\ref{design-types-itemprops}) has been declared for a C function, Gencot
translates it to the form of a modification function, i.e. it arranges the parameter and result types to be pairs of the type
of the first parameter of linear type and a tuple of all other relevant types. Gencot then uses a type of the form 
\code{ModFun Obj (...) (...)} as type of the translated function.

The put operation can now be represented as a function of type \code{ModTypeFun R (R put f) V ()} where \code{R} is the type of
\code{r} and \code{V} that of field \code{f} and value \code{v}. If the field is not taken in \code{R} the type is \code{ModFun R V ()}.
The take operation can be represented as a function of type \code{ModTypeFun R (R take f) () V}, it returns 
a pair of the remaining record and the taken field value.

In case of an error a \code{ModTypeFun} may not be able to produce a result value of type \code{res}. For this case Gencot defines 
a function type for ``transactional'' modification functions which either succeed or ``roll back'' the modification and return 
the original input value:
\begin{verbatim}
  type TModTypeFun obj res arg out = 
     (obj,arg) -> Result (res,out) (obj,out)
\end{verbatim}
using the variant type \code{Result} from the Cogent standard library. The result type is not defined in the form 
\code{(Result res obj,out)} because then it must always be bound explicitly before it can be used in a match expression.
With the definition used here the modification function call can be directly used in a match expression where the 
additional output is bound by the patterns in the alternatives.

Note that a \code{ModFun} can be transactional, if it
returns the information that an error occurred as part of the additional result of type \code{out}.

A typical pattern for modifying a record field \code{f} is a combination of a take and a put operation of the form
\begin{verbatim}
  let r' { f = h } = r 
  and r'' = r' { f = chg(h) }
\end{verbatim}
where a function \code{chg} is used to determine the new field value from the old field value. We can generalize function
\code{chg} to a function of type \code{(fld,arg)->(fld,out)} where \code{fld} is the type of field \code{f}. It takes 
additional input of type \code{arg} and returns additional output of type \code{out}. However, it need not be a modification
function, since type \code{fld} need not be linear and \code{chg} may map its first argument to an arbitrary other value
of the same type. Gencot defines the function type
\begin{verbatim}
  type ChgFun obj arg out = (obj,arg) -> (obj,out)
\end{verbatim}
for this kind of ``change functions''. Its meaning is the plain Cogent semantics of the type definition, no additional property is 
included.

Now we can define a higher order function for the combined field modification as
\begin{verbatim}
  modify (r,(chg,x)) = 
    let r' { f = h } = r
    and (v,y) = chg(h,x)
    in (r' { f = v }, y)
\end{verbatim}
It has the function type \code{ModFun R (ChgFun V arg out, arg) out}, accepts as additional input a pair of a change
function for the field value and its additional input, and returns the modified record and the additional result of
the field change function. Note that \code{modify} also respects the type constraints if the field type \code{V}
is linear. The field value is neither duplicated nor discarded.

For this kind of modifying a part Gencot defines the corresponding generalized function type
\begin{verbatim}
  type ChgPartFun obj prt arg out = 
    ModFun obj (ChgFun prt arg out, arg) out
\end{verbatim}
where \code{obj} is the type of the modified object, \code{prt} is the type of the part to be changed, \code{arg} is the type
of the information passed to the part change function, and \code{out} is the type of additional output of both functions.

Since every \code{ModFun} is also a \code{ChgFun}, modification functions of this type can be chained to modify parts arbitrarily 
deep embedded in other parts. 

As an example, to change a part \code{p} of type \code{P} in a part \code{q} of type \code{Q} in a value \code{r} of type \code{R}
an expression of the form
\begin{verbatim}
  modifyQInR (r, (modifyPInQ, (chg, arg)))
\end{verbatim}
modifies \code{r} by replacing \code{p} by \code{chg (p,arg)}. To make the modification functions generic for the type of the additional input
to the part modification function and for the type of its additional output they can be defined as polymorphic:
\begin{verbatim}
  modifyQInR: all(arg,out). ChgPartFun R Q arg out
  modifyPInQ: all(arg,out). ChgPartFun Q P arg out
  chg: ChgFun P A O
\end{verbatim}

If the change function \code{chg} needs as input information of nonlinear type from other linear parts of \code{q} or \code{r} it is not
possible to pass these parts to \code{chg}. For a record type \code{R} either they must be taken from \code{r} and put back in after the modification, then
the type of \code{r} is \code{R take (...)} and \code{modifyQInR} cannot be applied because of type incompatibility. Or the parts are
accessed as readonly in a banged context for \code{r}, then the readonly parts cannot escape from the banged context to be passed to the
modification operation (which must be outside of the banged context since it modifies \code{r}). Instead, the required nonlinear information must 
be retrieved from the linear parts in a banged context for \code{r}. Since it is nonlinear it may escape from the context and can be passed 
to the modification operation.

In C it is a common pattern to pass pointers to other parts of a data structure around for efficiency and access values through these pointers 
only when needed to modify parts of the structure. In the Cogent translation the values must be accessed separately in a banged context and then
passed to the modification operation as copies.

If type \code{prt} of the part to be modified is not linear, function \code{modify} removes the part's value from the structure,
passes it to the part change function and puts the result back into the structure. This is
inefficient for large parts when the part is only \textit{modified} by changing a small subpart.
In C the typical way of dealing with this situation is to pass a pointer to the part change function 
instead. 

The same approach can be used in Cogent defining a function \code{modref} which works like \code{modify}, but
uses a part modification function of type \code{ModFun} and passes a pointer to it instead of a copy of the part. 
Since it returns the same pointer, the part value can be modified ``in-place''.
In Cogent the pointer corresponds to a value of linear type, so the part modification function can usually be 
implemented in Cogent. Function \code{modref}, instead, must be abstract and implemented in C with the help of 
the address operator \code{\&}. 

Gencot defines the function type
\begin{verbatim}
  type ModPartFun obj pprt arg out = 
    ModFun obj (ModFun pprt arg out, arg) out
\end{verbatim}
which can be used to specify the type of \code{modref}:
\begin{verbatim}
  modref: ModPartFun obj pprt arg out
\end{verbatim}
Here \code{pprt} is the pointer type corresponding to the part's type \code{prt}. Note that Gencot's type mapping 
scheme supports for every mapped C type a corresponding pointer type.

Function \code{modref} can be chained with other \code{modref} functions and with \code{modify} functions in the
same way as described for \code{modify} functions.

Of course, using a pointer to the in-place part of the boxed value introduces sharing between both. However, the 
part modification function has no access to the boxed value other than by the pointer to the part. It could only get
access if the boxed value or a part of it would be passed to it using the additional input of type \code{arg}. But since
that is passed to \code{modref} together with the boxed value itself, the Cogent type checking rules prevent this
as a double use of the boxed value. Thus the approach is safe and the part modification function can work with the
pointer according to the usual Cogent rules, as long as it always returns the same pointer as result value. This
means it cannot dispose it and it cannot store it in another structured value and return a different pointer of
the same type. Function \code{modref} then simply discards the returned pointer so that the sharing ends when it
completes.

\subsection{Initializing and Clearing Boxed Values}
\label{design-operations-init}

Gencot uses the terms ``initialization'' and ``clearing'' for the conversions between empty and valid boxed values.
After a boxed value has been created it must be initialized to be used, before it is disposed it must be cleared.

Initialization must set every part of a structured value to a valid value. For parts of nonlinear type this is
straightforward, since values of nonlinear types can be directly denoted in Cogent programs in most cases. Parts
of unboxed record and abstract types are made valid by passing a pointer to the part to an initialization
function for the corresponding boxed part value (as described for function \code{modref} in 
Section~\ref{design-operations-modify}).

For parts of linear type there are two possible approaches: they can be created (allocated) during initialization 
or they can be passed as arguments to the initialization function. If they are created, the initialization function needs the heap as additional 
in- and output. Otherwise it takes all parts of linear type as additional input. Of course, if several parts
of linear type exist, some of them can be created and some passed as arguments.

Parts of readonly type \code{S!} cannot be initialized by creating a value for them. If a value is created in the 
initialization function it must be banged there but then it may not leave the banged context. The readonly value 
must either be created by a function which returns a value of type \code{S!}, or it must be passed as argument
to the initialization function. 

Clearing must convert every part of a structured value to an empty value. For parts of nonlinear type nothing
needs to be done, or the value can be explicitly set to a default value to overwrite the stored information for
security reason. Parts of unboxed record and abstract types are made empty by passing a pointer to a clearing 
function for the boxed part value.

Parts of linear type, dually to initializing them, can be disposed during clearing, or they can be returned
as result, so that they are not discarded. If they are disposed, the clearing function takes the heap as 
additional in- and output. Otherwise it returns all parts of linear type as output. If several parts
of linear type exist, some of them can be disposed and some returned as results.

Parts of readonly type need no specific treatment during clearing, since they can be discarded in the same way as
parts of nonlinear type.

Initialization and clearing functions are modification functions in the sense of Section~\ref{design-operations-modify}.
Translated to C they always return the same pointer they received as input.
Gencot defines the following function types in \code{Memory.cogent}:
\begin{verbatim}
  type IniFun evt vvt arg out = ModTypeFun evt vvt arg out
  type ClrFun vvt evt arg out = ModTypeFun vvt evt arg out
  type TIniFun evt vvt arg out = TModTypeFun evt vvt arg out
\end{verbatim}
They can be used by the developer to mark functions as initialization or clearing functions. This is purely 
informal since no constraint between the type parameters can be enforced by Cogent, so a correct pair of 
empty-value type and the corresponding valid-value type must be specified by the developer.

The third type supports ``transactional'' initialization functions which may fail and are rolled back, they return
a result of type \code{Result vvt evt}, as for type \code{TModTypeFun} (see Section~\ref{design-operations-modify}.
This is typically the case when initializing a part of the value includes allocating space on the heap.
If this is not done, initialization only consists of storing values, which cannot fail. For clearing we always 
assume that no error can occur, then the rollback for transactional initialization is always possible without 
causing another error.

Initialization and clearing functions are defined by Gencot to always expect additional input and output values of 
arbitrary types \code{arg} and \code{out}. The input value can be used to specify default values to be used,
the heap for creating and disposing parts of linear type, and initialization and clearing 
functions for parts of the value. If a function only uses fixed default values and functions for parts 
the unit type \code{()} is used as type \code{arg}. The output value can be used to return an error code,
the modified heap, or parts of linear type which have not been disposed.

An initialization or clearing function for a type with several parts must handle all parts together because it must
transform from the empty-value type, where all parts are taken, to the valid-value type, where all parts are present.
If an initialization or clearing function handles only one part, its type must respect which other parts are 
taken and which are not. This is not feasible for types with many parts. However, if all parts must be handled together,
there are many ways how to do so, especially if there are parts of linear and/or readonly type. 

Gencot provides the following polymorphic abstract initialization and clearing functions which are defined for only 
some of these cases:
\begin{verbatim}
  initFull : all(evt,vvt). IniFun evt vvt #vvt ()
  clearFull : all(vvt,evt). ClrFun vvt evt () #vvt
  initHeap : all(evt,vvt:<E). TIniFun evt vvt Heap Heap
  clearHeap : all(vvt:<E,evt). ClrFun vvt evt Heap Heap
  initSimp : all(evt,vvt:<E). IniFun evt vvt () ()
  clearSimp : all(vvt:<E,evt). ClrFun vvt evt () ()
\end{verbatim}
Generally, these functions are only defined if \code{evt} is the empty-value type corresponding to the valid-value
type \code{vvt}. Since this cannot be expressed by constraints in Cogent, Gencot defines the preprocessor macros:
\begin{verbatim}
  INIT(<k>,vvt) -> init<k>[EVT(vvt),vvt]
  CLEAR(<k>,vvt) -> clear<k>[vvt,EVT(vvt)]
\end{verbatim}
They can be used to specify valid instances of the functions with the correct types so that the constraints
between them are fulfilled and the Cogent typechecker can be used to test for correct application.
For example, \code{INIT(Full,vvt)} expands to \code{initFull[EVT(vvt),vvt]}. The macros can be used for 
all types \code{vvt} which are implemented as a Cogent record type.

Gencot also defines the macros
\begin{verbatim}
  INITTYPE(<k>,vvt)
  CLEARTYPE(<k>,vvt)
\end{verbatim}
which expand to the corresponding function types.

The first two functions pass the full content as argument: the additional input type for initialization and the additional
result type for clearing is the
unboxed type \code{\#vvt}. It is used to pass all content for the referenced memory region to \code{initFull} which
copies it there. For \code{clearFull} it is used to return all content, in particular, all content of linear type, so that 
it is not discarded.

The second pair passes the heap as additional input and result. Additionally, \code{vvt}
may not contain any readonly parts. One reason is that readonly values are a copy of a pointer, so they 
cannot be initialized internally. Another reason is that the current Gencot implementation cannot distinguish which 
parts are readonly and which parts are not, therefore it cannot treat them differently, which is necessary for 
clearing them: copies of a pointer must not be disposed. For this reason even parts of type \code{MayNull P} are
not allowed, although they could be initialized by setting them to \code{NULL}. 
The restriction not to contain readonly parts can be expressed
in Cogent by the type constraint \code{E}, this is specified for type \code{vvt} for both functions.

Function \code{initHeap} allocates all parts of linear type on the heap 
and \code{clearHeap} disposes them. Parts of type \code{MayNull a} are initialzed to \code{null} and are disposed only 
if they are not \code{null}. 
All parts of nonprimitive type are initialized or cleared using function \code{initHeap} or \code{clearHeap}, respectively.
All parts of primitive or Gencot function pointer type are initialized to their default value \code{defaultVal ()} and are cleared by
doing nothing. Whenever an allocation fails for 
\code{initHeap}, all other allocations are rolled back using \code{clearHeap}. The initialization function returns a variant
value which signals success or error.

The third pair passes no additional information. Moreover, \code{vvt} must have no readonly or linear parts other than 
parts of a type \code{MayNull P}.
Since \code{vvt} itself must be linear, the additional constraint cannot be expressed in Cogent, 
only readonly parts are excluded by specifying type constraint \code{E} for it. 
Functions \code{initSimp} and \code{clearSimp} work as \code{initHeap} or \code{clearHeap},
but the heap is not required since there are no linear parts which must be allocated or disposed.

The first pair is the most general, it is applicable to all kinds of valid-value types \code{vvt}. However, it bears the
most overhead, since all content must be passed as argument and copied to the memory to be initialized. The other
two pairs support ``in-place'' operation, however, they are more restrictive. 

Since the type of \code{initHeap} is different from that of the other initialization functions they cannot 
be passed as argument to a common function parameter. An alternative would have been to define all initialization
functions using the common type \code{TIniFun}, but then their use would always require unnecessary checks and
implementing an error case which can never occur.

Functions \code{clearFull}, \code{clearHeap}, and \code{clearSimp} do not overwrite the referenced memory with a 
``clearing value''. If this is required, a manually defined clearing function must be used instead.

For specific types \code{vvt} custom initialization and clearing functions can be defined manually. Typically, they 
pass values for some parts as parameters (in particular those of readonly types), and use default values or heap
allocation for the others.

\subsection{Accessing Parts of Structured Values}
\label{design-operations-parts}

For working with a structured value it is often necessary to access its parts for reading or modifying them.
Gencot supports the following conceptual operations on structured values:
\begin{description}
  \item[\code{get}] access the value of a part for reading,
  \item[\code{set}] replace the value of a part by a given value, discarding the old value,
  \item[\code{exchng}] replace the value of a part by a given value, returning the old value,
  \item[\code{modify}] apply a change function to a part.
\end{description}

Every function accesses only a single part of the structured value, if several parts must be accessed at the same
time custom operations must be defined manually.

Depending on the type of structured value and the kind of specifying the part, the part may safely exist or not.
For example, for a record field specified by its name it can be statically determined whether it exists,
for an array element specified by a calculated index value this is not the case. 

The actual function types of the operations differ depending on the way how the part is specified for them and
whether it safely exists. However, if the structured value has type \code{T} and the part has type \code{S} 
the conceptual functionalities are as follows:

The function \code{get} has functionality \code{T! -> S!}, if the part safely exists. It expects a readonly value as input and returns
a readonly copy of the part's value. This operation can be defined in Cogent for arbitrary types \code{S}
because the returned value can be shared with the value remaining in the structure since both are readonly.

If the part does not safely exists there are two possible functionalities: either the function returns a variant
value, or it returns a default value if the part does not exists. The variant value is the simpler and ``cleaner''
form, possible variant types are \code{Option} and \code{Result} from the Cogent standard library (the former treating
the part semantically as ``optional'', the latter treating its nonexistence as an ``error''). However, the use
of the variant value introduces an overhead, since Cogent implements it as a record. It must be constructed, passed
on the stack as function result, and then tested and deconstructed; for very frequent accesses to a part this may
cause a relevant performance reduction. Therefore an alternative form should be provided which always passes the
part's value directly, using a default if the part does not exist. It should only be used if it is clear from the
context that the part exists. A possible choice for the default value is \code{defaultVal} (defined in 
Section~\ref{design-operations-default}), however that is restricted to parts of regular type, therefore other 
solutions are required for other types. A better choice can be to use another part which safely exists as default 
value, since that has the expected type and no restrictions apply.

An alternative to the function \code{get} would be a function which takes a modifyable structure and returns the structure
together with the element. However, this would be cumbersome in many applications and misleading for proofs, since 
the function never modifies the structure. 

The function \code{set} has functionality \code{(T,S) -> (T,())} and is a modification function in the sense of 
Section~\ref{design-operations-modify}, hence its type can be denoted as \code{ModFun T S ()}. 
It expects a structure and the new value as input
and returns the structure where only the value of the part has been replaced by the new value. The result value is 
structured as a pair, so that the function has the form of a modification function. Since the old
value of the part is discarded, function \code{set} is only defined if type \code{S} is discardable.
If the part does not exist, the function returns the unmodified structure.

The function \code{exchng} has functionality \code{(T,S) -> (T,S)} and is also a modification function, so its type
can be denoted as \code{ModFun T S S}. It works like \code{set}, but instead of
discarding the old value of the part it returns it in the result. This can be done for arbitrary types \code{S}
since values of this type are neither shared nor discarded. If the part does not exist, the function returns
the unmodified structure together with the input value.

The function \code{modify} is a modification function and has functionality \code{ChgPartFun T S A O} where 
\code{A} and \code{O} are arbitrary types.
According to the definition of \code{ChgPartFun} \code{modify} applies a part change function of
type \code{ChgFun S A O} to change the part. All types may be linear, since the corresponding values are
only passed through to the part change function and back.
The part change function determines the new part value from the old part value. If the part's type \code{S}
is linear it can be implemented by actually modifying the part's value. In particular, this can be done by
again using \code{modify} as part change function changing a part's part, as it has been described
for the \code{modify} function in Section~\ref{design-operations-modify}.

If the part does not exist, function \code{modify} returns the unmodified structure. However, it must also
return a value of type \code{O}, although the part change function is never executed. Similar as for 
function \code{get} there are two possibilities: returning a variant value or a default value. A third
possibility here is to use the same type \code{A} as additional input and result to the part change
function. Then, if the part change function is not executed, its additional input can be returned
as result. This works even for linear types \code{A} since this way the value is not discarded. However,
this approach makes chaining cumbersome, since the rest of the chain is passed as additional input and
must therefore also be returned as result. A fourth
possibility is to change a part which safely exists instead. Thus the part change function is executed and
consumes its input and produces its output in the normal way. This is the most flexible approach, it allows
arbitrary types as additional input and result to the part change function.

If the part's type \code{S} is not linear, it can be efficiently accessed using a pointer to it.
Gencot supports this with the following two operations:
\begin{description}
  \item[\code{getref}] return a pointer to a part,
  \item[\code{modref}] apply a modification function in-place to a part.
\end{description}

The function \code{getref} has functionality \code{T! -> PS!} where \code{PS} is the mapped type used by Gencot
for pointer to \code{S}. If \code{S} is an unboxed record or abstract type \code{\#B} then \code{PS} is the
corresponding boxed type \code{B}. Otherwise \code{PS} is the type \code{P\_S} generated by Gencot for pointers
to values of type \code{S}. The function cannot be implemented in Cogent and is usually implemented in C using the address 
operator \code{\&}. The operation is safe since both the structure and the result type are readonly. The shared
memory used by both can neither be modified through the structure nor through the resulting pointer. 

If the part does not safely exist, the situation is similar to function \code{get}. However, now the result 
type \code{PS} is always linear, so \code{defaultVal} cannot be used to provide a default value.

The function \code{modref} has functionality \code{ModPartFun T PS A O} where \code{A} and \code{O} are
arbitrary types. It behaves as described in Section~\ref{design-operations-modify}. If the part does not safely exist, 
the possible solutions are the same as for function \code{modify}.

Note that all part access functions are defined in a way that they never allocate or deallocate memory on the heap.
therefore they never need the heap as additional in- and output.

An alternative to the function \code{modref} would be a pair of functions \code{ref} and \code{deref} where \code{ref}
returns the pointer together with the structure converted to a type which marks the part as removed (for a record this
corresponds to the type with a field taken), and \code{deref} converts the type back to normal. 
Since the structure has the converted type the part cannot be accessed through it
as long as the type has not been changed back which is done by \code{deref}, consuming the pointer.
However, it is possible to apply \code{deref} to another pointer of the same type, causing sharing between the 
structure and the original pointer. To prevent this it must be proven for the Cogent program that the \code{deref}
operation is always applied to a pointer retrieved by a \code{ref} operation before any other \code{deref}
is applied to the structure. This implies that
for proving the type safety properties an arbitrary complex part of the Cogent program must be taken into
account. Therefore Gencot does not support such functions.

To make the other parts of the structure available in the modification operation the \code{modref} operation could
pass the structure to it together with the additional input, with the type converted to a readonly type where the modified
part is marked as removed. This is safe because in the modification function the part cannot be accessed
through the structure and the structure cannot be modified by inserting another value for the part since it is
readonly in the modification operation. Note however, that instead of passing the structure to the modification operation,
all (nonlinear) values required from it can also be retrieved outside of \code{modref} and passed to it as part of the 
additional information of type \code{A}. Therefore Gencot does not support this approach.

\subsection{Primitive Types}
\label{design-operations-prim}

The primitive Cogent types are the numerical types, \code{Bool} and \code{String}. 

\subsubsection{Creating and Disposing Values}

Values of primitive types cannot be created and disposed. If instances such as \code{create[U32]} are used in a program 
this is not detected as error by the Cogent compiler. However, since Gencot does not provide implementations for such
instances the resulting C program will not compile.

\subsubsection{Modifying Values}

Values of primitive types cannot be modified, they can only be replaced. The type constructor \code{ChgFun} 
can be used to define such replacement functions for primitive types. The type constructors for modification functions
defined in Section~\code{design-operations-modify} can also
be applied to primitive types, however the resulting function type does not have the
intended semantics of modification functions. Therefore such types should not be used.

\subsubsection{Initializing and Clearing Values}

Values of primitive types cannot be initialized or cleared. For primitive types there is no corresponding empty-value type.
Like for the modification function types the type constructors
\code{IniFun} and \code{ClrFun} can be applied to primitive types with useful results, but not with the intended semantics.
Therefore they should not be used.

\subsubsection{Accessing Parts of Values}

Primitive values have no parts, therefore the part access operations are not provided for them.

Although the type \code{String} has a structure consisting of a sequence of characters, access to characters is not supported
by Gencot because there is no known size for \code{String} values.

\subsection{Pointer Types}
\label{design-operations-pointer}

Here we denote as ``Gencot pointer types'' all Cogent types of the form \code{CPtr Ref} where \code{Ref} is an arbitrary non-function
Cogent type (except the unit type). These types are generated by Gencot for several C pointer types (see Section~\ref{design-types-pointer}).

Gencot pointer types always point to a value of primitive type, or again a pointer 
(which may also be a function pointer, or a pointer used to represent an array or a boxed record).

Gencot pointer types do not include the type \code{CVoidPtr}. Since this is the mapping of the C type \code{void*} no information 
about the referenced data structure is available. Therefore Gencot cannot support any operations 
for it. Values of this type are fully opaque, they can be passed around but neither created, nor manipulated or disposed. 

It is possible for the developer to manually use additional Gencot pointer types by applying the generic type \code{CPtr} to other
Cogent types. Gencot provides the operation support described in the following sections also for such types.

\subsubsection{Creating and Disposing Pointers}

Since every Gencot pointer type is implemented by a Cogent record type, the corresponding empty-value type can be constructed by 
taking the single field: \code{(CPtr Ref) take (..)} which is equivalent to the expansion of the macro call \code{EVT(CPtr Ref)}
(see Section~\ref{design-operations-create}).

For every Gencot pointer type \code{CPtr Ref} used in the Cogent program Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[EVT(CPtr Ref)]
  dispose[EVT(CPtr Ref)]
\end{verbatim}

\subsubsection{Modifying Pointers}

Since Gencot pointer types are specific Cogent record types, modifications of pointer values can be done with the Cogent take and 
put functions.

The only modification function applicable to a pointer consists of replacing the referenced value. Such modifications correspond
either to initialization and clearing operations or to dereferencing operations, described in the next two sections.

\subsubsection{Initializing and Clearing Pointers}

Before a pointer returned by \code{create} can be used it must be initialized by storing a value into the referenced memory region.
Dually, before disposing a pointer the memory region may be cleared.

All instances of the functions \code{initFull/Heap/Simp} and \code{clearFull/Heap/Simp} described in 
Section~\ref{design-operations-init} are available
for Gencot pointer types. Functions \code{initFull} and \code{clearFull} additionally pass the value referenced
by the pointer (wrapped in an unboxed record). Functions \code{initSimp} and \code{clearSimp} set the referenced
value to its default value, discarding it upon clearing. Functions \code{initHeap} and \code{clearHeap} 
are required, if the referenced value is linear, for allocating or deallocating it on the heap. 

Functions
\code{initHeap} and \code{clearHeap} must also be used if the referenced value is of type \code{MayNull a} 
(see Section~\ref{design-operations-null}) since it has linear type. Note that function \code{initHeap} here
actually does not use the heap since it sets the referenced value to null. However, we assume that this is
feasible and do not provide alternative support for it, since it can also be implemented in Cogent using
the put operation.

For example a pointer \code{p} of type \code{EVT(CPtr U32)} can be initialized to the value \code{5} with typechecks by the 
Cogent expression
\begin{verbatim}
  INIT(Full,CPtr U32) (p,#{cont=5})
\end{verbatim}
and a pointer \code{p} of type \code{CPtr (CPtr U32)} can be cleared with typechecks by the Cogent expression
\begin{verbatim}
  CLEAR(Heap,CPtr (CPtr U32)) (p,heap)
\end{verbatim}
which clears and disposes the referenced pointer.

Alternatively values of Gencot pointer type can be initialized and cleared using the Cogent put and take
operations. Then the code for the initialization example above is
\begin{verbatim}
  p{cont=5}
\end{verbatim}
and for the clearing example is
\begin{verbatim}
  let p{cont=h}
  and heap = dispose(h,heap)
  in (p,heap)
\end{verbatim}
where clearing the value referenced by \code{h} is omitted since it is of primitive type.

\subsubsection{Dereferencing Pointers}

If a pointer is seen as a structured value, it has the referenced value as a single part.
Then the operations for accessing parts of a structured value can be defined for a Gencot pointer type as follows
The operation \code{getref} corresponds to the identity, the operation \code{modref} is equivalent to applying the
part modification function directly to the pointer. Both are not provided separately for pointers.
The other operations all dereference the pointer in some way. Gencot provides in \code{inlude/gencot/CPointer.cogent} 
the polymorphic functions
\begin{verbatim}
  getPtr: all(ptr,ref). ptr! -> ref! 
  setPtr: all(ptr,ref:<D). ModFun ptr ref ()
  exchngPtr: all(ptr,ref). ModFun ptr ref ref
  modifyPtr: all(ptr,ref,arg,out). ChgPartFun ptr ref arg out
\end{verbatim}
Instances of these functions are only defined if \code{ptr} is a Gencot pointer type and \code{ref} is the corresponding
type of the referenced values. 

The function \code{getPtr} dereferences a readonly pointer and returns the result as readonly. The function \code{setPtr}
replaces the referenced value by its second argument, discarding the old value. The function \code{exchngPtr} works like 
\code{setPtr} but returns the old referenced value as additional result. The function \code{modifyPtr} applies a change
function to the referenced value, replacing or modifying it.

Since a Gencot pointer type corresponds to a pointer which is guaranteed to be not null, the value referenced by the 
pointer safely exists and the functions need not handle the case where it does not exist.

\subsection{Function Pointer Types}
\label{design-operations-function}

As described in Section~\ref{design-types-pointer}, function pointer types are mapped by Gencot to abstract types of the form 
\code{CFunPtr\_EncFuntyp} where \code{EncFuntyp} encodes a C function type, or \code{CFunInc\_EncRestyp} where \code{EncRestyp}
encodes the C result type. They are not covered by Gencot pointer types since they behave differently.

\subsubsection{Creating and Disposing Function Pointers}

Function pointers cannot be created and disposed. Gencot does not provide instances of \code{create} and \code{dispose}
for function pointer types.

\subsubsection{Modifying Values}

Function pointers cannot be modified. As for primitive types the type constructors for modification functions should not be used for them.

\subsubsection{Initializing and Clearing Values}

Function pointers cannot be initialized or cleared, there is no corresponding empty-value type.
Like for the modification function types the type constructors
\code{IniFun} and \code{ClrFun} can be applied to function pointer types with useful results, but not with the intended semantics.
Therefore they should not be used.

\subsubsection{Accessing Parts of Values}

Function pointers have no parts, therefore the part access operations are not provided for them.

\subsubsection{Converting between Functions and Function Pointers}

For the values of the abstract type for function pointers in Cogent there are two relevant operations: invoking
it as a function and converting a Cogent function to a value of that type. Both are supported by Gencot
by providing polymorphic abstract functions in \code{inlude/gencot/CPointer.cogent} for the task.

The latter operation is supported by the polymorphic abstract function
\begin{verbatim}
  toFunPtr: all(fun,funptr). fun -> #funptr
\end{verbatim}
where \code{fun} is a Cogent function type and \code{funptr} is the Cogent abstract type representing the function pointer.

Invoking a function is supported by translating the function pointer to the Cogent function (equivalent to the enumeration value) which
then can be invoked in the usual way in Cogent. The translation is done by the polymorphic abstract function
\begin{verbatim}
  fromFunPtr: all(fun,funptr). #funptr -> Result fun ()
\end{verbatim}

All functions for which a function pointer is accepted or returned by these functions must be known to
Cogent so that there is an enumeration constant for it. It is not possible to pass a pointer to an arbitrary 
C function to Cogent as a parameter or as a field in a record. The function must either be defined in Cogent 
or it must be defined as an abstract function in Cogent. In both cases, the function may also be an instance of
a polymorphic Cogent function. 

Note, that if no function of type \code{fun} is 
defined in the Cogent program, the generated C code from an invocation of the result of \code{fromFunPtr} 
in Cogent is incomplete, since it invokes the dispatcher function which does not exist.

Illegal function pointers will be detected in the function \code{fromFunPtr}. The function must be implemented 
by selecting the result from a fixed list of known functions. Its result type uses the generic type \code{Result}
from the Cogent standard library. If the input pointer does not point to a 
function in the list (because it is NULL or points to an unknown function), an error is returned. Therefore,
whenever a function pointer shall be invoked, after translating it it must be checked whether the translation
was successful.

Note that \code{toFunPtr} is always successful, since it gets a known Cogent function as input and returns 
the corresponding function pointer.

Gencot defines in \code{inlude/gencot/CPointer.cogent} the preprocessor macros 
\begin{verbatim}
  TOFUNPTR(ENCFT)
  FROMFUNPTR(ENCFT)
\end{verbatim}
which expand to typed instances of both functions, where \code{ENCFT} is the encoding of the C function type.

Hence for example for the C type
\begin{verbatim}
  int *()(int, short)
\end{verbatim}
the following function instances are provided
\begin{verbatim}
  toFunPtr[(U32,U16) -> (CPtr U32),CFunPtr_FXU32XU16X_P_U32]
  fromFunPtr[(U32,U16) -> (CPtr U32),CFunPtr_FXU32XU16X_P_U32]
\end{verbatim}
which can be specified using the macros as
\begin{verbatim}
  TOFUNPTR(FXU32XU16X_P_U32)
  FROMFUNPTR(FXU32XU16X_P_U32)
\end{verbatim}

For incomplete function pointer types of the form \code{\#CFunInc\_ENCT} Gencot cannot provide instances of
\code{fromFunPtr} and \code{toFunPtr}, since it cannot determine the corresponding Cogent function type. Therefore
such function pointers cannot be used in any way in Cogent, they can only be passed through.

An alternative approach for invoking a function pointer would be a polymorphic abstract function 
\begin{verbatim}
  invkFunPtr: all(args,res). (#(CFunPtr (args->res)), args) -> res
\end{verbatim}
where \code{args} is the type of the single argument of the Cogent function (possibly a tuple) and \code{res}
is the result type of the Cogent function. In its C implementation \code{invkFunPtr} applies the function pointer
to the argument and returns its result. 
This approach always causes correct C code to be generated by the Cogent compiler. However, since the Isabelle
C parser does not support function pointer invocations, no refinement proof can be processed for the resulting
C program.

Therefore Gencot does not support this alternative approach.

\subsection{\code{MayNull} Pointer Types}
\label{design-operations-null}

The type safety of Cogent relies on the fact that the pointers representing values of linear types are never \code{NULL}.
If null pointers are used in the C source, Gencot reflects this in Cogent by marking the type with \code{MayNull} (see 
Section~\ref{design-types-pointer}. The way how to work with
null pointers in a binary compatible way depends on the way how the null pointers are used.

A null pointer can be used as struct member \code{f} to mark the corresponding part as ``uninitialized''. 
It is set when the struct is created and later
replaced by a valid pointer. It remains valid until the struct is disposed. If additionally the struct is used only in places
during the ``uninitialized state'' which are different from those afterwards, the ``uninitialized state'' can be represented
by marking the part \code{f} as not present in the type used for the struct. Setting the pointer to a non-null value 
changes the struct type to the normal type used for it in Cogent. In a similar way NULL pointers can be used in array
elements and in referenced values while the array or pointer has its empty-value type. In all these cases the pointer needs
no \code{MayNull} wrapper type, since the surrounding type already distinguishes between \code{NULL} values and valid values.

If the field \code{f} is initialized ``on demand'', i.e., not at a statical point in the program, or if not all elements
of an array are initialized together, this solution is not possible.
A null pointer can also be used as an ``error'' or ``escape'' value for function parameters or results. In all these cases
the \code{MayNull} marker type is required.

Since \code{MayNull} is an abstract type no predefined operations can be applied to its values. Gencot only defines abstract 
functions for
generating and testing the null pointer. Gencot provides the following generic abstract data type in \code{include/gencot/MayNull.cogent}.
It is available for all linear Cogent types, not only for types generated by Gencot by mapping a C pointer type.
\begin{verbatim}
  type MayNull a 
  null:      all(a:<E). () -> MayNull a
  roNull:    all(a). () -> (MayNull a)!
  mayNull:   all(a:<E). a -> MayNull a
  roMayNull: all(a). a! -> (MayNull a)!
  notNull:   all(a). MayNull a -> Option a
  roNotNull: all(a). (MayNull a)! -> (Option a)!
\end{verbatim}
The function \code{null} returns the null pointer, the function \code{mayNull} casts a non-null pointer of type \code{a}
to type \code{MayNull a}. For both the type \code{a} must be escapeable, otherwise it would be possible to wrap a value
of type \code{P!} which cannot escape from a banged context as a value of type \code{MayNull (P!)} which can escape.
The operations \code{roNull} and \code{roMayNull} must be used for readonly pointers, they return a result which is again 
readonly. This cannot be done 
by applying the bang operator to the result of \code{null} or \code{mayNull} since then the readonly result value
cannot escape the banged context. 

The type \code{Option} is used from the Cogent standard library. It is preferred over type \code{Result} because being null
is not interpreted as an error here.
The function \code{notNull} returns \code{None} if the argument is null and \code{Some x} if the argument \code{x} is not null.
The function \code{roNotNull} does the same for a readonly argument. 
Since \code{notNull} and \code{roNotNull} are the only functions which make the value available as a value of type \code{a} 
it is guaranteed by the Cogent type constraints that all accesses to the value are guarded by one of these two functions
(if no other abstract functions are introduced which convert from \code{Maynull a} to \code{a}).

As usual,
the type parameter \code{a} cannot be restricted by Cogent to linear types. However, Gencot provides instances of the functions only for
linear types \code{a}.

Based on the abstract functions the function
\begin{verbatim}
  isNull: all(a). (MayNull a)! -> Bool
\end{verbatim}
is defined for an explicit test for the null pointer. It could be implemented in Cogent based on function \code{roNotNull} but
is implemented in C for efficiency reasons, avoiding the intermediate use of a value of type \code{Option a}.

\subsubsection{General Operations}

Values of type \code{MayNull a} cannot be created, disposed, initialized, or cleared. Either they are null, or they are pointers of
a valid-value pointer type, for which the type-specific functions for creating, initializing, cearing, and disposing are available.

The type constructors for modification function (see Section~\ref{design-operations-modify}) can be applied to \code{MayNull a} 
with the usual intended semantics.

\subsubsection{Part Access Operations}

Conceptually, the type \code{MayNull a} can be seen as a structured value with the non-null pointer of type \code{a} being
an optional ``part''. Then the operations for accessing parts of a structured value can be defined for \code{MayNull a} as follows
The operation \code{get} corresponds to \code{roNotNull}. The operation \code{set} cannot be defined, since the type \code{a} of the 
``part'' is always linear and thus not discardable. The operations \code{getref} and \code{modref} cannot be defined, since
the ``part'' is identical to the container and need not be stored somewhere on the heap. 
All four operations are not provided by Gencot. The other two operations are provided
by the polymorphic functions
\begin{verbatim}
  exchngNull: all(a:<E).
     ModFun (MayNull a) a a
  modifyNull: all(a:<E,arg).
     ModPartFun (MayNull a) a arg arg
  modifyNullDflt: all(a:<E,arg:<D,out:<DSE).
     ModPartFun (MayNull a) a arg out
\end{verbatim}
Again, instances of the functions are only defined if \code{a} is a linear type. Additionally it must be escapeable, since
otherwise no values of type \code{Maynull a} can be constructed. The operations are not supported if \code{a} is not 
escapeable, since then the wrapped type would be \code{(MayNull a)!} and modifying its values would contradict the 
meaning of the bang operator. Like \code{isNull} the functions could be 
implemented in Cogent but are implemented in C for efficiency.

The function \code{exchngNull (mn, p)} takes as input two pointers, the first of which may be null. If \code{mn} is not null 
the result is the pair of \code{mayNull p} and the non-null pointer corresponding to \code{mn}.

The functions \code{modifyNull (mn, (modfun,addinput))} and \code{modifyNullDflt (mn, (modfun,addinput))} are
alternatives for operation \code{modify} as described in Section~\ref{design-operations-parts}.
If \code{mn} is not null it modifies the object referenced by \code{mn} by applying the part modification function \code{modfun} of type 
\code{ModFun a arg out} to \code{mn} and returns \code{mn} and the additional result of type \code{out}. Note that since here
the ``part'' is identical with the ``whole'', to modify the whole a modification function must be applied to the part instead of
a change function. Therefore the functions have type \code{ModPartFun} instead of \code{ChgPartFun}.

The case where the \code{MayNull a} value is null corresponds to the case where the part does not exist. According to the description in
Section~\ref{design-operations-parts} the function \code{roNotNull} corresponds to function \code{get} with a variant type as result.
Here a more efficient alternative passing the result value immediately is not possible, since in the null case a valid pointer must
be passed, which is not available. Therefore the typical C pattern of dereferencing a pointer without testing for null, because
we know from the context that it is not null, cannot be transferred directly to Cogent. However, a similar effect can be achieved
using type \code{a} for which it is guaranteed by the Cogent type system that it is a non-null pointer and which is always dereferenced
without testing it for null. 

Function \code{exchngNull} behaves in the null case as described in Section~\ref{design-operations-parts}, it returns its input \code{(mn,p)}.
Function \code{modifyNull} corresponds to the third case described in Section~\ref{design-operations-parts}. It uses the same type
for the additional input and result and returns the input to the part modification function as output when the part modification 
function is not used. This is the most general solution, therefore it is preferred over the other two. Since it restricts the function
to be used as part modification functions, the alternative \code{modifyNullDflt} is provided which discards the additional argument
and returns the default value \code{defaultVal[out]()} as additional result, however it is restricted in its types \code{arg} and
\code{out} as usual.

\subsection{Record Types}
\label{design-operations-record}

As described in Section~\ref{design-types-struct} C struct types are always mapped to Cogent record types.
Additional record types may be introduced manually in the translated Cogent program.

\subsubsection{Creating and Disposing Records}

The empty-value type corresponding to a record type \code{R} is the type \code{R take (..)} where all fields are taken,
which may be denoted by \code{EVT(R)} (see Section~\ref{design-operations-create}).

For every record type \code{R} used in the Cogent program (not only those generated by mapping a C type) Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[EVT(R)]
  dispose[EVT(R)]
\end{verbatim}

\subsubsection{Modifying Records}

The type constructors \code{ModFun}, \code{ModTypeFun}, \code{ChgPartFun}, and \code{ModPartFun} can be applied to record types with the 
usual intended semantics. 

A specific kind of modification functions for records are functions which put or take a record field. 
Gencot defines macros in \code{include/gencot/CStruct.cogent} to generate the type of simple put and take operations for
record types.

A macro call of the form 
\begin{verbatim}
  PUTFUN(R,f,A,O)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take f) R A O
\end{verbatim}
for a function which puts field \code{f} in a record of type \code{R}. A macro call of the form
\begin{verbatim}
  TAKEFUN(R,f,A,O)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun R (R take f) A O
\end{verbatim}
for a function which takes field \code{f} in a record of type \code{R} (without returning the taken value).

A macro call of the form 
\begin{verbatim}
  PUTFUN<n>(R,(f1,...,fn),f,A,O)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f,f1,...,fn)) (R take (f1,...,fn)) A O
\end{verbatim}
for a function which puts field \code{f} while the fields \code{fi} are already taken. A macro call of the form
\begin{verbatim}
  TAKEFUN<n>(R,(f1,...,fn),f,A,O)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f1,...,fn)) (R take (f,f1,...,fn)) A O
\end{verbatim}
for a function which takes field \code{f} while the fields \code{fi} are already taken.

Gencot does not automatically define modification functions for record types, since a record can be modified using the
Cogent get and put operations for its fields. Only if a field of unboxed record type is modified in-place through a 
modification function for its context, the record fields
must be manipulated using modification functions for the record. Then such operations must be defined manually.

\subsubsection{Initializing and Clearing Records}

Before a record returned by \code{create} can be used it must be initialized by putting values for all fields. 
Dually, before disposing a record it must be cleared by taking all fields.

All instances of the functions \code{initFull/Heap/Simp} and \code{clearFull/Heap/Simp} described in 
Section~\ref{design-operations-init} are available
for record types. Functions \code{initFull} and \code{clearFull} pass a value of the corresponding
unboxed record type. Functions \code{initSimp} and \code{clearSimp} set all fields to
their default value, ignoring them upon clearing. Functions \code{initHeap} and \code{clearHeap} 
are required if the record contains fields of linear type, for allocating or deallocating values for them on the heap.

Functions
for initializing and clearing a record \code{r} of type \code{R} by treating the fields differently can be manually 
defined in Cogent by putting or taking values into/from all fields.

If fields of linear type or of unboxed record or abstract type should be initialized or cleared using specific initialization
or clearing functions, these functions can either be specified explicitly in the code or they can be passed as additional
parameter to the initialization or clearing function. 

A field \code{f} with an unboxed record type \code{\#S} corresponds to an embedded struct in C. The space for this struct is allocated together
with the space for \code{r} by function \code{create}, so it needs only be initialized. The \code{initFull} instance initializes 
it by writing the value in one assignment together with alll other fields. The \code{initHeap/Simp} instances instead pass a pointer 
to the embedded struct to corresponding \code{initHeap/Simp} instances for the part. 

When an initialization function for \code{R} is implemented
manually, it should be possible to do the same with an arbitrary initialization function of type \code{IniFun EVT(S) S arg out}
for field \code{f}. This is the same approach as for the operation \code{modref} described in Section~\ref{design-operations-modify}.
However, \code{modref} takes as argument a value of type \code{R}
where no field is taken, so it cannot be used to put the taken field \code{f} by initializing it. Separate modification functions
are required for the record with taken fields. If the record contains several embedded structs every modification function
initializes one field and the result type has one field less taken. Thus, defining such modification functions imposes an order
in which the embedded structs must be initialized and whether they are initialized before or after the other fields. A corresponding
modification function for field \code{f} which must be initialized before field \code{g} but after all other fields would be
\begin{verbatim}
  putFInR : all(arg,out). 
    PUTFUN1(R,(g),f,(IniFun EVT(S) S arg out,arg),out)
\end{verbatim}
It is invoked with the initialization function for the embedded record and its argument 
as additional information. In a similar way a field of unboxed record type \code{\#S} can be cleared in-place using an abstract
function of the form
\begin{verbatim}
  takeFInR : all(arg,out).
    TAKEFUN1(R,(g),f,(ClrFun S EVT(S) arg out,arg),out)
\end{verbatim}
which applies a clearing function of type \code{ClrFun S EVT(S) arg out} and takes the field \code{f} while field \code{g} 
is already taken. Of course, instead of polymorphic functions for all types \code{arg} and \code{out} the specific forms
corresponding to \code{initFull}, \code{initHeap}, or \code{initSimp} can be defined.

Another approach to record initialization could have been that the function \code{create[EVT(R)]} returns a value where 
only the fields of primitive and linear type
are taken and the embedded structs are present, but again with all primitive and linear fields taken. Then the initialization function for
field \code{f} could be directly applied to a pointer to field \code{f}. However, it is still necessary to retrieve the pointer to \code{f}
with the help of an abstract function which now has to respect the fact that other embedded record fields have types with
some fields taken. So the same number of additional abstract functions is needed as in the approach above and their argument
types are of similar complexity.

Initializing a field \code{f} with a function pointer type \code{\#C(FunPtr Funtyp)} can always be done using the Cogent put operation.
The value to be put must be constructed using the function \code{toFunPtr} (see Section~\ref{design-operations-function}). To
avoid null pointers to functions, as described in Section~\ref{app-transfunction-pointer}, a dummy function should be defined in
Cogent and passed to the \code{toFunPtr} function.

\subsubsection{Accessing Record Fields}

The parts of a record are its fields. The conceptual operations for accessing parts of a structured value can be defined for a record type 
\code{R} as follows.

The field to be accessed by the operation must be specified by its name. This can only be done as part of the function name.
Therefore Gencot does not define polymorphic functions for accessing arbitrary fields of arbitrary record types. For every record type
\code{R} a set of differently named functions must be defined for every field \code{f}. Since only some of the functions are needed, Gencot
does not automatically generate such functions, they must be defined manually, if required.

The access functions can be defined as polymorphic functions in respect to the record type. Then, for every field name
\code{f} there is a polymorphic function which can be used for all records with a field named \code{f}. Additionally, the
function must be polymorphic in the field type, so that it supports fields of different type. The resulting 
functions have the following forms
\begin{verbatim}
  getFld_f : all(rec,fld). rec! -> fld!
  setFld_f : all(rec,fld:<D). ModFun rec fld ()
  exchngFld_f : all(rec,fld). ModFun rec fld fld
  modifyFld_f : all(rec,fld,arg,out). ChgPartFun rec fld arg out
\end{verbatim}
where \code{rec} is the type of the record and \code{fld} is the type of the field.

The operation \code{getFld\_f} for a field \code{f} corresponds to the Cogent member access operation \code{r.f}.
Since the \code{get} operation is not passed as argument to other functions, it need not be defined for record fields, it is always possible
to use the Cogent member access operation instead.

The operation \code{setFld\_f} for a field \code{f} and a value \code{v} corresponds to the Cogent put operation r{f = v}, if
the field has a discardable type. Otherwise it is not supported.

The operation \code{exchngFld\_f} for a field \code{f} and a value \code{v} can be implemented in Cogent by first taking the 
old value of \code{f}, then putting \code{v} and finally returning the record together with the old value.

The operation \code{modifyFld\_f} for a field \code{f} and a field change function can be implemented in Cogent 
by first taking the value of \code{f}, then applying the change function to it, and finally putting the result back into
the field. 

All three operations may be passed as argument to other modification functions, then they must be defined and cannot be replaced
by a direct inline implementation in Cogent.

Defining the access functions as polymorphic in the record type has the drawback that they cannot be implemented in Cogent, 
although every single instance for a specific record type can be implemented in Cogent. So, an alternative approach is to
define the access functions for every record type \code{Rec} and every field \code{f} of \code{Rec} with type \code{Ftp} as
\begin{verbatim}
  getFld_F_InRec : Rec! -> Ftp!
  setFld_f_InRec : ModFun Rec Ftp ()
  exchngFld_f_InRec : ModFun Rec Ftp Ftp
  modifyFld_f_InRec : all(arg,out). ChgPartFun Rec Ftp arg out
\end{verbatim}
where \code{setFld\_f\_InRec} is only defined if \code{Ftp} is discardable.

The operations \code{getref} and \code{modref} cannot be implemented in Cogent, they must be defined as abstract function which are implemented in 
C with the help of the address operator \code{\&}. For a field \code{f} the corresponding function definitions have the form
\begin{verbatim}
  getrefFld_f : all(rec,pfld). rec! -> pfld!
  modrefFld_f : all(rec,pfld,arg,out). ModPartFun rec pfld arg out
\end{verbatim}
where \code{pfld} is the Gencot mapping of the type of pointer to the field type. 

Since whenever an instance of these functions is defined, the field is safely existing, the case of the nonexisting
part needs not be respected.

Remember that according to the definition of 
\code{ModPartFun} the function \code{modrefFld\_f} is invoked in the form
\begin{verbatim}
  (r',o) = modrefFld_f(r, (m,a))
\end{verbatim}
where \code{r} is a boxed record value which is not readonly, \code{m} is a modification function of type \code{ModFun pfld arg out} which
has the form \code{(pfld,arg) -> (pfld,out)}, \code{a} is the argument of type \code{arg} passed to \code{m}, \code{r'} is
the record value \code{r} after the modification, and \code{o} is the additional result of type \code{out} returned by \code{m}.

\subsection{Array Types}
\label{design-operations-array}

Gencot represents arrays of known size in Cogent always by a (boxed) type \code{CArr<size> El} which is a record 
type wrapping the array (see Section~\ref{design-types-array}).
We call these types ``Gencot array types'' here.

Gencot array types are complemented by abstract polymorphic functions for working with
arrays. For these functions Gencot automatically generates the instance 
implementations in C. All these implementations involve the array size in some way. The developer may manually introduce
additional Gencot array types by adhering to the Gencot naming schema for array types (see Section~\ref{design-types-array}). 
Then Gencot also supports these types and generates instances of all polymorphic functions for them.

If the array size is unknown (types of the form \code{CArrXX El})
no instances of the polymorphic functions are provided by Gencot. However, implementations may be provided manually. Often
this is possible by the developer determining the array size from the context. If several array types with 
different unknown sizes have been mapped to the same abstract type, they must be disambiguished manually.

Gencot only supports arrays which are allocated globally or on the heap. In C, arrays can also be introduced by defining
them as local variable, but Cogent has no language constructs which support this.

\subsubsection{Creating and Disposing Arrays}

Cogent does not provide a language construct to create or dispose values for Gencot array types.

Since Gencot array types are implemented as Cogent records, the empty-value type corresponding to type \code{CArr<size> El} 
is generated by the macro call \code{EVT(CArr<size> El)} as 
usual.

For every Gencot array type \code{CArr<size> El} used in the Cogent program Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[EVT(CArr<size> El)]
  dispose[EVT(CArr<size> El)]
\end{verbatim}

Both functions also support multidimensional array types of the form \code{CArr<size1> \#(CArr<size2> El)}.

\subsubsection{Modifying Arrays}

If an array is seen as a structured value, its elements are its parts.

When C array types were mapped using abstract functions all accesses to array elements 
must be performed using abstract functions. Since Cogent builtin array types are used for mapping C array types, 
the index operator \code{"\@"} can be used instead. In the current Cogent version (Oct 2020) the index operator 
does not yet work for boxed array types, therefore Gencot still uses abstract functions for array element access.

%Only if the index value is statically known the builtin access operations can be used.
%Gencot uses only abstract functions in both cases, in the current version
%it does not try to optimize accesses using statically known indexes for builtin array types.

The type constructors for modification functions (see Section~\ref{design-operations-modify}) can be applied to 
Gencot array types with the usual intended semantics. 

Gencot provides no equivalent for single Cogent take and put operations for array elements. It would be
necessary to statically encode the set of array indices for which the elements have been taken in the type expression,
this is not feasible (although Cogent builtin array types support it).

\subsubsection{Initializing and Clearing Arrays}

An array initialization function sets a valid value for every element. An array clearing function clears every element, 
clearing and disposing all linear values contained in elements. Since all elements are of the same type, they can all be
treated in the same way by an initialization or clearing function for the element type. Array elements are similar to
an embedded struct: the element value is stored in-place in the memory region used for the array. Hence, initializing and 
clearing an element can also be done in-place by passing a pointer to the element to the element initialization or 
clearing function. As usual, an additional input given to the array function is passed through to every invocation 
of the element function. 

All instances of the functions \code{initFull/Heap/Simp} and \code{clearFull/Heap/Simp} described in 
Section~\ref{design-operations-init} are available
for Gencot array types. Functions \code{initFull} and \code{clearFull} take or return the complete array content
as an unboxed value of type \code{\#(CArr<size> El)}. Functions \code{initSimp} and \code{clearSimp} set all elements
to their default value, ignoring them upon clearing. Functions \code{initHeap} and \code{clearHeap} 
are required, if the element type is linear, for allocating or deallocating it on the heap.

For example an array \code{a} of type \code{EVT(CArr16 U32)} can be initialized by setting all elements to \code{0} 
(the \code{defaultVal[U32]()}) with typechecks by the Cogent expression
\begin{verbatim}
  INIT(Simp,CArr16 U32) (a,())
\end{verbatim}
and an array \code{a} of pointers to integers with Cogent type \code{CArr16 (CPtr U32)} can be cleared with typechecks 
by the Cogent expression
\begin{verbatim}
  CLEAR(Heap,CArr16 (CPtr U32)) (a,heap)
\end{verbatim}
which will clear and dispose all elements.

Additionally, Gencot provides operations where the user can specify how to initialize or clear a single element, which is then
applied to all elements. The specification for a single element is done by passing an initialization or clearing function which
can be applied to a pointer to the element. Gencot defines the corresponding polymorphic abstract functions
\begin{verbatim}
  initEltsParCmb: all(evt,vvt,epe,vpe,arg:<S,out). 
     IniFun evt vvt (IniFun epe vpe arg out, arg, (out,out)->out) out
  clearEltsParCmb: all(vvt,evt,vpe,epe,arg:<S,out). 
     ClrFun vvt evt (ClrFun vpe epe arg out, arg, (out,out)->out) out
  initEltsPar: all(evt,vvt,epe,vpe,arg:<S). 
     IniFun evt vvt (IniFun epe vpe arg (), arg) ()
  clearEltsPar: all(vvt,evt,vpe,epe,arg:<S). 
     ClrFun vvt evt (ClrFun vpe epe arg (), arg) ()
  initEltsSeq: all(evt,vvt,epe,vpe,arg). 
     IniFun evt vvt (IniFun epe vpe arg arg, arg) arg
  clearEltsSeq: all(vvt,evt,vpe,epe,arg). 
     ClrFun vvt evt (ClrFun vpe epe arg arg, arg) arg
\end{verbatim}
where \code{epe} is the empty-value type for a pointer to an element and \code{vpe} is the corresponding valid-value type.
The first pair of functions passes the additional input of type \code{arg} in parallel to every invocation of the element function, 
therefore it must be sharable. The outputs of type \code{out} are combined using the function passed as third part of
the additional input to \code{initEltsParCmb} or \code{clearEltsParCmb}. It is applied by ``folding'', starting at the first element.
The second pair uses an element function which does not return a result and needs no combination function.
The third pair of functions passes the additional result of every invocation of the element function as additional input 
to the invocation for the next element. Thus it must have a common type, which may be linear, since it is neither shared nor
discarded. 

All three initialization functions are only defined for the case that no error can occur. In particular, the function
\code{initHeap} cannot be used as element initialization function. If this is required, a corresponding array initialization
function must be implemented manually.

For every array type \code{CArr<size> El} Gencot provides corresponding instances of all six functions.
In these instances all types besides \code{A} and \code{O} are uniquely determined by the array size and the element type, although
this cannot be expressed by Cogent type constraints. Therefore Gencot defines in \code{include/gencot/CArray.cogent}
the preprocessor macros
\begin{verbatim}
  INITelts(<k>,<ek>,<size>,El,A,O)
  CLEARelts(<k>,<ek>,<size>,El,A,O)
\end{verbatim}
which expand to the corresponding instance specifications shown above and
\begin{verbatim}
  INITTYPEelts(<k>,<ek>,<size>,El,A,O)
  CLEARTYPEelts(<k>,<ek>,<size>,El,A,O)
\end{verbatim}
which expand to their function types. Parameter \code{<k>} is either \code{ParCmb}, \code{Par}, 
or \code{Seq}. The additional parameter \code{<ek>} is required for technical reasons and specifies the
kind of the element type, as for macro \code{CPTR} (see Section~\ref{design-types-pointer}. 
It must be \code{U} if the element is an unboxed record type or an unboxed Gencot array type, and it
must be empty otherwise. If \code{<k>} is not \code{ParCmb} the last parameter \code{O} is ignored and may be empty.

For example an array \code{a} of type \code{EVT(CArr16 U32)} can be initialized by setting all elements to \code{5} 
with typechecks by the Cogent expression
\begin{verbatim}
  INITelts(Par,,16,U32,U32,) (a,(INIT(Full,CPtr U32),#{cont=5}))
\end{verbatim}

It could be useful to also know the element index in the element function. This could be supported by passing the index
as additional input to the element functions. However, this implies that the normal initialization and clearing functions
for the element type cannot be used as element functions here, since they do not expect the index as additional input.
Therefore the functions automatically supported by Gencot for initializing and clearing arrays do not pass the index 
to the element functions. However, using \code{initEltsSeq} or \code{clearEltsSeq}, the index can be calculated by
passing it from one invocation of the element function to the next, counting it up in the element function.

\subsubsection{Accessing Array Elements}

All operations for accessing parts of a structured value are nontrivial for the elements of an array. Since elements are 
specified by an index value a specified element need not exist, this case must be handled by the part access operations.
The general approach here is to use the property that Gencot array types are never empty and the element at index 0 safely
exists and can be used as default if the given index is invalid.

Gencot provides polymorphic functions for all six operations with alternatives for the case where the element does not 
exist:
\begin{verbatim}
  getArr : all(arr,idx,el). (arr!,idx) -> el!
  getArrChk : all(arr,idx,el). (arr!,idx) -> Result el! ()
  setArr : all(arr,idx,el:<D). ModFun arr (idx,el) ()
  exchngArr : all(arr,idx,el). ModFun arr (idx,el) (idx,el)
  modifyArr : all(arr,idx,el,arg,out). 
    ModFun arr (idx, ChgFun el arg out, arg) out
  getrefArr : all(arr,idx,pel). (arr!,idx) -> pel!
  getrefArrChk : all(arr,idx,pel). (arr!,idx) -> Result pel! ()
  modrefArr : all(arr,idx,pel,arg,out). 
    ModFun arr (idx, ModFun pel arg out, arg) out
\end{verbatim}
The type variable \code{arr} denotes the array type, \code{idx} denotes the index type,
\code{el} denotes the array element type, and \code{pel} denotes the type of pointers to elements. 

Instances of these functions are defined if \code{arr} is a Gencot array type. Type \code{idx}
must be one of \code{U8, U16, U32, U64} according to the \code{<size>} of the array. Types \code{el} and
\code{pel} must be as determined by \code{arr}. \code{arg} and \code{out} may be arbitrary types.

Function \code{getArr} retrieves the indexed element as readonly. If the element does not exist because
the specified index is not in the range \code{0..<size>-1} the function returns the element with 
index \code{0} which always exists since Gencot array types must have atleast one element. Note that
this solution is more general than returning \code{defaultVal} since it works for arbitrary element types.
As alternative, as described in Section~\ref{design-operations-parts}, the function
\code{getArrChk} returns a variant value using the value \code{Error()} if the element does not exist.
This function should be used whenever it cannot be proven that the index is valid.

Function \code{setArr}, as usual, is only defined for a discardable element type. 
It simply discards the old value of the indexed element and sets it to the specified value.

Function \code{exchngArr}
replaces the element at the specified position by the element passed as parameter and returns the old element in the result.
The index is always part of the result so that the additional output has the same type as the additional input,
so that \code{exchngArr} can be used as element function also for \code{modifyArr} and \code{modrefArr}.

If the specified
index is not in the range \code{0..<size>-1} both functions work as described in Section~\ref{design-operations-parts}:
\code{setArr} returns the unmodified array and \code{exchngArr} returns its unmodified input.

Function \code{modifyArr} changes the element at the specified position by applying the element change function
to it. If the specified
index is not in the range \code{0..<size>-1} the function instead applies the element change function to the element
with index \code{0}. This corresponds to the fourth solution described in Section~\ref{design-operations-parts}
and supports arbitrary types of additional input and result. 

Function \code{getrefArr} returns a pointer to the element in the array without copying the element. This is safe since 
both the array and the result type are readonly. If the element does not exist it behaves like \code{getArr}, returning 
a pointer to the element with index \code{0}. The alternative function \code{getrefArrChk} is provided and returns the 
corresponding variant value.

Function \code{modrefArr} works like \code{modifyArr} but uses an
element modification function and passes a pointer to the element to it, so that the element is modified in-place.

The types of \code{modifyArr} and \code{modrefArr} are similar to a 
\code{ChgPartFun} or \code{ModPartFun}, but differ because in addition to the 
element function and its argument the element index must be passed as argument.

Note that it is not possible
to pass the array or parts of it as additional information in the parameter of type \code{arg} of the element
functions, since that would always be
a second use of the array of linear type. If several elements must be modified together, a specific modification function
must be defined and used instead of \code{modifyArr} or \code{modrefArr}.

For multidimensional array types of the form \code{CArr<n1> \#(CArr<n2> ...)} the element type is again an (unboxed) array type.
When \code{getrefArr} and \code{modrefArr} are used for the access in the outer array all access functions described here
can be used for the access in the inner array.

\subsubsection{Working with Unboxed Arrays}

As for unboxed record types, Cogent provides a value constructor for unboxed array types. Both together can be used to 
construct values of unboxed Gencot array types. For the type \code{\#(CArr3 U16)} a value can be constructed by the expression
\begin{verbatim}
  #{arr3 = [1,2,3]}
\end{verbatim}

Elements of an unboxed array can be accessed using the index operator \code{"\@"}. Thus, if the element type is not linear,
elements of a Gencot array type can be accessed directly in Cogent. The second element of a value \code{a} of type \code{\#(CArr3 U16)}
can be accessed by the expression
\begin{verbatim}
  a.arr3@2
\end{verbatim}

If the element type is linear, the unboxed array is linear as well and the dot operator cannot be used. Instead, the array must be
taken from the wrapping record, which means, the whole array must be copied even for accessing a single element.
Therefore Gencot also defines and implements abstract functions for working with unboxed Gencot array types.

Gencot does not support Gencot array types with taken elements other than empty-value types for boxed arrays. Therefore no
initialization or clearing operations are applicable to unboxed Gencot array types.

As for boxed Gencot array types Gencot only supports functions for accessing single elements of unboxed arrays. It supports the 
functions \code{getArr}, \code{getArrChk}, \code{setArr}, \code{exchngArr}, and \code{modifyArr}.
The latter four functions return a modified copy of the array. As described in Section~\ref{design-operations-modify} 
the \code{ModFun} type is interpreted accordingly for unboxed values. Note that
an unboxed array may still be of linear type, if the elements are of linear type. Then all the type restrictions
defined for the access functions are also required for the unboxed arrays. Together with these restrictions the semantics
of these functions guarantees that elements of linear type are neither shared nor discarded.

The \code{getref} and \code{modref} functions are not supported. They would return or pass a pointer to an element.
Since unboxed Gencot arrays are stack allocated these would be pointers into the stack which are not supported by the 
Isabelle C parser.

\subsection{Explicitly Sized Arrays}
\label{design-operations-esarray}

A common pattern in C programs is to explicitly use a pointer type instead of an array type for referencing an array,
in particular if the array is allocated on the heap. This is typically done if the number of elements in the
array is not statically known at compile time. The C concept of variable length array types can sometimes be
used for a similar purpose, but is restricted to function parameters and local variables and cannot be used for
structure members.

In C the array subscription operator can be applied to terms of pointer type \code{p} in the form \code{p[i]}. 
The semantics is to access an element in memory at the specified offset after the element referenced by the pointer. 
To use this in a safe way, the number of array elements must be known. 

Gencot provides support for this kind of working with arrays, if the number of elements is specified explicitly as
an integer value. Basically, the element pointer and the element size are combined to a pair. The corresponding type is called
an ``explicitly sized array'' type. Gencot uses the generic type \code{CArrES}
to construct types for explicitly sized arrays, such as \code{CArrES El} for an explicitly sized array with elements
of type \code{El}. 

For the Isabelle shallow embedding the direct use of an element pointer in the pair would correspond to a pair 
consisting of the first element and the size. Thus, explicitly sized arrays would be considered equal, if they have the
same size and the same first element. To prevent this, the element pointer type is replaced by the type \code{(CArrPtr El)}
where \code{CArrPtr} is a specific generic type introduced for this purpose. As described
in Section~\ref{design-types-pointer} for the marker type \code{MayNull}, defining \code{CArrPtr} as an abstract type can 
lead to violation of the Cogent type system guarantees, therefore it is defined like \code{CPtr} using a wrapper 
record:
\begin{verbatim}
  type CArrPtr el = { arr: el }
\end{verbatim}

Like \code{CPtr} this definition maps to a C type which is binary compatible to pointer to type \code{el} in C. In the 
shallow embedding it is mapped to type \code{list}. Based on this type definition it would be possible to access the 
first array element in Cogent, but it is not intended to be used in this way and will lead to code which cannot be verified.

Note that if \code{CArrPtr} is instead used as a marker type for the pointer type, the situation would 
be more complex: for a primitive element type an array pointer type would have the form \code{(CArrPtr (CPtr U32))},
for a struct element type \code{r} it would have the form \code{(CArrPtr Cogent\_Struct\_r)}. Both forms have to be treated 
differently in the shallow embedding.

As a C pointer, the pointer may be \code{NULL}. To express this, the type \code{MayNull} (see Section~\ref{design-types-pointer})
may be applied to \code{CArrPtr el}. However, in explicitly sized arrays it is always assumed that the pointer is not \code{NULL}.
If an arbitrary pointer is used to construct an explicitly sized array it should have type \code{MayNull (CArrPtr el)} and should
be tested with \code{notNull} before.

The corresponding type definition for explicitly typed arrays is
\begin{verbatim}
  type CArrES el = (CArrPtr el, U64)
\end{verbatim}

To be able to define the functions \code{getArr}, \code{modifyArr}, and \code{modrefArr} in the same way as for fixed size
arrays, explicitly sized arrays must not be empty, i.e., the size must not be \code{0}. This property must be proven for 
all uses of explicitly sized arrays.

In the same way as the macro \code{CARR} for fixed-sized arrays (see Section~\ref{design-types-array} Gencot provides in 
\code{include/gencot/CArray.cogent} the preprocessor macro
\begin{verbatim}
  CAES(<ek>,el)
\end{verbatim}
where \code{<ek>} describes the kind of element type as for the macro \code{CPTR} (see Section~\ref{design-types-pointer}),
i.e. it is \code{U} if \code{el} is an unboxed type and it is empty otherwise. The form \code{CAES(,El)} expands to
\code{CArrES El}, the form \code{CAES(U,El)} expands to \code{CArrES \#El}.

For every instance of type \code{CArrES} Gencot provides operations as described in the following sections.

Whenever a pointer \code{p} of type \code{(CArrPtr el)} to an element is given in a program and an expression \code{s} 
is known which specifies the corresponding number of elements in the sequence, the corresponding explicitly sized array value 
can be constructed manually as \code{(p,s)} in Cogent. To make this construction more explicit, Gencot provides in 
\code{include/gencot/CArray.cogent} the preprocessor macro
\begin{verbatim}
  MKCAES(p,s)
\end{verbatim}
which expands to the pair \code{(p,s)}.

\subsubsection{Converting Arrays}

Gencot provides support for converting array values between explicitly sized arrays and the fixed size arrays of types
\code{CArr<size> El}. It supports the polymorphic abstract functions
\begin{verbatim}
  toCAES: all(arr,aes). arr -> aes
  fromCAES: all(aes,arr). aes -> arr
  rotoCAES: all(arr,aes). arr! -> aes!
  rofromCAES: all(aes,arr). aes! -> arr!
\end{verbatim}
where \code{arr} is the fixed size array type and \code{aes} is the explicitly sized array type. Gencot provides instances
for all cases where \code{arr} and \code{aes} have the same element type. Since this constraint cannot be represented in
Cogent, Gencot provides the following preprocessor macros in \code{include/gencot/CArray.cogent}:
\begin{verbatim}
  TOCAES(<size>,<ek>,El)
  FROMCAES(<size>,<ek>,El)
  ROTOCAES(<size>,<ek>,El)
  ROFROMCAES(<size>,<ek>,El)
\end{verbatim}
where \code{<size>} is the number of elements in the fixed size array type, \code{<ek>} is the kind of element type as above, 
and \code{El} is the element type. As example, the macro call \code{TOCAES(8,,U32)} expands to
\begin{verbatim}
  toCAES[CArr8 U32,CArrES U32]
\end{verbatim}
and the macro call \code{ROFROMCAES(5,,CPtr U16)} expands to
\begin{verbatim}
  rofromCAES[CArrES (CPtr U16),CArr5 (CPtr U16)]
\end{verbatim}

Function \code{toCAES} returns the pair of the pointer to the first array element and the constant known size, this
always succeeds. Function \code{fromCAES} simply returns the casted pointer. This may be wrong, so in the shallow embedding
it must be proven that the sizes are the same. An alternative would be to define \code{fromCAES} so that it compares the 
explicit size in the argument to the known fixed size of the result and, if they are equal it returns the element pointer, 
otherwise it returns an error value with the original input. However, the original input is linear and cannot be discarded
and in the context of the invocation, the linear value of the fixed size array must be consumed, therefore such a definition
would be very difficult to be used in Cogent.

\subsubsection{Creating and Disposing Explicitly Sized Arrays}

The empty-value type corresponding to an explicitly sized array type \code{(CArrES El)} cannot be constructed by 
\code{EVT(CArrES El)}, because that would take all fields from the \textit{pair}, including the size, which must be present
also for the empty-value type. Instead, Gencot uses the type \code{(EVT(CArrPtr El),U64)} as empty-value type for explicitly sized arrays.
For specifying the empty-value type Gencot provides the preprocessor macro
\begin{verbatim}
  EVT_CAES(<ek>,El)
\end{verbatim}
where parameter \code{<ek>} is as described for \code{CAES} above.

For allocating an explicitly sized array the size must be specified, since it is not known as part of the type.
Gencot provides the polymorphic abstract function
\begin{verbatim}
  createCAES: all(evp). (U64,Heap) -> Result (evp,Heap) Heap
\end{verbatim}
for all cases where \code{evp} is a type of the form \code{EVT\_CAES(<ek>,El)}, i.e., an empty-value type for an explicitly
sized array. For disposing an explicitly sized array the usual function \code{dispose} from Section~\ref{design-operations-create}
is used, since an \code{evp} value already contains all information required for applying function \code{free}.

\subsubsection{Modifying Explicitly Sized Arrays}

Explicitly sized arrays can be modified in the same way as fixed size arrays. In particular, 
all type constructors for modification functions (see Section~\ref{design-operations-modify}) can be applied to 
explicitly sized array types with the usual intended semantics. 

\subsubsection{Initializing and Clearing Explicitly Sized Arrays}

Since the array size is known at runtime, all conceptual initialization and clearing operations defined for fixed
size arrays can also be provided for explicitly sized arrays. These are the general operations defined in 
Section~\ref{design-operations-init} and the array-specific operations defined in Section~\ref{design-operations-array}.

The functions \code{initFull} and \code{clearFull} are not supported, since they are defined using the unboxed type \code{\#vvt}
to represent the content. For an explicitly sized array type the unboxed type is the same tuple type. Thus \code{initFull} has not the
intended semantics of moving data from the stack to the heap. The other functions work as described.

Since the way how the empty-value type is constructed is different for explicitly sized arrays, the macros defined in
Section~\ref{design-operations-init} cannot be used. Gencot instead provides the macros
\begin{verbatim}
  INIT_CAES(<k>,<ek>,El)
  CLEAR_CAES(<k>,<ek>,El)
  INITTYPE_CAES(<k>,<ek>,El)
  CLEARTYPE_CAES(<k>,<ek>,El)
\end{verbatim}
where \code{<k>} is one of \code{Heap} or \code{Simp}, and \code{<ek>} and \code{El} are as for \code{CAES} above. As for fixed size
arrays, the functions treat all array elements in the same way.

The functions \code{initEltsParCmb}, \code{clearEltsParCmb}, \code{initEltsPar}, \code{clearEltsPar}, \code{initEltsSeq}, 
\code{clearEltsSeq} treat elements individually. They are all supported for explicitly sized array types \code{vvt}. 
Gencot provides the macros
\begin{verbatim}
  INITelts_CAES(<k>,<ek>,El,A,O)
  CLEARelts_CAES(<k>,<ek>,El,A,O)
  INITTYPEelts_CAES(<k>,<ek>,El,A,O)
  CLEARTYPEelts_CAES(<k>,<ek>,El,A,O)
\end{verbatim}
corresponding to \code{INITelts}, \code{CLEARelts}, \code{INITTYPEelts}, and \code{CLEARTYPEelts}. As for them
\code{<k>} is one of \code{ParCmb}, \code{Par}, or \code{Seq} and \code{A} and \code{O} are arbitrary types for the 
additional input and output of the element function. \code{O} is ignored if \code{<k>} is not \code{ParCmb}.

\subsubsection{Accessing Array Elements}

All element access functions defined for fixed size arrays in Section~\ref{design-operations-array} are also supported for 
explicitly sized arrays, i.e., their type variable \code{arr} can be an explicitly sized array type. The index type \code{idx}
can be as described (one of U8, U16, U32, U64).
