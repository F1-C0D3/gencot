As described in Section~\ref{design-modular} there are several different Gencot components which process C code and generate 
target code.

\subsection{Filters for C Code Processing}
\label{impl-ccomps-filters}

All filters which parse and process C code are implemented in Haskell and read the
C code as described in Section~\ref{impl-ccode-read}.

The following filters always process the content of a single C source file and produce the content for a single 
target file.
\begin{description}
\item[\code{gencot-translate}] translates a single file \code{x.c} or \code{x.h} to the Cogent code to be put in file
\code{x.cogent} or \code{x-incl.cogent}. It processes typedefs, struct/union/enum definitions, and function
definitions. 
\item[\code{gencot-entries}] translates a single file \code{x.c} to the antiquoted C entry wrappers to be put in
file \code{x-entry.ac}. It processes all function definitions with external linkage.
\item[\code{gencot-remfundef}] processes a single file \code{x.c} by removing all function definitions. The output
is intended to be put in file \code{x-globals.c}
\item[\code{gencot-deccomments}] processes a single file \code{x.c} or \code{x.h} to generate the list of
all declaration positions.
\item[\code{parmod-gen}] processes a single file \code{x.c} and generates the 
function parameter modification descriptions (see Section~\ref{impl-parmod}).
\item[\code{items-gen}] processes a single file \code{x.c} and generates a list of all items with internal linkage 
for which properties may be declared.
\end{description}

All these filters take the name of the original source file as additional first
argument, since they need it to generate Cogent names for C names with internal linkage and for tagless C struct/union
types.

There are other target files which are generated for the whole Cogent compilation unit. The filters for generating these target files 
take as input the list of file names to be processed (see Section~\ref{impl-ccode-package}). Filters of this kind 
are called ``processors'' in the following.

Usually only \code{.c} files need to be specified as input to processors.
In contrast to the single-file filters, the original file name is not required for the files input to a 
Gencot processor. A processor only processes items which are external to all input files, whereas the original
file name is needed for items which are defined in the input files. Therefore the list of input file names is
sufficient and the input files may have arbitrary names which need not be related to the names of the original 
\code{.c} files.

Gencot uses the following processors of this kind:
\begin{description}
\item[\code{gencot-exttypes}] generates the content to be put in the file \code{<package>-exttypes.cogent}. It 
processes externally referenced typedefs, tag definitions and enum constant definitions.
\item[\code{gencot-dvdtypes}] generates the content to be put in the file \code{<package>-dvdtypes.cogent}. It 
processes derived types.
\item[\code{gencot-dvdtypesah}] generates the content to be put in the file \code{<package>-dvdtypes.ah}. It 
processes derived types.
\item[\code{gencot-externs}] generates the abstract function definitions of the exit wrappers to be put in the file 
\code{<package>-externs.cogent}. It processes the declarations of externally referenced functions and variables.
\item[\code{gencot-externsac}] generates the exit wrappers to be put in the file \code{<package>-externs.ac}. It processes
the declarations of externally referenced functions.
\item[\code{parmod-externs}] generates the list of function identifiers of all externally referenced functions and
function pointer (array)s.
\item[\code{items-used}] determines a list of all declared external items which are actually used by the Cogent
compilation unit.
\item[\code{items-externs}] generates a list of all items with external or no linkage 
for which properties may be declared.
\end{description}

\subsection{Used External Items}
\label{impl-ccomps-items}

External items are those C items (functions, objects, types) which are known in the sources of the Cogent compilation
unit but not defined there. 

Functions and objects are external, if they are declared in the 
Cogent compilation unit but are not defined there. They may be defined in files of the package which do not belong to
the Cogent compilation unit (then they are declared in \code{.h} files of the package), or they may be defined in 
standard runtime libraries (then they are declared in system include files). In both cases they must have external linkage.

Gencot always assumes that all package include files used by the Cogent compilation unit are translated to Cogent and
are thus a part of the Cogent compilation unit. Thus a type can only be external if it is defined in a system include
file.

If an external item is actually used (by invoking a function, accessing an object, or referencing a type) in the Cogent
compilation unit, it must also be translated to Cogent so that it is known in the Cogent program. Functions are translated
in the form of exit wrappers, objects are translated in the form of abstract access functions, and types are translated
as usual.

Usually, C programs know many external items without actually using them. To keep the resulting Cogent code as small 
as possible, Gencot performs an automatic analysis to determine the external toplevel items which are actually used
by the Cogent compilation unit. The result of this analysis can be manually overridden by explicitly specifying additional
external items which also should be processed.

\subsubsection{The processor \code{items-used}}

The processor \code{items-used} generates a list of the external toplevel items used by the Cogent compilation unit.
It is intended as a filtering list for the processors \code{gencot-externs}, \code{gencot-exttypes}, \code{gencot-dvdtypes},
\code{items-externs} and \code{parmod-gen} which process external items, to reduce them to the relevant ones.

The processor is invoked as
\begin{verbatim}
  items-used <additional items file>
\end{verbatim}
where the argument is a list of additional external toplevel items specified manually.

A toplevel item is a struct, union, or enum, a typedef name, a function or a global variable. 

The processor writes a textual list of the used external items to its standard output. Each item is output in a separate line 
identified by its item identifer as described in Section~\ref{impl-itemprops-ids}. The argument file content must have the 
same form, it is added to the output. These additional items cannot be added afterwards, since they may use other items
which can only be detected by \code{items-used} if the additional items are known to it.

As conveniency for the developer, the argument file may contain empty lines and may contain comment lines which
start with a hash sign \code{\#}.

\subsubsection{Determining Used Functions}

A function is used by the Cogent compilation unit if it is invoked by a function which is part of the Cogent compilation unit. 
Gencot determines the invoked external functions with the help of the call graph as described in 
Section~\ref{impl-ccode-callgraph}. 

The processor parses and analyses
all C source files specified in the input file name list, resulting in the list of corresponding symbol tables, as
described in Section~\ref{impl-ccode-package}. Then
it determines for every table the invoked functions using the call graph. This must
be done before combining the tables, since invocations may also occur in the bodies of functions with internal
linkage. These functions are removed during table combination.

After determining the invoked functions, the tables are combined as described in Section~\ref{impl-ccode-package}
and the invocations are reduced to those for
which a declarations is present in the combined table. These are the invocations of functions (including function pointers)
external to all read C sources. 

Although \code{gencot-externs} only processes complete function declarations, 
\code{items-used} also lists identifiers for incompletely declared functions and for variadic functions,
if they are invoked in the Cogent compilation unit. This is intended as an 
information for the developer who has to translate invocations of such functions manually. Additionally, these functions
may be needed by \code{gencot-exttypes} and \code{gencot-dvdtypes} to process their result types.

An identifier seen by Gencot in a function invocation may also be a macro call which shall be translated by Gencot. 
In this case a dummy function declaration must be manually provided for it as part of the Gencot macro call conversion
(see Section~\ref{design-preprocessor-macros}), so that the language-c parser can parse the invocations. 
Therefore \code{items-used} will detect the macro as a used external item.

There are cases where an external function is used without being seen by the call graph. This is the case when
the function is assigned to a function pointer or when the function invocation is created by a macro call and
is thus not visible for the call graph. For these cases the function item id must be provided manually in the argument file.

\subsubsection{Determining Used Variables}

Gencot determines usage of an external variable if it or a sub-item of it is invoked as a function, using the 
call graph. Invocations of sub-items which are the result of another function are currently not detected. 
Variables accessed in other ways (e.g., read access, assignment) must be added manually in the argument file. This
provides more control about the processed external variables for the developer.

\subsubsection{Collecting Used Types}

As described in Section~\ref{design-types-itemprops}, type items are all typedef names, tag names, generated names 
for tagless struct/unions, and some derived pointer types. Typedef names and tag names can be external, if they are 
declared in a system include file. Tagless struct/unions and derived types cannot be extern in this sense, because 
for them the declaration is identical with their single use. However, the following situation can lead to external 
used items of this kind: a typedef name is defined for them in a system include file. This typedef name is used 
indirectly by the Cogent compilation unit and is thus resolved. Then the result of resolving the name becomes the 
used external type item. 

Properties declared for a derived pointer type item are always applied to the individual items having that type. 
Thus it is always possible to declare the properties directly for the individual items and Gencot does not support 
external pointer type items for this reason. For a tagless struct/union the situation is different, it is translated
to a single defined type and declared properties must be used in this type definition, they cannot be replaced by
properties declared for the individual typed items. Therefore Gencot also supports tagless struct/unions as used
external items, identified by their item identifier using a generated name as described in Section~\ref{impl-itemprops-ids}.

A type item can be used by code in a translated C soure file or by a declaration of an external function or variable.
Therefore, \code{items-used} first determines the external invoked functions and variables as described above, including
the additional items in the argument file.

Type items are reduced by an analysis of type usage by reference. Every item can be
associated with the type items referenced in the types of all sub-items. This usage relation is transitive, because 
in a definition of a composite type or typedef name, other type items can be referenced. To determine the relevant 
type items defined in system include files, \code{items-used} starts with all initial items belonging
to the Cogent compilation unit, together with all external invoked functions and the processed external variables. 
It then determines all transitively used type items (which all must be defined in system include files).

To further reduce external items, external type name which are not directly used in the Cogent compilation unit are
resolved, i.e.~always replaced by their definition (which may again reference external type items).

For the resulting set of type items the item identifiers are added to the output list. 

The initial toplevel items are collected with the help of the callback handler during analysis, as described in 
Section~\ref{impl-ccode-read}. All toplevel items can be wrapped as a \code{DeclEvent}. The callback handler 
is automatically invoked for all toplevel items in the parsed
C source files, including local variables (which are not present anymore in the symbol table after the analysis phase).

Gencot uses the callback handler
\begin{verbatim}
  collectTypeCarriers :: DeclEvent -> Trav [DeclEvent] ()
\end{verbatim}
in module \code{Gencot.Util.Types}. It adds all \code{DeclEvent}s with relevant toplevel items to the list in the 
user state of the \code{Trav} monad. The handler is used for every \code{.c} file separately, the collected
items must be combined afterwards to get all items in the Cogent compilation unit. This is
done by first combining the symbol tables as described in Section~\ref{impl-ccode-package}, and then using the union of all 
items which are local, have internal linkage, or are still contained in the resulting combined table. 
This will avoid duplicate occurrences of items.

All parameter declarations are ignored by the callback handler, since for every parameter declaration there must be 
a \code{DeclEvent} for the containing function, which is processed by the handler and has the parameters as sub-items. 
Function and global variable declarations 
are also ignored, since they represent external functions and variables which are determined separately. Also,
a function or variable declared in one source file may be defined in another source file of the Cogent compilation unit and thus 
be not external. 

Type items defined in system include files are omitted, since they will be determined using the type usage relation. 
To determine whether
an item is defined in a system include file, the simple heuristics is used that the source file name is specified
as an absolute pathname in the \code{nodeinfo}. System includes are typically accessed using absolute pathnames of the 
form \code{/usr/include/...} (after being searched by cpp). If include paths are specified explicitly for Gencot, 
system include paths must be 
specified as absolute paths whereas include paths belonging to the <package> must be specified as relative paths
to make the heuristics work.

After the language-c analysis phase the declarations of all invoked external functions are determined 
as described above and added to the combined items determined by the callback handler. No duplicate items
will result here since the combined symbol table contains every external declaration only once.
External invoked composite type members are not included, because they are sub-items of the composite type. To invoke 
a composite type member an object must exist which is an item with the composite type, so the composite is always 
a used type item.

The resulting set of items is transitively completed by adding all type items used by referencing them,
as described above. This will add all required type items defined in system include files.
Duplicates could occur if a type item is referenced
by several different types, they must be detected and avoided. Since all toplevel items correspond to 
syntactic entities in a source file, type items can be identified and compared by their position and source file.

Finally, the type items are reduced to those defined in a system include file using the same
heuristics as above. Together with the item identifiers of the external invoked functions and variables their items
identifiers are written to the output.

\subsection{Main Translation to Cogent}
\label{impl-ccomps-main}

The main translation from C to Cogent is implemented by the filter \code{gencot-translate}. It translates \code{DeclEvent}s
of the following kinds:
\begin{itemize}
\item struct/union definitions
\item enum definitions with a tag
\item enum constant definitions
\item function definitions
\item object definitions
\item type definitions
\end{itemize}
The remaining global items are removed by the predicate passed to \code{Gencot.Input.getDeclEvents}: all declarations, 
and all tagless enum definitions. No Cogent type name is generated for a tagless enum definition,
references to it are always directly replaced by type \code{U32}.

The translation does not use the callback handler to collect information during analysis. It only uses the semantics map
created by the analysis and processes the \code{DeclEvent} sequence created by preprocessing as described in 
Section~\ref{impl-ccode-read}.

\subsubsection{Translating Toplevel Definitions}

The translation of the \code{DeclEvent} sequence is implemented by the monadic action
\begin{verbatim}
  transGlobals :: [DeclEvent] -> FTrav [GenToplv]
\end{verbatim}
in module \code{Gencot.Cogent.Translate}.
It performs the monadic traversal as described in Section~\ref{impl-ccode-trav} and returns the list of toplevel
Cogent definitions of type \code{GenToplv}. It is implemented by mapping the function \code{transGlobal} to the 
\code{DeclEvent} sequence.

A struct/union/enum definition corresponds to a full specifier, as described in Section~\ref{design-decls-tags}.
The language-c analysis already implements moving all nested full specifiers to separate global definitions and the
sorting step done by \code{Gencot.Input.getDeclEvents} creates the desired ordering. Therefore, basically the 
\code{DeclEvent}s in the list could be processed by \code{transGlobal} independently from each other.

However, this approach would create inappropriate origin markers which could result in duplicated conditional preprocessor
directives and comments. If a definition in lines $b1 < e1$ contains a nested struct definition in lines $b2 < e2$
independent translation would wrap the translated nested struct always in origin markers for $b2$ and $e2$. If $e1 = e2$
the corresponding origin marker would occur twice. A better approach is to use origin markers for $b1, e1$ to wrap the 
whole sequence consisting of the translated definition together with the translations of all nested structs. Then, the translated
nested struct would be followed by the two origin markers for $e2$ and $e1$ which can be reduced to a single marker if
$e2 = e1$.

Therefore function \code{transGlobal} is defined as
\begin{verbatim}
  transGlobal :: DeclEvent -> FTrav [GenToplv]
\end{verbatim}
It translates every definition together with all nested struct/union/enum definitions and returns the sequence of 
the corresponding Cogent toplevel definitions, wrapped by the origin markers as described.

Since the nested definitions still occur seperately in the list of \code{DeclEvent}s processed by \code{transGlobals}, their processing
must be suppressed. This is implemented by sorting the list according to the position of the first character in the source file
(which will put all nested definitions after their surrounding definitions), marking processed nested definitions in the 
monadic user state, and testing every struct/union/enum definition found by \code{transGlobal} in the \code{DeclEvent} list 
whether it is marked as already processed.

A struct/union definition is translated to a Cogent type definition where the type name is constructed as described 
in Section~\ref{design-names}. A struct is translated to a corresponding record type, a union is translated to an 
abstract type, as described in Section~\ref{design-types}.
In both cases the type name names the boxed type, i.e., it corresponds to the C type of a pointer to the struct/union.

An enum definition with a tag is translated to a Cogent type definition where the type name is constructed as described 
in Section~\ref{design-names}. The name is always defined for type \code{U32}, as described in Section~\ref{design-types}.

An enum constant definition is translated to a Cogent constant definition where the name is constructed as described 
in Section~\ref{design-names} and the type is always \code{U32}, as described in Section~\ref{design-types}.

A function definition is translated to a Cogent function definition, as described in Section~\ref{design-fundefs}.

A type definition is translated to a Cogent type definition as described in Section~\ref{design-decls-typedefs}.

\subsubsection{Translating Type References}

A type reference is translated by the function
\begin{verbatim}
  transType :: Bool -> ItemAssocType -> FTrav GenType
\end{verbatim}
It must be paired with the associated item identifier as an \code{ItemAssocType} as described in 
Section~\ref{impl-itemprops-types}. The identifier is used to retrieve the declared item properties required for
the translation.

The first parameter specifies whether typedef names should be resolved when translating the type. 
The reason why typedef names are resolved as part of the type translation function is that item properties may be 
associated with typedef names or their sub-items. If typedef names would
be resolved in a separate function the item identifier could not be associated anymore
afterwards. This would cause the declared item properties for typedef names to be ignored when translating the 
resolved type.

A type reference may be a direct type, a derived type, or a typedef name. For every typedef name a Cogent type
name is defined, as described in Sections~\ref{design-names} and~\ref{design-types-typedef}. An exception are 
externally defined typedef names not used directly in the Cogent compilation unit, they are resolved. A direct type is either
the type \code{void}, a primitive C type, which is mapped to the name of a primitive Cogent type, or it is a 
struct/union/enum type reference for which Gencot also introduces a Cogent type name or maps it to the 
primitive Cogent type \code{U32} (tagless enums). Hence, both direct types and typedef names can always be mapped
to Cogent type names, with the exception of type \code{void}, which is mapped to the Cogent unit type \code{()}.
For struct and union types the unbox operator must be applied to the Cogent type name.
If a typedef name references (directly or indirectly) a struct or union type, the corresponding Cogent
type name references the boxed type. Therefore, it must also be modified by applying the unbox operator. 

Primitive types or typedef names referencing a primitive type are semantically unboxed. However, if marked as unboxed, 
the Cogent prettyprint function will add an explicit unbox operator. For better readability Gencot specifies these types
as boxed, to suppress the redundant unbox operator.

A derived type is either a pointer type, an array type, or a function type. It is derived from a base type
which in case of a function type is the type of the function result. The base type may again be a derived
type, ultimately it is a direct type or a typedef name.

For a pointer type the translation depends on the base type. If it is a struct, union, or array type or a typedef
name referencing such a type, the pointer type is translated to the translation of the base type in its
boxed form. If it is a function type (possibly after resolving type names), the function type
is encoded as described in Section~\ref{design-types-pointer} using the function \code{encodeType}, then the function
pointer type is constructed from the encoding as described in Section~\ref{design-types-pointer}. The monadic operation
\begin{verbatim}
  encodeType :: Bool -> ItemAssocType -> FTrav String
\end{verbatim}
works similar to \code{transType} but returns the encoding as a string instead of the translated 
Cogent type. In particular, it optionally resolves typedef names and respects item properties.
If the base type is \code{void} the special type name \code{CVoidPtr} is used.

In all other cases, as described in Section~\ref{design-types}, 
the pointer type is translated to the parametric type \code{CPtr} with the translated base type as type argument.

For an array type, the translation is the parameterized type for an array according to the number of elements. 
The translated base type is used as type argument. In case that the base type is again an array type (multidimensional
array), an explicit unbox operator is applied to the type argument to differentiate the multidimensional array 
from an array of array pointers, as described in Section~\ref{design-types-array}.

A function type is always translated to the corresponding Cogent function type, where a tuple type is
used as parameter type if there is more than one parameter, and the unit type is used if there is
no parameter. Declared Read-Only and Add-Result properties are used to determine whether a parameter type
should be translated as readonly, or whether it should be returned as part of a result tuple. 

The translation functions do not respect the \code{const} qualifiers in C type specifications, they only use the 
Read-Only property to determine whether a type should be translated as readonly. The \code{const} qualifiers are 
used by \code{items-gen} to generate the default properties as described in Section~\ref{impl-ccomps-itemprops}. 

\subsubsection{Filter \code{gencot-translate}}

The filter \code{gencot-translate} is invoked as
\begin{verbatim}
  gencot-translate <source name> <item property file> <used external items file>
\end{verbatim}
where the arguments are the name of the original C source file, a file with the item property declarations (see 
Section~\ref{impl-itemprops}) and a file with the identifiers of the used external items as created 
by \code{items-used} (see Section~\ref{impl-ccomps-items}).

\subsection{External Functions and Variables}
\label{impl-ccomps-externs}

Used external functions and variables (``objects'') are translated so that they are known and usable
in the Cogent program.

\subsubsection{Translating External Functions and Variables}

Normally, a used external function is translated as an exit wrapper.
For the exit wrapper functions Gencot generates the Cogent abstract function definitions and the implementations
in antiquoted C. 
The information required for each of these functions is contained in the C function declaration.

A C function which is only declared may be incomplete, i.e., its parameters (number and types) are not known. 
We could translate such function declarations to Cogent abstract functions with Unit as argument type, however,
that would not be related to the invocations and thus be useless. Therefore Gencot does not generate exit 
wrappers for incompletely declared functions.

As described in Section~\ref{impl-ccomps-items} a used external function seen by Gencot may also be a macro call 
which shall be translated to Cogent. In this case a dummy function declaration must have been manually provided 
for it. By using an incomplete declaration the generation of an exit wrapper can be suppressed for macros 
which shall be translated to a macro in Cogent.

If an external function is accessed through a function pointer no exit wrapper is generated for it.
Function pointers are invoked as described in Section~\ref{design-operations-function}. Since in C all functions
which are sub-items of other items must be function pointers, exit wrappers are only generated for toplevel
items, sub-items are not considered here.

For a used external object (including invoked function pointers) Gencot generates a Cogent abstract function 
definition for an access function without providing an implementation in antiquoted C. Again, this is only 
done for toplevel items, sub-items are not considered.

\subsubsection{Processor \code{gencot-externs}}

The processor \code{gencot-externs} generates the Cogent abstract function definitions. It is invoked as
\begin{verbatim}
  gencot-externs <item properties file> <used external items file>
\end{verbatim}
where the arguments are a file with the item property declarations (see 
Section~\ref{impl-itemprops}) and a file with the identifiers of the used external items as created 
by \code{items-used} (see Section~\ref{impl-ccomps-items}).

The processor parses and analyses
all C source files specified in the input file name list, resulting in the list of corresponding symbol tables, as
described in Section~\ref{impl-ccode-package}. The tables are combined and from the resulting table all 
declarations of toplevel items are retrieved which are listed in the file of used items.

The processor translates these declarations using the monadic action \code{transGlobals} of
module \code{Gencot.Cogent.Translate}. It translates C function and variable declarations to abstract function 
definitions in Cogent. It uses the item properties to fine tune the translation.
The result is output using \code{prettyTopLevels} from module \code{Gencot.Cogent.Output}.

\subsubsection{Processor \code{gencot-externsac}}

The processor \code{gencot-externsac} generates the wrapper implementations in antiquoted C code.

\subsection{External Cogent Types}
\label{impl-ccomps-exttypes}

The processor \code{gencot-exttypes} generates all Cogent type definitions which origin from a C system include file.
It is invoked as
\begin{verbatim}
  gencot-exttypes <item properties file> <used external items file>
\end{verbatim}
where the arguments are a file with the item property declarations (see 
Section~\ref{impl-itemprops}) and a file with the identifiers of the used external items as created 
by \code{items-used} (see Section~\ref{impl-ccomps-itemprops}).

The task of \code{gencot-exttypes} is to translate all type item definitions listed in the 
file of used external items. It parses and analyses
all C source files specified in the input file name list and combines the resulting symbol tables as
described in Section~\ref{impl-ccode-package}. The type item (struct/union, tagged enum, and typedef name) definitions 
in the resulting table listed in the argument file are then translated.

\subsubsection{Translating Type Definitions}

For all external enum types, composite types and typedef names in the resulting set \code{gencot-exttypes} translates the
definition to Cogent as described in Sections~\ref{design-types}.
All typedef names not used directly are resolved in these definitions, as described in Section~\ref{impl-ccomps-items}.
The same monadic action \code{transGlobals} is used as for \code{gencot-translate}.

\subsection{Derived Types}
\label{impl-ccomps-dvdtypes}

The processor \code{gencot-dvdtypes} generates all Cogent type definitions required for the derived types
used in the C program. It is invoked as
\begin{verbatim}
  gencot-dvdtypes <item properties file> <used external items file>
\end{verbatim}
where the arguments are a file with the item property declarations (see 
Section~\ref{impl-itemprops}) and a file with the identifiers of the used external items as created 
by \code{items-used} (see Section~\ref{impl-ccomps-itemprops}).

A C derived type, is a pointer type, array type or function type. As described in 
Section~\ref{design-types}, Gencot usually maps these types to parameterized Gencot types. The generic types \code{CPtr},
\code{CFunPtr} and \code{CFunInc} used for pointer and function types are predefined by Gencot. However, function
pointer types use abstract types for encoding the base function type and the generic 
types of the form \code{CArr<size>} used for array types syntactically contain the array size, both
depend on the translated C program. For these types Cogent definitions must be provided.

Derived types are used in C in the form of type expressions, i.e., base types, result and parameter types are 
syntactically included in the type specification. With some exceptions, derived types may occur wherever a type
may be used. Therefore, to determine all used derived types, Gencot determines all item associated types as
described in Section~\ref{impl-itemprops-types}. These include all types used 
in translated C sources, in declarations of external used functions and variables and those defined in system
include files.

Together, \code{gencot-dvdtypes} processes
\textit{all} item associated types for all sub-item types which are a derived array or function pointer type.

\subsubsection{Generating Type Definitions}

For all derived array types two abstract generic type definitions must be generated
(see Section~\ref{design-types-array}). However, only one such pair may be generated for every array \code{<size>}, 
although array types with a specific size may be associated with several different items and element types.

For all derived function pointer types an abstract type definition or a type synonym for the fully resolved type 
must be generated for encoding the function type used as its base type (see Section~\ref{design-types-pointer}).
For fully resolved function types an additional type synonym definition must be generated for the translated function type.

Gencot first generates the translated Cogent type names for all derived array and function pointer types associated 
with an item. Then it generates the corresponding definitions for every type name
used in all these derived types. If a translated array type uses the generic name \code{CArrXX} no definition
is generated since this type name is predefined by Gencot.

Generating the type definitions for derived array and function pointer types is implemented by the monadic action
\begin{verbatim}
  genTypeDefs :: [DeclEvent] -> FTrav [GenToplv]
\end{verbatim}
in module \code{Gencot.Cogent.Translate}, where the list of \code{DeclEvent}s corresponds to the items
to be processed.

\subsubsection{Processor \code{gencot-dvdtypesah}}

\subsection{Declarations}
\label{impl-ccomps-decls}

The filter \code{gencot-deccomments} is used to provide the information about the positions of all declarations with
external linkage in
a translated file, as described in Section~\ref{impl-comments-decl}. This information is used to move declaration
comments to the corresponding definitions, as described in Section~\ref{design-comments-decl}.

Only global declarations are processed by this filter. Therefore the filter processes the list of \code{DeclEvents}
returned by \code{getDeclEvents} (see Section~\ref{impl-ccode-read}). The predicate for filtering the list
selects all declarations with external linkage (i.e. removes all object/function/enumeration/type definitions and 
all declarations with internal or no linkage). 
The main application case are functions declared as external, but moving the comments may also be useful for 
objects.

If a function or object with external linkage is declared and defined in the same file, the language-c analysis step
replaces the declaration by the corresponding definitions in the semantic map, hence it will not be found and processed
by \code{gencot-deccomments}. However, it is assumed that in this case the documentation is assocatied with the definition
and need not be moved from the declaration to the definition.

For processing the declarations we do not need a monad since every declaration can be processed on its own. This is implemented
by the function
\begin{verbatim}
  transDecl :: DeclEvent -> String
\end{verbatim}
in module \code{Gencot.Text.Decls}. It is mapped over the list of \code{DeclEvents} and the resulting string list
is output one string per line.

\subsection{Item Properties}
\label{impl-ccomps-itemprops}

To support an easy manual declaration of item properties Gencot generates default declarations from the C sources for all 
items with an identifier. The declarations are either empty or declare the properties Read-Only and/or Add-Result, if they
can be derived from the item's type. 

The property Heap-Use is not set in default declarations. It could be set if a C memory management function such as \code{malloc} 
is directly invoked by a function, however, the most relevant way to set the property is by transitive dependency among functions.
This is implemented by the parameter modification mechanism (see Section~\ref{design-parmod-heap}) and therefore omitted here.

\subsubsection{The filter \code{items-gen}}

The filter \code{items-gen} is used to generate default item property declarations from a single C source file (\code{.h} or \code{.c}).
It is invoked as:
\begin{verbatim}
  items-gen <source file name>
\end{verbatim}

The filter processes as individual items all \code{DeclEvent}s in the source file which are function
definitions or definitions for objects. The filter processes every definition of a composite type 
(with or without a tag) and every type name definition in the source file as collective item. (The filter does not
process any derived pointer types as collective items.) The processing is done by the monadic action
\begin{verbatim}
  transGlobals :: [DeclEvent] -> FTrav ItemProperties
\end{verbatim}
defined in module \code{Gencot.Items.Translate}.

For every item, if its declared type (in the case of a typedef name item its defining type) is
a derived function, array, or pointer type, its sub-items according to the 
type are processed recursively. For a composite type item its members are processed recursively as sub-items.

An item is processed as follows. If its declared or defined type is primitive or an enum or a function pointer no output 
is generated since properties are not 
supported or always ignored for it. Otherwise, if it is a parameter item or its declared type is not composite, a property
declaration is generated for it (parameters of composite type may be affected by the Add-Result property, items of function
type may be affected by the Heap-Use property, items of pointer or array type may be affected by the Read-Only property).
For non-parameter items of composite type no output is generated since properties are not 
supported or always ignored for them.

If the non-function-pointer type of an item is intrinsically readonly, the Read-Only property is declared for it. If an 
item has an intrinsically readonly array type and is not an element of another array or a member of a composite type (in both
cases it is translated with an unboxed type and the Read-Only property would be ignored), the Read-Only property
is declared for it. Otherwise, if it is a parameter and its type is linear (is a pointer or array or contains any),
the Add-Result property is declared for it. Otherwise the declaration is empty.

All generated declarations are written in textual form to the standard output.

Whether a type is intrinsically readonly depends on its \code{const} qualifiers. For a direct type the \code{const}
qualifier is ignored, since in Cogent values of unboxed and regular types are always immutable. For
a function type the qualifier is also ignored since function types are regular in Cogent. All other array types 
and all pointer types are translated to linear types which can be mutable in
Cogent. To be intrinsically immutable, the base types of these types and all transitively contained array and pointer 
types must be const qualified. The immutability is determined by function\code{isReadOnlyType}. It is implemented
by a monadic action since it must access the symbol table to resolve references to tagged C structs.

Default Add-Result properties are generated whenever the parameter type is linear. In cases where the parameter 
shall be discarded because it is deallocated in the function or it is already returned as the function's result
the default property must be removed manually or with the help of the parameter modification descriptions before
using the properties for translating the function.

\subsubsection{The processor \code{items-externs}}

The processor \code{items-externs} is used to generate the default property declarations for items intended
to be used by \code{gencot-externs} (see Section~\ref{impl-ccomps-externs}) and \code{gencot-exttypes} 
(see Section~\ref{impl-ccomps-exttypes}). It is invoked as
\begin{verbatim}
  items-externs <used external items file>
\end{verbatim}
where the argument is the list of external toplevel items used by the Cogent compilation unit, as it is created 
by \code{items-used}.

The processor reads the source files of the Cogent compilation unit as described in Section~\ref{impl-ccode-package}
and processes all external toplevel items specified in the list of used items in the same way as \code{items-gen}
to generate default property declarations for them on standard output. The same monadic action \code{transGlobals}
is used as by \code{items-gen}.

The type of a processed item may involve an externally defined type name which is not in the list of used external items.
This means that the type name is not used directly in the Cogent code and is resolved in the translation. In this case it is 
also resolved by \code{items-externs} so that collective sub-items of the type name become individual sub-items of 
the processed item, as described in Section~\ref{design-types-itemprops}.

If a processed external function or object belongs to the <package> but is outside the Cogent compilation unit, it may
have type subitems which are defined in an include file which is also used in the Cogent compilation unit. In this
case the subitems are not extern, but still output by \code{items-externs}. They must be removed in a postprocessing
step which recognizes them because they have no prefix in the list of used external items.

\subsubsection{The processor \code{items-extfuns}}

The processor \code{items-extfuns} is used to generate the list of identifiers of all used external items which 
have a derived function type as declared type. It is invoked as
\begin{verbatim}
  items-extfuns <used external items file>
\end{verbatim}
where the argument is the list of external toplevel items used by the Cogent compilation unit, as it is created 
by \code{items-used}.

The processor reads the source files of the Cogent compilation unit as described in Section~\ref{impl-ccode-package}
and processes all external toplevel items specified in the list of used items in the same way as \code{items-externs}.
Instead of generating default property declarations for them, it lists the identifiers of all function items on 
standard output. This list is intended for selecting parameter modification descriptions for these functions. It
is produced by the monadic action
\begin{verbatim}
  functionsInGlobals :: [DeclEvent] -> FTrav [String]
\end{verbatim}
defined in module \code{Gencot.Items.Translate}.

It is not possible to directly use the list of identifiers of the used external toplevel items for this purpose, since 
functions can be sub-items of toplevel items and the resolved external typedef names have to be taken into account.

The result must include all functions processed by \code{gencot-externs} and all function types and composite type members
processed by \code{gencot-exttypes}. 

Although \code{gencot-externs} only processes complete function declarations of non-variadic external functions, 
\code{items-extfuns} also lists identifiers for incompletely declared functions and for variadic functions.
This is intended as an information for the developer who has to translate invocations of such functions manually.

For declared functions and for all kinds of function pointers the function type can be specified in C using a typedef name.
Such function items are not listed, instead, the typedef name is listed as the collective item for which the parameter
modification description is required. If, however, the external typedef name is not used diectly by the Cogent compilation
unit, it is resolved, and the item for which the typedef name has been declared is listed, as described in 
Section~\ref{design-parmod-entities}.

Manually specified additional external functions are also listed, since they have been added by \code{items-used}
to the \code{<used external items file>}.

\subsection{Parameter Modification}
\label{impl-ccomps-parmod}

The goal of working with the parameter modification descriptions (see Section~\ref{design-parmod}) is to analyse 
transitive function invocation chains which only stop at functions external to the C <package>, for which no sources
are available. Therefore the approach used for item property declarations in Section~\ref{impl-ccomps-itemprops}
cannot be used here, since it treats all items as external which do not belong to the Cogent compilation unit.

Instead, we use a single filter \code{parmod-gen} which is always applied to a single C source file in the 
<package>. It may be run in two modes: in normal mode it processes all functions \textit{defined} in the source
file and outputs descriptions for them, in ``closing mode'' it processes all functions only \textit{declared} in 
the source file or in a file included by it and outputs a description template. This covers all functions which 
may be invoked by the functions defined in the source, including functions external to the <package>. 

The invocation chains can then be followed using the descriptions generated in normal mode, until a function is invoked
which is external to the <package>. Only for these functions the templates generated in closing mode are used
to ``close'' the invocation chains, all other templates (in particular, for functions defined in the <package>)
are ignored.

The filter still needs the information about the used items outside the Cogent compilation unit to correctly handle
typedef names which are used only indirectly and are resolved during the translation to Cogent. If the type of an
invoked function is specified by a type name, the invocation either refers to the type name or to individual function items,
depending on whether the type name is resolved, as described in Section~\ref{design-parmod}.

\subsubsection{\code{parmod-gen}}

The filter \code{parmod-gen} is used to generate the Json parameter modification description from a C source file.
It may be invoked in two forms:
\begin{verbatim}
  parmod-gen <source file name> <used external items file>
  parmod-gen <source file name> <used external items file> close
\end{verbatim}
The second form runs the filter in ``closing mode''.

In normal mode the filter processes all \code{DeclEvent}s in the source file which are function
definitions or definitions for objects with a type syntactically including a function type (called a ``SIFT'' 
type in the following). Every such definition is translated to an
entry in the parameter modification description. A function definition is translated to the sequence of its
own description entry and the entries for all invoked local items with a SIFT type and all parameters with 
a SIFT type.

The filter processes every definition of a composite type in the source file and translates all
its members with a SIFT type to the corresponding
description template. The filter processes every type name definition in the source file where the defining type
is a SIFT type, and translates it to the corresponding description template.

The descriptions of functions, their function parameters, composite type members, and typedef names are 
intended to be converted to item property declarations for being used by \code{gencot-translate}
when it translates the function and type definitions. The descriptions of invoked local items 
are intended for evaluating dependencies as described in Section~\ref{impl-parmod}.

In closing mode the filter processes all \code{DeclEvent}s in the source file and in all included files which
are declarations for functions or items with a SIFT type. Every declaration is translated to an entry in the parameter
modification template. The filter also processes all composite type definitions and type name definitions which
are specified in system include files in the same way as described above. 
These templates are only intended for ``closing'' the dependencies for the evaluation.

Here, resolved external type names are taken into account, when the type of a declaration is tested for 
being a SIFT type: all such type names are resolved before testing whether a derived function type directly
occurs in the type.

After analysing the C code as described in Section~\ref{impl-ccode} the call graph is generated as described
in Section~\ref{impl-ccode-callgraph}. Then another traversal is performed using the \code{CTrav} monad and
\code{runWithCallGraph} with action
\begin{verbatim}
  transGlobals :: [DeclEvent] -> CTrav Parmods
\end{verbatim}
defined in module \code{Gencot.Json.Translate}. The resulting list of JSON objects is output as described 
in Section~\ref{impl-parmod-json}.

