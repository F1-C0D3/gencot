The goal of this step is to translate a single C source file which is part of the translation set to Cogent.
This is done by first using Gencot to translate the file to Cogent with embedded partially translated C code,
and then manually translating the embedded C code.

The translated file is either a \code{.c} file which can be seperately compiled by the C compiler as a compilation unit,
or it is a \code{.h} file which is a part of one or more compilation units by being included by other files. In both cases
the file can include \code{.h} files, both in the package and standard C include files such as \code{stdio.h}.

\subsection{Automatic Translation by Gencot}
\label{app-trans-auto}

To be translated by Gencot the C source file must first be prepared for being read by Gencot as described in
Section~\ref{app-prep}. Then the parameter modification descriptions for all functions and function types defined 
in the source file must be created and evaluated as described in Section~\ref{app-parmod-defined}. 

A \code{.c} file is translated using the command
\begin{verbatim}
  gencot [options] cfile file.c [<parmod>]
\end{verbatim}
where \code{file.c} is the file to be translated and \code{<parmod>} is the file containing the parameter modification 
descriptions. If it is not provided, Gencot assumes for all functions and function types, that linear parameters 
may be modified. The result of the translation is stored as \code{file.cogent} in the current directory.

An \code{.h} file is translated using the command
\begin{verbatim}
  gencot [options] hfile file.h [<parmod>]
\end{verbatim}
where \code{file.h} is the file to be translated and \code{<parmod>} is as above. The result of the translation is 
stored as \code{file-incl.cogent} in the current directory.

Special support is provided for translating configuration files. A configuration file is a \code{.h} file mainly
containing preprocessor directives for defining flags and macros, some of which are deactivated by being ``commented
out'', i.e., they are preceded by \code{//}. If such a file is translated using the command
\begin{verbatim}
  gencot [options] config file.h [<parmod>]
\end{verbatim}
it is translated like a normal \code{.h} file, but before, all \code{//} comment starts at line beginnings are 
removed, and afterwards the corresponding Cogent comment starts \code{--} are re-inserted before the definitions.

\subsection{Manual Translation of C Function Bodies}
\label{app-trans-manbody}

The manual part of the translation is mainly required for the bodies of all C functions defined in the C source file.
A \code{.h} file normally does not contain function or object definitions, then it may be the case that no manual actions 
are necessary. But some \code{.h} files define functions, typically as \code{static inline}, then also their bodies
must be translated manually.

The manual translation is done by modifying the \code{.cogent} file generated by the automatic translation in an 
editor. As described in Section~\ref{design-fundefs-body}, the result of automatically translating a function
definition has the form
The generated Cogent function definition has the form
\begin{verbatim}
  <name> :: (<ptype1>, ..., <ptypen>) -> <restype>
  <name> (<pname1>, ..., <pnamen>) = <dummy result>
  {- <compound statement> -}
\end{verbatim}
where the \code{<compound statement>} is plain C code with global names mapped to Cogent. The task of the manual
translation is to replace the \code{<dummy result>} by a Cogent expression equivalent to the \code{<compound statement>}.

In the following sections we provide some patterns how to translate typical C constructs occurring in a
\code{<compound statement>}.

\subsection{Function Pointer Invocation}
\label{app-trans-funpointer}

In C a function pointer may be \code{NULL}, therefore it is typically tested for being valid before the
referenced function is invoked, such as in 
\begin{verbatim}
  if( fptr == NULL ) ...
  else fptr( params );
\end{verbatim}
We assume that fptr shall have a type which is binary compatible to the function pointer type in C.
This prevents to use a Cogent type \code{Option a} as the natural equivalent of a value that may be undefined.
\code{Option a} is a Cogent variant type and is not binary equivalent to the C function pointer type.

If \code{fptr} is a member of a C struct, it would be possible to use a Cogent record with a taken field,
if the function pointer is undefined. Then it would be clear from the record type whether the function pointer
is valid and can be invoked. However, this would require two implementations for all functions with such a records 
as parameter, which is usually infeasible.

The simplest solution is to assume that function pointers are always defined. Instead of using the value 
\code{NULL}, they must then be set to point to a default function. Then no test is required, the function
can simply be invoked in Cogent.

Note that to be binary compatible the Cogent type of \code{fptr} is an abstract type of the form \code{\#F\_...}.
To invoke the referenced function the translation function \code{invk\_F\_...} must be used (see 
Section~\ref{design-types-function}). 

For example, if the function pointer is declared in C as 
\begin{verbatim}
  int (*fptr)(int p1, const char *p2);
\end{verbatim}
the corresponding invocation in Cogent would be
\begin{verbatim}
  invk_F_'U32'RP_U8'_U32 (fptr,arg1,arg2)
\end{verbatim}
with result type \code{U32}.

\subsection{The Null Pointer}
\label{app-trans-null}

The type safety of Cogent relies on the fact that the pointers representing values of linear types are never \code{NULL}.
If null pointers are used in the C source, there is no immediate translation. The way how to translate C code which uses 
null ponters in a binary compatible way depends on the way how the null pointers are used.

A null pointer can be used as struct member \code{f} of linear Type \code{T} in an ``uninitialized state''. 
It is set when the struct is created and later
replaced by a valid pointer. It remains valid until the struct is disposed. If additionally the struct is used only in places
during the ``uninitialized state'' which are different from those afterwards, the ``uninitialized state'' can be represented
by using the record type with the field \code{f} taken. Initializing the pointer changes the type to the normal record
type.

If the field \code{f} is initialized ``on demand'', i.e., not at a statical point in the program, this solution is not possible.
The main problem here is that it must be possible to determine at runtime whether \code{f} is initialized or not. So simply
allocating a ``dummy'' to get a valid pointer is not sufficient, it must also be possible to recognize the dummy pointer.

One possibility for this is if the data structure referenced by the pointer has a field value which never occurs for a valid
pointer. Then it can be used to mark the pointer as dummy.

Another possibility is to use a single dummy pointer for all values of a specific linear type which can be null and store it 
in a seperate place for comparing it. However, this cannot be done in Cogent since the dummy pointer would be a shared linear 
value. Even if implemened in antiquoted C through abstract functions, to prove memory safety every access to such a value must 
be guarded with a test for the dummy pointer. Thus it is easier to actually use the null pointer instead of the dummy pointer,
in combination with a guard testing for the null pointer, resulting in a solution which is binary compatible with the C 
implementation.

A straightforward approach uses abstract functions
\begin{verbatim}
  null_T: () -> T
  ronull_T: () -> T!
  isNull_T: T! -> Bool
\end{verbatim}
to work with the null pointer. To dispose it the function \code{dispose\_T} must also check for the null pointer and ignore
invocations for it. The existence of the function \code{null\_T} makes it necessary to guard all accesses to values of type
\code{T} and \code{T!} with the help of \code{isNull\_T}. The function \code{ronull\_T} is required to initialize record fields 
of readonly type. This cannot be done by applying the bang operator to the result of \code{null\_T} since then the value
cannot escape the banged context. The existence of the function \code{ronull\_T} makes it necessary to guard
all accesses to values of type \code{T!}, the values of type \code{T} need not be guarded since a readonly value can never be 
made modifyable again. Therefore Gencot does not automatically define the functions for all 
linear types \code{T}.

A safer approach replaces type \code{T} by an abstract type and uses type \code{T} only in places where a value has been checked
for not being null. The abstract type must be specific for \code{T} and it must be complemented with abstract functions for
generating and testing the null pointer. Together the following abstract data type should be used:
\begin{verbatim}
  type MayNull a 
  null: all(a). () -> MayNull a
  roNull: all(a). () -> (MayNull a)!
  mayNull: all(a). a -> MayNull a
  isNull: all(a). (MayNull a)! -> Bool
  notNull: all(a). MayNull a -> Option a
\end{verbatim}
The function \code{notNull} returns \code{None} if the argument is null and \code{Some x} if the argument \code{x} is not null.
Since it is the only function which makes the value available as type \code{a} it is guaranteed that all accesses to the value
are guarded.

It may seem to be an alternative approach to avoid arbitrary access to the null pointer by using it always bound to the struct field \code{f}
with an abstract function of the following form instead:
\begin{verbatim}
  isNull_f: R -> Bool
\end{verbatim}
where \code{R} is the type of the struct containing field \code{f}. The null value would be inserted in the initialization 
function which transforms the result of \code{create\_R} from type \code{R take (..)} to type \code{R}. However, the null 
pointer can still be accessed by taking it from the record, so this is no improvement.

A null pointer can also be used as an ``error'' or ``escape'' value for function parameters or results. If the function is
invoked from Cogent to C code or vice versa, a binary compatible solution is required. Again, the type \code{MayNull} can
be used here.

\subsection{The Address Operator \code{\&}}
\label{app-trans-addrop}

The address operator \code{\&} is used in C to determine a pointer to data which is not yet accessed through a 
pointer. The main use cases are
\begin{itemize}
\item determine a pointer for a local or global variable as in the example
\begin{verbatim}
  int i = 5;
  int *ptr = &i;
\end{verbatim}

\item determine a pointer for a member in a struct as in the example
\begin{verbatim}
  struct ii { int i1; int i2; } s = {17,4};
  int *ptr = &(s.i2);
\end{verbatim}

\item determine a pointer for an array elemnt as in the example
\begin{verbatim}
  int arr[20];
  int *ptr = &(arr[5]);
\end{verbatim}

determine a pointer to a function as in the example
\begin{verbatim}
  int f(int p) { return p+1; }
  ...
  int *ptr = &f;
\end{verbatim}
\end{itemize}

In all these cases the pointer is typically used as reference to pass it to other functions or store it
in a data structure.

The binary compatible Cogent equivalent of the pointer is a value of a linear type. However, there is
no Cogent functionality to create such values. Hence it must be implemented by an abstract function.

\subsubsection{Address of Variable}

In the first use case there are several problems with this approach. First, there is no true equivalent
for C variables in Cogent. Second, it is not possible to pass the variable to the implementation of the
abstract function, without first determining its address using the address operator. Third, if the address
operator is applied to the variable in the implementation of the abstract function, the Isabelle c-parser
will not be able to process the abstract function, since it only supports the address operator when 
the result is a heap address.

All these problems can be solved by allocating the variable on the heap instead. Then the variable definition
must be replaced by a call to the (abstract) creation function for the corresponding linear type 
(see Section~\ref{design-types-pointer}) and 
at the end of its scope a call to the (abstract) dispose function must be added. Then the address
operator need not be translated, since the creation function already returns the linear value which can be 
used for the same purposes. The resulting Cogent code would be
\begin{verbatim}
  let ptr = create_P_U32 5
  in dispose_P_U32(...ptr...)
\end{verbatim}
where the argument of \code{dispose\_P\_U32} is an expression which uses and returns the \code{ptr} in the 
usual way for a value of linear type.

\subsubsection{Address of Struct Member}

The second use case cannot be translated in this way, since the referenced data is a part of a larger structure.
If it is separated from the structure and allocated on the heap, the structure is not binary compatible any more.

If the overall structure is not allocated on the heap, the same three problems apply as in the first use case.
This can be solved in the same way, by moving the overall structure to the heap. Then it can be represented
by the linear Cogent type
\begin{verbatim}
  type Struct_Cogent_ii = { i1: U32, i2: U32 }
\end{verbatim}

If the overall structure in Cogent is readonly an abstract function of the form
\begin{verbatim}
  access_i2 : Struct_Cogent_ii! -> P_U32!
\end{verbatim}
can be used to access the Cogent field through a pointer. It returns the field as readonly, thus it is safe 
since neither the field nor the structure can be modified.

If the overall structure is modifyable, determining a pointer to the field would introduce sharing for the
field, since it can be modified through the pointer or by modifying the structure. There are several possible
approaches in this case.

A straighforward approach uses two abstract functions
\begin{verbatim}
  take_i2 : Struct_Cogent_ii -> (P_U32, Struct_Cogent_ii take i2)
  put_i2 : (P_U32, Struct_Cogent_ii take i2) -> Struct_Cogent_ii
\end{verbatim}
The implementation of \code{take\_i2} allocates a new copy of field \code{i2} on the heap
and return this heap pointer as first result component. The implementation of \code{put\_i2} copies the 
value back from the heap and frees the heap entry. Then no sharing can occur and the program has the 
same type safety properties as a usual Cogent program. However, the copying makes it less efficient.

An alternative implementation of \code{take\_i2} would apply the address operator to the field \code{i2} of 
its argument and return it together with the argument. Then \code{put\_i2} would do nothing and simply 
return the record. Since the record returned by \code{take\_i2} has field \code{i2} taken, it
cannot be accessed as long as the type has not been changed to the full record type again, which should be 
done by \code{put\_i2}, discarding the pointer. However, it is possible to apply any other explicit \code{put}
operation which writes the field \code{i2} while the pointer still exists, causing the shared content to
be overwritten. To prevent this it must be proven for the Cogent program that no \code{put} operation for field 
\code{i2} is applied to the result of \code{take\_i2} until it is restored by \code{put\_i2}. This implies that
for proving the type safety properties an arbitrary complex part of the Cogent program must be taken into
account.

A better approach is to combine the pseudo take an put operations in a single abstract function. It takes
as parameter a function for working with the field, accessing it through a pointer. The working function
may need additional information which must be passed to it. To support arbitrary types of additional information
the main function can be defined as polymorphic. Then it has the form
\begin{verbatim}
  modify_i2 : all a:<DS. (Struct_Cogent_ii,
    (P_U32,(Struct_Cogent_ii take i2)!,a)->P_U32, a)
    -> Struct_Cogent_ii
\end{verbatim}
Here the type parameter \code{a} is restricted to be regular or readonly, so it can be discarded by \code{modify\_i2}.
The working function takes as parameters the pointer to the field, the remaining structure, and the additional information
of type \code{a}. The remaining structure is provided since often its content is also required for working on 
field \code{i2}. It is passed with field \code{i2} taken, so no sharing occurs in the working function. Additionally,
it is passed as readonly, so no other value can be put into field \code{i2} in the working function. The working
function returns the pointer to the modified field, thus it does not discard it and can be fully implemented in Cogent.

If the record field is an unboxed record with type \code{\#R}, the type of the pointer to the field has the boxed record
type \code{R} in all cases above. If the record field is an array of type \code{\#UA'n'\_El} the pointer to the field
has the corresponding array type \code{A'n'\_El} (see Section~\ref{design-types-array}.

There could be more complex cases of working with a structure through pointers to fields. The working function could
take an additional argument where it returns information, then an additional type variable \code{b} would be required
which is escapable. The working function could modify several record fields at the same time, then for every such field
a pointer is passed to it. This complexity is the reason why Gencot does not generate according definitions automatically.

\subsubsection{Address of Array Element}

The third use case is similar to the second. It often occurs if the array itself is represented by a pointer to its first
element (see Section~\ref{app-trans-arrpoint}). This case can simply be replaced by using the element index instead of a 
pointer to the element. The array index is nonlinear and thus easier to work with. However, this solution is not binary
compatible, if the element pointer is also accessed outside the Cogent compilation unit.

A binary compatible solution can be achieved in a similar way as for struct members. The first prerequisite for it is
to allocate the array on the heap.

If the array in Cogent has the readonly type \code{Arr!} with element type \code{El} an abstract function of the form
\begin{verbatim}
  access_Arr : (Arr!, UNN) -> Option P_El!
\end{verbatim}
can be used to access the element with the second argument as index.  If the specified index is not in the range of the array the
function returns None. Otherwise it returns a readonly pointer to the element. This is safe 
since neither the element nor the array can be modified. Note the similarity to the \code{get\_} functions defined in
Sections~\ref{design-types-array} and~\ref{app-trans-arrpoint} which return the element itself instead of a pointer.

If the array is not readonly an element can be modified in-place through a pointer by a function of the form
\begin{verbatim}
  modify_Arr : all a:<DS. (Arr, UNN, (P_El,a)->P_El, a) -> Arr
\end{verbatim}
As for the struct member the working function takes an additional information of nonlinear type as argument, which can be
used as input for the modification. Other than for the struct member it does not get the remaining array as argument,
since the type of an array with a specific element ``taken'' cannot be expressed in Cogent. Note that it is not possible
to pass the array or parts of it as additional information in the parameter of type \code{a}, since that would always by
a second use of the array of linear type.

\subsubsection{Address of Function}

The last use case is translated in a specific way for function pointers, using the translation function
\code{to\_F\_...} (see Section~\ref{design-types-function}), which is generated by Gencot for all function
pointer types. The resulting Cogent code has the form
\begin{verbatim}
  Cogent_f : U32 -> _U32
  Cogent_f p = p+1
  ...
  let ptr = to_F_'U32'_U32 Cogent_f
  in ...
\end{verbatim}
In this case \code{ptr} has the nonlinear type \code{\#F\_'U32'\_U32} in Cogent and may freely be copied and
discarded in its scope.

\subsection{Using Pointers for Array Access}
\label{app-trans-arrpoint}

A common pattern in C programs is to explicitly use a pointer type instead of an array type for referencing an array,
in particular if the array is allocated on the heap. This is typically done if the number of elements in the
array is not statically known at compile time. The C concept of variable length array types can sometimes be
used for a similar purpose, but is restricted to function parameters and local variables and cannot be used for
structure members.

In C the array subscription operator can be applied to terms of pointer type. The semantics is to access an element 
in memory at the specified offset after the element referenced by the pointer. This makes it possible to use 
a pointer as struct member which references an array as in
\begin{verbatim}
  struct ip {... int *p, ...} s;
\end{verbatim}
and access the array elements using the subscription operator as in \code{s.p[i]}.

Gencot translates the struct type to a record type of the form
\begin{verbatim}
  type Struct_Cogent_ip = {... p: P_U32, ...}
\end{verbatim}
and does not generate abstract functions which allow to treat \code{p} as an array, this must be done manually.

The main problem here is the unknown array size. In the C program, however, for working with the array it must be
possible to determine the array size in some way at runtime. Here we distinguish two approaches how this is done.

In the first case the array size can always be determined from the array content. Then the pointer to the first 
element is always sufficient for working with the array. The two typical patterns of this kind either use a 
stop element to mark the array end, such as the zero character ending C strings, or store the array size in a
specific element or elements, such as in a network package represented as a byte array.

Working with the array is supported by manually defining and implementing an abstract data type for the array as follows.
Let \code{tt} be a unique name for the specific kind of array (how its size is determined) and let \code{El} be the
name of the array element type. We use \code{CArray\_tt\_El} as type name for the array, thus the 
type of \code{p} must be manually changed as follows:
\begin{verbatim}
  type Struct_Cogent_ip = {... p: CArray_tt_El, ...}
\end{verbatim}

Then the abstract functions for the array type are defined in the same way as for the mapped array types as described in
Section~\ref{design-types-array}. The functions for creating and disposing arrays are:
\begin{verbatim}
  create_CArray_tt_El : UNN -> TCArray_tt_El
  dispose_CArray_tt_El : TCArray_tt_El -> ()
\end{verbatim}
where the \code{create}-function takes the actual array size (number of elements) as argument. The type \code{UNN} must be
chosen by the developer so that it can represent all sizes which are used for the array. It is also used for the index
values below. The type 
\code{TCArray\_tt\_El} is used for the uninitialized array, corresponding abstract functions for initializing
and freeing the array elements must be provided.

The implementation in antiquoted C has the following form:
\begin{verbatim}
  typedef el *CArray_tt_El, *TCArray_tt_El;
  
  $ty:TCArray_tt_El $id:create_CArray_tt_El($ty:U32 size) { 
    return calloc(size,sizeof(el));
  }
  $ty(()) $id:dispose_CArray_tt_El($ty:TCArray_tt_El arr) {
    free(arr); return $exp(());
  }
  ...
\end{verbatim}

The element access functions are defined in the same way as for array types (see Section~\ref{design-types-array}. 
In the case of a non-linear element type they are:
\begin{verbatim}
  get_CArray_tt_El : (CArray_tt_El!,UNN) -> Option El
  put_CArray_tt_El : (CArray_tt_El,UNN,El) -> CArray_tt_El
\end{verbatim}
and for a linear element type:
\begin{verbatim}
  get_CArray_tt_El : (CArray_tt_El!,UNN) -> Option El!
  replacein_CArray_tt_El : 
        (CArray_tt_El,UNN,El) -> (CArray_tt_El,El)
\end{verbatim}
Functions for accessing the element through a pointer (see Section~\ref{app-trans-addrop}) are in both cases:
\begin{verbatim}
  access_CArray_tt_El : (CArray_tt_El!,UNN) -> Option P_El!
  modify_CArray_tt_El : all a:<DS. 
        (CArray_tt_El,UNN,(P_El,a)->P_El, a) -> CArray_tt_El
\end{verbatim}

In the second case the array size is determined by additional information seperate from the pointer to the array.
Either the size is specified as an integer value as in 
\begin{verbatim}
  struct ip {... int *p, int psize; ...} s;
\end{verbatim}
or it is specified by a second pointer, e.g., pointing to the last element as in
\begin{verbatim}
  struct ip {... int *p, int *pend; ...} s;
\end{verbatim}
In general there may be additional information, such as pointers into the array which are used to reference
``current'' positions in the array. We assume that all this information is provided by a sequence of members
in the surrounding struct:
\begin{verbatim}
  struct ip {...; t1 m1;...tn mn; ...} s;
\end{verbatim}
When working with the array all additional information is required, therefore it must be included in the abstract
type. This is achieved by replacing the sequence of variables containing information about the array by a single
field of the array type in Cogent:
\begin{verbatim}
  type Struct_Cogent_ip = {... a: #SArray_tt_El, ...}
\end{verbatim}
with the array type being defined in C as
\begin{verbatim}
  typedef struct { t1 m1;...tn mn; } SArray_tt_El;
\end{verbatim}
This makes the Cogent type \code{Struct\_Cogent\_ip} binary compatible with the C type \code{struct ip} and it allows
to represent several groups of related members in the struct by a common abstract type. Of course this approach is 
only possible if the members are contiguous in the struct.

To access the group in the struct the abstract function
\begin{verbatim}
  modify_a: all a:<DS. (Struct_Cogent_ip,
    (SArray_tt_El, (Struct_Cogent_ip take a)!,a)->SArray_tt_El,a)
    -> Struct_Cogent_ip
\end{verbatim}
is used in the same way as described in Section~\ref{app-trans-addrop}.

The functions for working with the array now look different from those above, since type \code{SArray\_tt\_El}
does not correspond to a pointer to the array elements, but to a pointer to the substructure with members describing
the array. The specific form and functionality of these functions depend on the actual members and their use.

\subsection{Initializing Values of Linear Type}
\label{app-trans-init}

As described in Section~\ref{design-types-struct} the function \code{create\_T} returns a record with all fields taken.
Before it can be used it must be initialized by putting values for all fields. We assume here that this is done by a 
function of the form
\begin{verbatim}
  init_T: T take (..) -> T
\end{verbatim}
which puts simple fixed values into the fields and does not require any additional information.
Similarly, as described in Section~\ref{design-types-array} the function \code{create\_A'<size>'\_El} returns an 
unitialized array of type \code{TA'<size>'\_El} and we assume an initialization function of the form
\begin{verbatim}
  init_A'<size>'_El: TA'<size>'_El -> A'<size>'_El
\end{verbatim}

Putting values into fields of primitive type is straightforward. For fields of linear type \code{T} a value can be created 
using the function \code{create\_T} or \code{null[T]} (see Section~\ref{app-trans-null}) and put into the field using the
Cogent put operation. Not so clear is how to initialize fields of unboxed types.

A field \code{f} with an unboxed record type \code{\#S} corresponds to an embedded struct in C. The space for this struct is allocated together
with the space for the surrounding struct by function \code{create\_T}. The initialization should be done using the 
function \code{init\_S} which takes as input a value of type \code{S take (..)}. 

The most natural way of initializing an embedded struct would be in-place using a pointer to the embedded struct as described
in Section~\ref{app-trans-addrop}. But the function \code{modify\_f} described there takes as argument a record of type \code{T}
where no field is taken, so it cannot be used to put the taken field \code{f} into the record. Seperate \code{modify}-functions
are required for the record with taken fields. If the record contains several embedded structs every \code{modify}-function
puts one field and the result type has one field less taken. Thus, defining such \code{modify}-functions imposes an order
in which the embedded structs must be initialized and whether they are initialized before or after the other fields. A corresponding
\code{modify}-function for field \code{f} which must be initialized before field \code{g} but after all other fields would be
\begin{verbatim}
  put_f : (S take (..)->S, T take (f,g)) -> T take g
\end{verbatim}
It is defined in a way that it can be invoked with function \code{init\_S} as its first argument. This implies that other than
\code{modify\_f} the modification function neither takes the remaining record as argument nor additional information.
The implementation in antiquoted C would simply apply the first argument to a pointer to member \code{f} which is retrieved
using the address operator \code{\&}.

A more flexible way would be to use the Cogent put operation. However, for field \code{f} it needs a value of type 
\code{\#S} which is not produced by \code{init\_S}. To bridge this gap we can use an abstract function
\begin{verbatim}
  deref_S : S -> #S
\end{verbatim}
which dereferences the argument pointer, and returns a copy of its content. Additionally it frees the pointer so that the
linear input value is safely disposed. (Note that the argument cannot be readonly to avoid freeing the pointer, since then
the result must also be readonly if it contains linear values.) Then the Cogent code to initialize the embedded struct 
\code{f} in a record \code{t} would be
\begin{verbatim}
  t { f = deref_S init_S create_S }
\end{verbatim}
It is not as efficient as in-place initialization, since it allocates a struct of type \code{S} on the heap, initializes it,
copies it to the embedded struct \code{f} and deallocates it.

Since both ways may be useful in certain contexts Gencot does not generate one or both of them, they must be provided manually.

Another approach could be that the function \code{create\_T} returns a value where only the fields of primitive and linear type
are taken and the embedded structs are present, but again with all primitive and linear fields taken. Then the function \code{init\_S}
could be directly applied to a pointer to field \code{f}. However, it is still necessary to retrieve the pointer to \code{f}
with the help of an abstract function which now has to respect the fact that other embedded struct fields have types with
some fields taken. So the same number of additional abstract functions is needed as in the approach above and their argument
types are of similar complexity.

Fields of an unboxed abstract type are created by Gencot only in the case of arrays and function pointers (see 
Section~\ref{design-types-array} and~\ref{design-types-function}). Initializing an embedded array field \code{f} of type 
\code{\#UA'<size>'\_El} can be done in-place or separate like an embedded struct field. In the first case an abstract
function of the form 
\begin{verbatim}
  put_f : (TA'<size>'_El->A'<size>'_El, T take (f,g)) -> T take g
\end{verbatim}
is required which can be invoked with function \code{init\_A'<size>'\_El} as its second argument. In the second case an
abstract function of the form
\begin{verbatim}
  deref_A'<size>'_El : A'<size>'_El -> #UA'<size>'_El
\end{verbatim}
is required which copies the array content and frees the array on the heap.

Initializing an array field \code{f} of a function pointer type \code{\#F\_...} can always be done using the Cogent put operation.
The value to be put must be constructed using the function \code{to\_F\_...} (see Section~\ref{design-types-function}). To
avoid null pointers to functions, as described in Section~\ref{app-trans-funpointer}, a dummy function should be defined in
Cogent and passed to the \code{to\_F\_...} function.
