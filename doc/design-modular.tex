\subsection{Modularization and Interfacing to C Parts}
\label{design-modular}

Every C compilation unit produces
a set of global variables and a set of defined functions. Data of the same type may be used in
different compilation units, e.g. by passing it as parameter to an invoked function. In this case type compatibility in C is
only guaranteed by including the \code{.h} file with the type definition in both compilation units. In the compiled
units no type information is present any more. 

This organisation makes it possible to use different \code{.h} files in different compilation units. Even the type definitions
in the included files may be different, as long as they are binary compatible, i.e., have the same memory layout.

We exploit this organisation for an incremental translation from C to Cogent as follows. At every stage we replace some 
C compilation units by Cogent sources. All C data types used both in C units and in Cogent units are mapped to binary compatible
Cogent types. Compiling the Cogent sources produces again C code which together with the remaining C units are linked to
the target program. The C code resulting from Cogent compilation is completely separated from the code of the remaining C units,
no common include files are used.

All interfacing between C compilation units is done by name. All names of C objects with external linkage can be referred
from other compilation units. This is possible for functions and for global variables. Interfacing from and to Cogent works
in the same way. 

\subsubsection{Interfacing to Functions}

Cogent functions always take a single parameter, the same is true for the C functions generated by the Cogent compiler. Hence
for interfacing from or to an arbitrary C function, wrapper functions are needed which convert between arbitrary many parameters
and a single structured parameter. These wrapper functions are implemented in C. 

The ``entry wrapper'' for invoking a Cogent function 
from C has the same name as the original C function, so it can be invoked transparently. Thus the Cogent implementation of
the function must have a different name so that it does not conflict with the name of the wrapper. This is guaranteed by the 
Gencot renaming scheme as described in Section~\ref{design-names}.

The Cogent implementation of a C function generated by Gencot is never polymorphic. This implies that the Cogent compiler
will always translate it to a single C function of the same name.

In particular, if the C program contains a definition of the function \code{main}, it is treated in the same way: it is 
translated to a Cogent function with a mapped name (usually \code{cogent\_main}) and an entry wrapper named \code{main}
is generated with the same interface as the original \code{main} function. This entry wrapper thus replaces the original
main function and the resulting Cogent compilation unit can be translated to an executable binary and used as a standalone 
program.

The ``exit wrapper'' for invoking a C function from Cogent invokes the C function by its original name, hence the wrapper
must have a different name. We use the same renaming scheme for these wrappers as for the defined Cogent functions.
This implies that every exit wrapper
can be replaced by a Cogent implementation without modifying the invocations in existing Cogent code. Note that for every
function either the exit wrapper or the Cogent implementation must be present, but not both, since they have the same name.

To use the exit wrapper from Cogent, a corresponding abstract function definition must be present in Cogent.

Note that if the C function has only one parameter, a wrapper is not required. For consistency reasons we generate and use
the wrappers also for these functions.

Cogent translates all function definitions to C definitions with internal linkage. To make them accessible the entry wrappers
must have external linkage. They are defined in an antiquoted C (.ac) file which includes the complete code generated from 
Cogent, there all functions translated from Cogent are accessible from the entry wrappers. The exit wrappers are only invoked 
from code generated from Cogent. They are defined with internal linkage in an included antiquoted C file.

\subsubsection{Interfacing to Global Variables}

Accessing an existing global C variable from Cogent is not possible in a direct way, since there are no ``abstract constants'' in 
Cogent. If the global variable is actually a constant and never modified by the C program, it can be translated as an abstract
parameterless function which is implemented in antiquoted C. If the global variable is modified, this is not possible, even if 
it is never modified by the Cogent code. Semantically a parameterless function must always return the same value and thus
properties which take into account that the variable value may change could not be proven for the Cogent representation.

Global variables with non-constant values must be translated by explicitly passing them as arguments to all functions which
access them. However, for efficiency, they should be passed by reference, i.e. using a pointer to the variable, which 
corresponds to a parameter of linear type in Cogent. If the access is read-only the parameter may have a read-only type in 
Cogent, otherwise it must not be discarded and must be returned as part of the function result. Gencot supports mechanisms
to systematically introduce such parameters for translated functions.

An alternative approach would be to aggregate all global variables to a single ``system state'' and pass that state as argument
to all functions which access a global variable. Gencot does not use this approach for the following reasons. If the variables
are actually rearranged in a common struct which comprizes the system state this would not be binary compatible to the C
data layout. Instead, the system state must be a collection of pointers to all global variables. However, that would be
inflexible: it would not be possible to pass some of the pointers as read-only types and it would be inefficient because always
all pointers have to be passed even if only some are used. Moreover, it should be easier to prove functional properties 
when only those arguments are present which are actually required.

The definition of a global variable cannot be translated to Cogent. It must either remain in the C code outside of the Cogent
compilation unit or it must be implemented in antiquoted C as part of the Cogent compilation unit. Gencot decides this according
to the definition's location: if it is located in a C source which is translated to Cogent it is implemented in antiquoted 
C, otherwise the original definition is used unmodified and the variable is declared as extern in antiquoted C.

The actual access to the global variable is implemented by the entry wrappers: whenever a Cogent function takes a pointer to
a global variable as argument, the entry wrapper constructs the pointer with the help of the \code{\&} operator and adds it
to the function arguments. Pointers returned by Cogent functions are simply discarded. Since the wrappers are implemented in 
antiquoted C they can directly access the global variable in both cases, either defined externally or in antiquoted C.

When a global variable is defined or declared in antiquoted C as part of the Cogent compilation unit, its type must be specified. 
Here the Cogent antiquotation feature is used which allows to use the translated Cogent type as specification. Thus no additional 
type definitions are required from the C program, if Gencot translates all type information used in the translated parts of
the C program.

The names of global variables are not mapped to Cogent names, since they never occur in the Cogent program. In particular, they are 
not used for naming the additional function parameters used for passing the pointers to the global variables.

\subsubsection{Cogent Compilation Unit}

As of December 2018, Cogent does not support modularization by using separate compilation units. A Cogent program may be distributed
across several source files, however, these must be integrated on the source level by including them in a single compilation unit.
It would be possible to interface between several Cogent compilation units in the same way as we interface from C units to Cogent
units, however this will probably result in problems when generating proofs. 

Therefore Gencot always generates a single Cogent compilation unit for the <package>. 
At every intermediate stage of the incremental translation the package consists of one Cogent compilation unit 
together with all remaining original C compilation units and optionally additional C compilation units (e.g., for implementing 
Cogent abstract data types).

Conflicts for names with internal linkage originating in different C compilation units are avoided by Gencot's name mapping scheme
as described in Section~\ref{design-names}.

It would be possible to translate only some include files used by the Cogent compilation unit to Cogent and access the content
of the others through abstract Cogent types and functions which are mapped in antiquoted C to the original C definitions. 
However, for checking the refinement proof of the Cogent compilation unit, the Isabelle C parser reads the complete C program
which results from translating the Cogent code to C. The Isabelle C parser only supports a C subset and normally the original
<package> include files will not be restricted to this subset. Therefore we do not use any of them for the Cogent compilation
unit. Gencot always assumes that \textit{all} include files used (transitively) by the Cogent compilation unit are also translated
to Cogent and included in this form.

The only exception are the system include files. Their content typically needs specific treatment anyways. Gencot replaces every 
reference to a function declared in a system include file by an abstract function, whithout providing an implementation. 
It must be added manually by the developer. Referenced types defined in system include files are translated as usual.

\subsubsection{External Name References}
\label{design-modular-extref}

To successfully compile the Cogent compilation unit all referenced identifiers must be declared in the C code. 
Those references which are
used in the generated Cogent code must additionally be defined in Cogent. A non-local reference in a C source file is every
identifier which is used in the file but not defined or declared in the same file.

In the original C source for every non-local reference there must be a declaration or definition present in one of the included
files (its ``origin file''). If the origin file of a non-local reference is a file which has already been translated by 
Gencot, the required information about the identifier is already present in the Cogent compilation unit. As described above, 
all used include files which belong to the <package> must have been translated. If the origin file
of a non-local reference is not a part of the <package> (which normally is the case for all
system includes), we call it an ``external reference''. For external references additional information must be created and 
made available in the Cogent compilation unit.

A non-local reference is external relative to a given set of C source files, if its definition does not belong to the content
of the set. For a name without linkage (mainly type names and struct/union/enum tags) its definition must be present for every
reference, i.e. contained in the included origin file. Thus a reference to such a name is external, if its origin file does 
not belong to the set. For a name with linkage (mainly names of functions and variables) it depends on the kind of linkage.
If it has internal linkage, its definition must also be present for every reference. Then the origin file is that containing the
(single) definition, not a file containing a declaration. An external reference of a name with internal linkage occurs if
the definition is contained in an include file which does not belong to the <packge>.

If the name has external linkage, however, the definition need not be present. In this case the origin file only contains a declaration
of the name and even needs not be unique. Then it is not possible to decide whether a non-local reference is external by simply 
looking at the content of all included files. Instead, all the files in the given set must be inspected, whether they contain
the name's definition. Note that this is only necessary for deciding whether a reference is external. The information necessary
for processing it is always present as part of the declaration in the included origin file.

On the C level the information for external name references with internal linkage must always be provided manually,
since they are not defined in the <package>. The information for external references with no linkage (type and tag names) is
not required since Gencot fully translates the corresponding definitions to Cogent as usual. References to variables
with external linkage are never used in Cogent code, they are only used in antiquoted C code in the entry wrapper functions,
there the information is provided automatically by Gencot. The information for function references with external linkage is 
generated automatically by Gencot in the form of the exit wrapper functions defined in antiquoted C. 

On the Cogent level the information is provided as follows.
\begin{itemize}
\item If the external reference is a type name or a struct/union/enum tag, a Cogent type definition is generated for the mapped name.
The defined Cogent type is determined
from the C type referenced by the type name as described in Section~\ref{design-types}. The only difference is that all C type
names used directly or indirectly by the C type are resolved, if they are not already external references. This is done to avoid 
introducing type names which are never referenced from any other place in the generated Cogent program. 
\item If the external reference is a function name, an exit wrapper and the corresponding Cogent abstract function 
definition is generated.
\item If the external reference is the name of a global variable no information is provided in Cogent, it must always be 
accessed through additional function arguments where they are originally passed by the entry wrappers.
\item If the external reference is the name of an enum constant or a preprocessor defined constant, a Cogent constant definition 
is generated.
\item An external reference may be the name of a member in a struct or union. In this case also the struct or union tag must
be externally referenced and the corresponding Cogent type definition is generated, as described above. Note that for a union
member this will always be an abstract type which does not provide access to the member in Cogent.
\end{itemize}
