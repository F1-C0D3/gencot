-- Using values of readonly type.

-- Functions used as context:
cogent_fcln : CPtr U32 -> U32
cogent_fcln i =
   let (c', r') = let v' = 0
      in (3, v')
   in r'
cogent_fcro : (CPtr U32)! -> U32
cogent_fcro i =
   let (c', r') = let v' = 0
      in (3, v')
   in r'
-- Global variables used as context:
type GlobState1 =
   CPtr (CPtr U32)
type GlobState2 =
   CPtr ((CPtr U32)!)

-- struct probes:
type Struct_Cogent_ros1 = { mrg : U32, mro : (CPtr U32)!, mln : CPtr U32 }
type Struct_Cogent_ros2 = { sln : Struct_Cogent_ros1, sub : #Struct_Cogent_ros1 }

-- array probes:
type Cogent_roa1 = CArr5 U32 -- regular elements
type Cogent_roa2 =
   CArr5 ((CPtr U32)!) -- readonly elements
type Cogent_roa3 =
   CArr5 (CPtr U32) -- linear elements
type Cogent_roa4 =
   CArr5 #Cogent_roa1 -- array elements
type Cogent_roa5 =
   CArr5 #Cogent_roa2 -- array elements
type Cogent_roa6 =
   CArr5 #Cogent_roa3 -- array elements

-- Direct use of probe in context
cogent_f11ln : (CPtr U32)! -> U32
cogent_f11ln pro =
   let (c'
       , r') = let v2' = let v' = cogent_fcln
         and v1' = pro
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_f11ro : (CPtr U32)! -> U32
cogent_f11ro pro =
   let (c'
       , r') = let v2' = let v' = cogent_fcro
         and v1' = pro
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_f12ln : () -> U32
cogent_f12ln () =
   let (c'
       , r') = let v2' = let v' = cogent_fcln
         and v1' = cogent_glob ()
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_f12ro : () -> U32
cogent_f12ro () =
   let (c'
       , r') = let v2' = let v' = cogent_fcro
         and v1' = cogent_glob ()
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_f13ln : () -> U32
cogent_f13ln () =
   let (c'
       , r') = let v3' = let v' = cogent_fcln
         and v1' = cogent_frro
         and v2' = v1' ()
         and v3' = v' v2'
         in v3'
      in (3, v3')
   in r'
cogent_f13ro : () -> U32
cogent_f13ro () =
   let (c'
       , r') = let v3' = let v' = cogent_fcro
         and v1' = cogent_frro
         and v2' = v1' ()
         and v3' = v' v2'
         in v3'
      in (3, v3')
   in r'
cogent_f14ln : ( (CPtr U32)!, (CPtr U32)!, U32 ) -> U32
cogent_f14ln (pro, qro, i) =
   let (c'
       , r') = let v5' = let v' = cogent_fcln
         and v1' = i
         and v2' = pro
         and v3' = qro
         and v4' = if v1'
            then v2'
            else v3'
         and v5' = v' v4'
         in v5'
      in (3, v5')
   in r'
cogent_f14ro : ( (CPtr U32)!, (CPtr U32)!, U32 ) -> U32
cogent_f14ro (pro, qro, i) =
   let (c'
       , r') = let v5' = let v' = cogent_fcro
         and v1' = i
         and v2' = pro
         and v3' = qro
         and v4' = if v1'
            then v2'
            else v3'
         and v5' = v' v4'
         in v5'
      in (3, v5')
   in r'

-- Probe assigned to variable
cogent_f21ln : GlobState1 -> ( (), GlobState1 )
cogent_f21ln g =
   let (c', g) = let (v5'
                     , g) = let v' = cogent_frro
         and v1' = v' ()
         and v2' = g
         and g { cont = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and g = g { cont = p0' }
         in (v5', g)
      in (0, g)
   in ((), g)
cogent_f21ro : GlobState2 -> ( (), GlobState2 )
cogent_f21ro g =
   let (c', g) = let (v5'
                     , g) = let v' = cogent_frro
         and v1' = v' ()
         and v2' = g
         and g { cont = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and g = g { cont = p0' }
         in (v5', g)
      in (0, g)
   in ((), g)
cogent_f22ln : CPtr U32 -> ( (), CPtr U32 )
cogent_f22ln pln =
   let (c', pln) = let (v4'
                       , pln) = let v' = cogent_frro
         and v1' = v' ()
         and v2' = pln
         and v3' = v1'
         and (v4', pln) = (v3', v3')
         in (v4', pln)
      in (0, pln)
   in ((), pln)
cogent_f22ro : (CPtr U32)! -> U32
cogent_f22ro pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v4'
                                        , pro) = let v' = cogent_frro
            and v1' = v' ()
            and v2' = pro
            and v3' = v1'
            and (v4', pro) = (v3', v3')
            in (v4', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v6'
                               , pro) = let v5' = pro
                  and pro { cont = p0' } = v5'
                  and v6' = p0'
                  and pro = pro { cont = p0' }
                  in (v6', pro)
               in (3, v6', pro)
            in (c', pro, r')
   in r'

-- Probe returned as result
cogent_f31ln : () -> CPtr U32
cogent_f31ln () =
   let (c'
       , r') = let v1' = let v' = cogent_frro
         and v1' = v' ()
         in v1'
      in (3, v1')
   in r'
cogent_f31ro : () -> (CPtr U32)!
cogent_f31ro () =
   let (c'
       , r') = let v1' = let v' = cogent_frro
         and v1' = v' ()
         in v1'
      in (3, v1')
   in r'

-- Probe used in conditional expression with other branch as context
cogent_f41ln : ( (CPtr U32)!, CPtr U32, U32 ) -> ( U32, CPtr U32 )
cogent_f41ln (pro, qln, i) =
   let (c'
       , r') = let v5' = let v' = cogent_fcro
         and v1' = i
         and v2' = pro
         and v3' = qln
         and v4' = if v1'
            then v2'
            else v3'
         and v5' = v' v4'
         in v5'
      in (3, v5')
   in (r', qln)
cogent_f42ln : ( CPtr U32, (CPtr U32)!, U32 ) -> ( U32, CPtr U32 )
cogent_f42ln (pln, qro, i) =
   let (c'
       , r') = let v5' = let v' = cogent_fcro
         and v1' = i
         and v2' = pln
         and v3' = qro
         and v4' = if v1'
            then v2'
            else v3'
         and v5' = v' v4'
         in v5'
      in (3, v5')
   in (r', pln)

-- Probe used by accessing a struct component
cogent_f51ln : Struct_Cogent_ros1! -> Struct_Cogent_ros1!
cogent_f51ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v4'
                                        , pro) = let v' = 5
            and v1' = pro
            and pro { mrg = p0' } = v1'
            and v2' = p0'
            and v3' = v'
            and (v4', p0') = (v3', v3')
            and pro = pro { mrg = p0' }
            in (v4', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r') = let v5' = pro
               in (3, v5')
            in (c', pro, r')
   in r'
cogent_f51ro : Struct_Cogent_ros1! -> U32
cogent_f51ro pro =
   let (c', r', pro) = let (v1'
                           , pro) = let v' = pro
         and pro { mrg = p0' } = v'
         and v1' = p0'
         and pro = pro { mrg = p0' }
         in (v1', pro)
      in (3, v1', pro)
   in r'
cogent_f52ln : Struct_Cogent_ros1! -> Struct_Cogent_ros1!
cogent_f52ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v5'
                                        , pro) = let v' = cogent_frro
            and v1' = v' ()
            and v2' = pro
            and pro { mro = p0' } = v2'
            and v3' = p0'
            and v4' = v1'
            and (v5', p0') = (v4', v4')
            and pro = pro { mro = p0' }
            in (v5', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r') = let v6' = pro
               in (3, v6')
            in (c', pro, r')
   in r'
cogent_f52ro : Struct_Cogent_ros1! -> (CPtr U32)!
cogent_f52ro pro =
   let (c', r', pro) = let (v1'
                           , pro) = let v' = pro
         and pro { mro = p0' } = v'
         and v1' = p0'
         and pro = pro { mro = p0' }
         in (v1', pro)
      in (3, v1', pro)
   in r'
cogent_f53ln : Struct_Cogent_ros1! -> Struct_Cogent_ros1!
cogent_f53ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v5'
                                        , pro) = let v' = cogent_frln
            and v1' = v' ()
            and v2' = pro
            and pro { mln = p0' } = v2'
            and v3' = p0'
            and v4' = v1'
            and (v5', p0') = (v4', v4')
            and pro = pro { mln = p0' }
            in (v5', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r') = let v6' = pro
               in (3, v6')
            in (c', pro, r')
   in r'
cogent_f53ro : Struct_Cogent_ros1! -> (CPtr U32)!
cogent_f53ro pro =
   let (c', r', pro) = let (v1'
                           , pro) = let v' = pro
         and pro { mln = p0' } = v'
         and v1' = p0'
         and pro = pro { mln = p0' }
         in (v1', pro)
      in (3, v1', pro)
   in r'
cogent_f54ln : Struct_Cogent_ros1! -> Struct_Cogent_ros1!
cogent_f54ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v5'
                                        , pro) = let v' = 5
            and v1' = pro
            and pro { mln = p0' } = v1'
            and v2' = p0'
            and p0' { cont = p1' } = v2'
            and v3' = p1'
            and v4' = v'
            and (v5', p1') = (v4', v4')
            and p0' = p0' { cont = p1' }
            and pro = pro { mln = p0' }
            in (v5', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r') = let v6' = pro
               in (3, v6')
            in (c', pro, r')
   in r'
cogent_f54ro : Struct_Cogent_ros1! -> U32
cogent_f54ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v' = pro
         and pro { mln = p0' } = v'
         and v1' = p0'
         and p0' { cont = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { cont = p1' }
         and pro = pro { mln = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f55ln : Struct_Cogent_ros1! -> U32
cogent_f55ln pro =
   let (c', r', pro) = let (v3'
                           , pro) = let v' = cogent_fcln
         and v1' = pro
         and pro { mln = p0' } = v1'
         and v2' = p0'
         and pro = pro { mln = p0' }
         and v3' = v' v2'
         in (v3', pro)
      in (3, v3', pro)
   in r'
cogent_f55ro : Struct_Cogent_ros1! -> U32
cogent_f55ro pro =
   let (c', r', pro) = let (v3'
                           , pro) = let v' = cogent_fcro
         and v1' = pro
         and pro { mln = p0' } = v1'
         and v2' = p0'
         and pro = pro { mln = p0' }
         and v3' = v' v2'
         in (v3', pro)
      in (3, v3', pro)
   in r'
cogent_f56ln : ( Struct_Cogent_ros1!, GlobState1 ) -> ( (), GlobState1 )
cogent_f56ln (pro, g) =
   let (c', pro, g) = let (v5'
                          , pro
                          , g) = let v' = pro
         and pro { mln = p0' } = v'
         and v1' = p0'
         and pro = pro { mln = p0' }
         and v2' = g
         and g { cont = p1' } = v2'
         and v3' = p1'
         and v4' = v1'
         and (v5', p1') = (v4', v4')
         and g = g { cont = p1' }
         in (v5', pro, g)
      in (0, pro, g)
   in ((), g)
cogent_f56ro : ( Struct_Cogent_ros1!, GlobState2 ) -> ( (), GlobState2 )
cogent_f56ro (pro, g) =
   let (c', pro, g) = let (v5'
                          , pro
                          , g) = let v' = pro
         and pro { mln = p0' } = v'
         and v1' = p0'
         and pro = pro { mln = p0' }
         and v2' = g
         and g { cont = p1' } = v2'
         and v3' = p1'
         and v4' = v1'
         and (v5', p1') = (v4', v4')
         and g = g { cont = p1' }
         in (v5', pro, g)
      in (0, pro, g)
   in ((), g)
cogent_f57ln : ( Struct_Cogent_ros1!, CPtr U32 ) -> ( (), CPtr U32 )
cogent_f57ln (pro, pln) =
   let (c', pro, pln) = let (v4'
                            , pro
                            , pln) = let v' = pro
         and pro { mln = p0' } = v'
         and v1' = p0'
         and pro = pro { mln = p0' }
         and v2' = pln
         and v3' = v1'
         and (v4', pln) = (v3', v3')
         in (v4', pro, pln)
      in (0, pro, pln)
   in ((), pln)
cogent_f57ro : ( Struct_Cogent_ros1!, (CPtr U32)! ) -> U32
cogent_f57ro (pro, qro) =
   let (c', pro, qro, r') = let (c'
                                , pro
                                , qro) = let (v4'
                                             , pro
                                             , qro) = let v' = pro
            and pro { mln = p0' } = v'
            and v1' = p0'
            and pro = pro { mln = p0' }
            and v2' = qro
            and v3' = v1'
            and (v4', qro) = (v3', v3')
            in (v4', pro, qro)
         in (0, pro, qro)
      in if c' > 0
         then (c', pro, qro, r')
         else let (c'
                  , r'
                  , qro) = let (v6'
                               , qro) = let v5' = qro
                  and qro { cont = p1' } = v5'
                  and v6' = p1'
                  and qro = qro { cont = p1' }
                  in (v6', qro)
               in (3, v6', qro)
            in (c', pro, qro, r')
   in r'
cogent_f58ln : Struct_Cogent_ros1! -> CPtr U32
cogent_f58ln pro =
   let (c', r', pro) = let (v1'
                           , pro) = let v' = pro
         and pro { mln = p0' } = v'
         and v1' = p0'
         and pro = pro { mln = p0' }
         in (v1', pro)
      in (3, v1', pro)
   in r'
cogent_f58ro : Struct_Cogent_ros1! -> (CPtr U32)!
cogent_f58ro pro =
   let (c', r', pro) = let (v1'
                           , pro) = let v' = pro
         and pro { mln = p0' } = v'
         and v1' = p0'
         and pro = pro { mln = p0' }
         in (v1', pro)
      in (3, v1', pro)
   in r'
cogent_f59ln : ( Struct_Cogent_ros1!, CPtr U32, U32 ) -> ( U32, CPtr U32 )
cogent_f59ln (pro, qln, i) =
   let (c', r', pro) = let (v6'
                           , pro) = let v' = cogent_fcro
         and v1' = i
         and v4' = qln
         and (v5', pro) = if v1'
            then let v2' = pro
               and pro { mln = p0' } = v2'
               and v3' = p0'
               and pro = pro { mln = p0' }
               in (v3', pro)
            else (v4', pro)
         and v6' = v' v5'
         in (v6', pro)
      in (3, v6', pro)
   in (r', qln)
cogent_f59ro : ( Struct_Cogent_ros1!, (CPtr U32)!, U32 ) -> U32
cogent_f59ro (pro, qro, i) =
   let (c', r', pro) = let (v6'
                           , pro) = let v' = cogent_fcro
         and v1' = i
         and v4' = qro
         and (v5', pro) = if v1'
            then let v2' = pro
               and pro { mln = p0' } = v2'
               and v3' = p0'
               and pro = pro { mln = p0' }
               in (v3', pro)
            else (v4', pro)
         and v6' = v' v5'
         in (v6', pro)
      in (3, v6', pro)
   in r'

cogent_f61ln : Struct_Cogent_ros2! -> Struct_Cogent_ros2!
cogent_f61ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v5'
                                        , pro) = let v' = 5
            and v1' = pro
            and pro { sln = p0' } = v1'
            and v2' = p0'
            and p0' { mrg = p1' } = v2'
            and v3' = p1'
            and v4' = v'
            and (v5', p1') = (v4', v4')
            and p0' = p0' { mrg = p1' }
            and pro = pro { sln = p0' }
            in (v5', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r') = let v6' = pro
               in (3, v6')
            in (c', pro, r')
   in r'
cogent_f61ro : Struct_Cogent_ros2! -> U32
cogent_f61ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v' = pro
         and pro { sln = p0' } = v'
         and v1' = p0'
         and p0' { mrg = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { mrg = p1' }
         and pro = pro { sln = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f62ln : Struct_Cogent_ros2! -> Struct_Cogent_ros2!
cogent_f62ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v6'
                                        , pro) = let v' = cogent_frro
            and v1' = v' ()
            and v2' = pro
            and pro { sln = p0' } = v2'
            and v3' = p0'
            and p0' { mro = p1' } = v3'
            and v4' = p1'
            and v5' = v1'
            and (v6', p1') = (v5', v5')
            and p0' = p0' { mro = p1' }
            and pro = pro { sln = p0' }
            in (v6', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r') = let v7' = pro
               in (3, v7')
            in (c', pro, r')
   in r'
cogent_f62ro : Struct_Cogent_ros2! -> (CPtr U32)!
cogent_f62ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v' = pro
         and pro { sln = p0' } = v'
         and v1' = p0'
         and p0' { mro = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { mro = p1' }
         and pro = pro { sln = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f63ln : Struct_Cogent_ros2! -> Struct_Cogent_ros2!
cogent_f63ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v6'
                                        , pro) = let v' = cogent_frln
            and v1' = v' ()
            and v2' = pro
            and pro { sln = p0' } = v2'
            and v3' = p0'
            and p0' { mln = p1' } = v3'
            and v4' = p1'
            and v5' = v1'
            and (v6', p1') = (v5', v5')
            and p0' = p0' { mln = p1' }
            and pro = pro { sln = p0' }
            in (v6', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r') = let v7' = pro
               in (3, v7')
            in (c', pro, r')
   in r'
cogent_f63ro : Struct_Cogent_ros2! -> (CPtr U32)!
cogent_f63ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v' = pro
         and pro { sln = p0' } = v'
         and v1' = p0'
         and p0' { mln = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { mln = p1' }
         and pro = pro { sln = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f64ln : Struct_Cogent_ros2! -> Struct_Cogent_ros2!
cogent_f64ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v6'
                                        , pro) = let v' = cogent_frln
            and v1' = v' ()
            and v2' = pro
            and pro { sub = p0' } = v2'
            and v3' = p0'
            and p0' { mln = p1' } = v3'
            and v4' = p1'
            and v5' = v1'
            and (v6', p1') = (v5', v5')
            and p0' = p0' { mln = p1' }
            and pro = pro { sub = p0' }
            in (v6', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r') = let v7' = pro
               in (3, v7')
            in (c', pro, r')
   in r'
cogent_f64ro : Struct_Cogent_ros2! -> (CPtr U32)!
cogent_f64ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v' = pro
         and pro { sub = p0' } = v'
         and v1' = p0'
         and p0' { mln = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { mln = p1' }
         and pro = pro { sub = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'

-- Probe used by accessing an array element
cogent_f71ln : Cogent_roa1! -> U32
cogent_f71ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v5'
                                        , pro) = let v' = 5
            and v2' = 1
            and v1' = pro
            and (pro @{ @v2' = p0' }
                , i0') = (v1', v2')
            and v3' = p0'
            and v4' = v'
            and (v5', p0') = (v4', v4')
            and pro = pro @{ @i0' = p0' }
            in (v5', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v8'
                               , pro) = let v7' = 1
                  and v6' = pro
                  and (pro @{ @v7' = p1' }
                      , i1') = (v6', v7')
                  and v8' = p1'
                  and pro = pro @{ @i1' = p1' }
                  in (v8', pro)
               in (3, v8', pro)
            in (c', pro, r')
   in r'
cogent_f71ro : Cogent_roa1! -> U32
cogent_f71ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f72ln : Cogent_roa2! -> (CPtr U32)!
cogent_f72ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v6'
                                        , pro) = let v' = cogent_frro
            and v1' = v' ()
            and v3' = 1
            and v2' = pro
            and (pro @{ @v3' = p0' }
                , i0') = (v2', v3')
            and v4' = p0'
            and v5' = v1'
            and (v6', p0') = (v5', v5')
            and pro = pro @{ @i0' = p0' }
            in (v6', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v9'
                               , pro) = let v8' = 1
                  and v7' = pro
                  and (pro @{ @v8' = p1' }
                      , i1') = (v7', v8')
                  and v9' = p1'
                  and pro = pro @{ @i1' = p1' }
                  in (v9', pro)
               in (3, v9', pro)
            in (c', pro, r')
   in r'
cogent_f72ro : Cogent_roa2! -> (CPtr U32)!
cogent_f72ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f73ln : Cogent_roa3! -> (CPtr U32)!
cogent_f73ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v6'
                                        , pro) = let v' = cogent_frln
            and v1' = v' ()
            and v3' = 1
            and v2' = pro
            and (pro @{ @v3' = p0' }
                , i0') = (v2', v3')
            and v4' = p0'
            and v5' = v1'
            and (v6', p0') = (v5', v5')
            and pro = pro @{ @i0' = p0' }
            in (v6', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v9'
                               , pro) = let v8' = 1
                  and v7' = pro
                  and (pro @{ @v8' = p1' }
                      , i1') = (v7', v8')
                  and v9' = p1'
                  and pro = pro @{ @i1' = p1' }
                  in (v9', pro)
               in (3, v9', pro)
            in (c', pro, r')
   in r'
cogent_f73ro : Cogent_roa3! -> (CPtr U32)!
cogent_f73ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f74ln : Cogent_roa3! -> (CPtr U32)!
cogent_f74ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v6'
                                        , pro) = let v' = 5
            and v2' = 1
            and v1' = pro
            and (pro @{ @v2' = p0' }
                , i0') = (v1', v2')
            and v3' = p0'
            and p0' { cont = p1' } = v3'
            and v4' = p1'
            and v5' = v'
            and (v6', p1') = (v5', v5')
            and p0' = p0' { cont = p1' }
            and pro = pro @{ @i0' = p0' }
            in (v6', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v9'
                               , pro) = let v8' = 1
                  and v7' = pro
                  and (pro @{ @v8' = p2' }
                      , i2') = (v7', v8')
                  and v9' = p2'
                  and pro = pro @{ @i2' = p2' }
                  in (v9', pro)
               in (3, v9', pro)
            in (c', pro, r')
   in r'
cogent_f74ro : Cogent_roa3! -> U32
cogent_f74ro pro =
   let (c', r', pro) = let (v3'
                           , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and p0' { cont = p1' } = v2'
         and v3' = p1'
         and p0' = p0' { cont = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v3', pro)
      in (3, v3', pro)
   in r'
cogent_f75ln : Cogent_roa3! -> U32
cogent_f75ln pro =
   let (c', r', pro) = let (v4'
                           , pro) = let v' = cogent_fcln
         and v2' = 1
         and v1' = pro
         and (pro @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and pro = pro @{ @i0' = p0' }
         and v4' = v' v3'
         in (v4', pro)
      in (3, v4', pro)
   in r'
cogent_f75ro : Cogent_roa3! -> U32
cogent_f75ro pro =
   let (c', r', pro) = let (v4'
                           , pro) = let v' = cogent_fcro
         and v2' = 1
         and v1' = pro
         and (pro @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and pro = pro @{ @i0' = p0' }
         and v4' = v' v3'
         in (v4', pro)
      in (3, v4', pro)
   in r'
cogent_f76ln : ( Cogent_roa3!, GlobState1 ) -> ( (), GlobState1 )
cogent_f76ln (pro, g) =
   let (c', pro, g) = let (v6'
                          , pro
                          , g) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pro = pro @{ @i0' = p0' }
         and v3' = g
         and g { cont = p1' } = v3'
         and v4' = p1'
         and v5' = v2'
         and (v6', p1') = (v5', v5')
         and g = g { cont = p1' }
         in (v6', pro, g)
      in (0, pro, g)
   in ((), g)
cogent_f76ro : ( Cogent_roa3!, GlobState2 ) -> ( (), GlobState2 )
cogent_f76ro (pro, g) =
   let (c', pro, g) = let (v6'
                          , pro
                          , g) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pro = pro @{ @i0' = p0' }
         and v3' = g
         and g { cont = p1' } = v3'
         and v4' = p1'
         and v5' = v2'
         and (v6', p1') = (v5', v5')
         and g = g { cont = p1' }
         in (v6', pro, g)
      in (0, pro, g)
   in ((), g)
cogent_f77ln : ( Cogent_roa3!, CPtr U32 ) -> ( (), CPtr U32 )
cogent_f77ln (pro, qln) =
   let (c', pro, qln) = let (v5'
                            , pro
                            , qln) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pro = pro @{ @i0' = p0' }
         and v3' = qln
         and v4' = v2'
         and (v5', qln) = (v4', v4')
         in (v5', pro, qln)
      in (0, pro, qln)
   in ((), qln)
cogent_f77ro : ( Cogent_roa3!, (CPtr U32)! ) -> U32
cogent_f77ro (pro, qro) =
   let (c', pro, qro, r') = let (c'
                                , pro
                                , qro) = let (v5'
                                             , pro
                                             , qro) = let v1' = 1
            and v' = pro
            and (pro @{ @v1' = p0' }
                , i0') = (v', v1')
            and v2' = p0'
            and pro = pro @{ @i0' = p0' }
            and v3' = qro
            and v4' = v2'
            and (v5', qro) = (v4', v4')
            in (v5', pro, qro)
         in (0, pro, qro)
      in if c' > 0
         then (c', pro, qro, r')
         else let (c'
                  , r'
                  , qro) = let (v7'
                               , qro) = let v6' = qro
                  and qro { cont = p1' } = v6'
                  and v7' = p1'
                  and qro = qro { cont = p1' }
                  in (v7', qro)
               in (3, v7', qro)
            in (c', pro, qro, r')
   in r'
cogent_f78ln : Cogent_roa3! -> CPtr U32
cogent_f78ln pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f78ro : Cogent_roa3! -> (CPtr U32)!
cogent_f78ro pro =
   let (c', r', pro) = let (v2'
                           , pro) = let v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pro = pro @{ @i0' = p0' }
         in (v2', pro)
      in (3, v2', pro)
   in r'
cogent_f79ln : ( Cogent_roa3!, CPtr U32, U32 ) -> ( U32, CPtr U32 )
cogent_f79ln (pro, qln, i) =
   let (c', r', pro) = let (v7'
                           , pro) = let v' = cogent_fcro
         and v1' = i
         and v5' = qln
         and (v6', pro) = if v1'
            then let v3' = 1
               and v2' = pro
               and (pro @{ @v3' = p0' }
                   , i0') = (v2', v3')
               and v4' = p0'
               and pro = pro @{ @i0' = p0' }
               in (v4', pro)
            else (v5', pro)
         and v7' = v' v6'
         in (v7', pro)
      in (3, v7', pro)
   in (r', qln)
cogent_f79ro : ( Cogent_roa3!, (CPtr U32)!, U32 ) -> U32
cogent_f79ro (pro, qro, i) =
   let (c', r', pro) = let (v7'
                           , pro) = let v' = cogent_fcro
         and v1' = i
         and v5' = qro
         and (v6', pro) = if v1'
            then let v3' = 1
               and v2' = pro
               and (pro @{ @v3' = p0' }
                   , i0') = (v2', v3')
               and v4' = p0'
               and pro = pro @{ @i0' = p0' }
               in (v4', pro)
            else (v5', pro)
         and v7' = v' v6'
         in (v7', pro)
      in (3, v7', pro)
   in r'

cogent_f81ln : Cogent_roa4! -> U32
cogent_f81ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v7'
                                        , pro) = let v' = 5
            and v4' = 1
            and v2' = 1
            and v1' = pro
            and (pro @{ @v2' = p0' }
                , i0') = (v1', v2')
            and v3' = p0'
            and (p0' @{ @v4' = p1' }
                , i1') = (v3', v4')
            and v5' = p1'
            and v6' = v'
            and (v7', p1') = (v6', v6')
            and p0' = p0' @{ @i1' = p1' }
            and pro = pro @{ @i0' = p0' }
            in (v7', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v12'
                               , pro) = let v11' = 1
                  and v9' = 1
                  and v8' = pro
                  and (pro @{ @v9' = p2' }
                      , i2') = (v8', v9')
                  and v10' = p2'
                  and (p2' @{ @v11' = p3' }
                      , i3') = (v10', v11')
                  and v12' = p3'
                  and p2' = p2' @{ @i3' = p3' }
                  and pro = pro @{ @i2' = p2' }
                  in (v12', pro)
               in (3, v12', pro)
            in (c', pro, r')
   in r'
cogent_f81ro : Cogent_roa4! -> U32
cogent_f81ro pro =
   let (c', r', pro) = let (v4'
                           , pro) = let v3' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and (p0' @{ @v3' = p1' }
             , i1') = (v2', v3')
         and v4' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v4', pro)
      in (3, v4', pro)
   in r'
cogent_f82ln : Cogent_roa5! -> (CPtr U32)!
cogent_f82ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v8'
                                        , pro) = let v' = cogent_frro
            and v1' = v' ()
            and v5' = 1
            and v3' = 1
            and v2' = pro
            and (pro @{ @v3' = p0' }
                , i0') = (v2', v3')
            and v4' = p0'
            and (p0' @{ @v5' = p1' }
                , i1') = (v4', v5')
            and v6' = p1'
            and v7' = v1'
            and (v8', p1') = (v7', v7')
            and p0' = p0' @{ @i1' = p1' }
            and pro = pro @{ @i0' = p0' }
            in (v8', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v13'
                               , pro) = let v12' = 1
                  and v10' = 1
                  and v9' = pro
                  and (pro @{ @v10' = p2' }
                      , i2') = (v9', v10')
                  and v11' = p2'
                  and (p2' @{ @v12' = p3' }
                      , i3') = (v11', v12')
                  and v13' = p3'
                  and p2' = p2' @{ @i3' = p3' }
                  and pro = pro @{ @i2' = p2' }
                  in (v13', pro)
               in (3, v13', pro)
            in (c', pro, r')
   in r'
cogent_f82ro : Cogent_roa5! -> (CPtr U32)!
cogent_f82ro pro =
   let (c', r', pro) = let (v4'
                           , pro) = let v3' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and (p0' @{ @v3' = p1' }
             , i1') = (v2', v3')
         and v4' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v4', pro)
      in (3, v4', pro)
   in r'
cogent_f83ln : Cogent_roa6! -> (CPtr U32)!
cogent_f83ln pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v8'
                                        , pro) = let v' = cogent_frln
            and v1' = v' ()
            and v5' = 1
            and v3' = 1
            and v2' = pro
            and (pro @{ @v3' = p0' }
                , i0') = (v2', v3')
            and v4' = p0'
            and (p0' @{ @v5' = p1' }
                , i1') = (v4', v5')
            and v6' = p1'
            and v7' = v1'
            and (v8', p1') = (v7', v7')
            and p0' = p0' @{ @i1' = p1' }
            and pro = pro @{ @i0' = p0' }
            in (v8', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v13'
                               , pro) = let v12' = 1
                  and v10' = 1
                  and v9' = pro
                  and (pro @{ @v10' = p2' }
                      , i2') = (v9', v10')
                  and v11' = p2'
                  and (p2' @{ @v12' = p3' }
                      , i3') = (v11', v12')
                  and v13' = p3'
                  and p2' = p2' @{ @i3' = p3' }
                  and pro = pro @{ @i2' = p2' }
                  in (v13', pro)
               in (3, v13', pro)
            in (c', pro, r')
   in r'
cogent_f83ro : Cogent_roa6! -> (CPtr U32)!
cogent_f83ro pro =
   let (c', r', pro) = let (v4'
                           , pro) = let v3' = 1
         and v1' = 1
         and v' = pro
         and (pro @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and (p0' @{ @v3' = p1' }
             , i1') = (v2', v3')
         and v4' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pro = pro @{ @i0' = p0' }
         in (v4', pro)
      in (3, v4', pro)
   in r'

-- probe assigned to struct component or array element
cogent_f91ln : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_f91ln pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = cogent_frro
         and v1' = v' ()
         and v2' = pln
         and pln { mln = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and pln = pln { mln = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_f91ro : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_f91ro pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = cogent_frro
         and v1' = v' ()
         and v2' = pln
         and pln { mro = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and pln = pln { mro = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_f92ln : Cogent_roa3 -> ( (), Cogent_roa3 )
cogent_f92ln pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frro
         and v1' = v' ()
         and v3' = 1
         and v2' = pln
         and (pln @{ @v3' = p0' }
             , i0') = (v2', v3')
         and v4' = p0'
         and v5' = v1'
         and (v6', p0') = (v5', v5')
         and pln = pln @{ @i0' = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)
cogent_f92ro : Cogent_roa2 -> ( (), Cogent_roa2 )
cogent_f92ro pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frro
         and v1' = v' ()
         and v3' = 1
         and v2' = pln
         and (pln @{ @v3' = p0' }
             , i0') = (v2', v3')
         and v4' = p0'
         and v5' = v1'
         and (v6', p0') = (v5', v5')
         and pln = pln @{ @i0' = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)

-- Using values of linear type (can be banged).

-- Direct use of probe in context
cogent_g11ln : CPtr U32 -> U32
cogent_g11ln pln =
   let (c'
       , r') = let v2' = let v' = cogent_fcln
         and v1' = pln
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_g11ro : CPtr U32 -> U32
cogent_g11ro pln =
   let (c'
       , r') = let v2' = let v' = cogent_fcro
         and v1' = pln
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_g12ln : () -> U32
cogent_g12ln () =
   let (c'
       , r') = let v2' = let v' = cogent_fcln
         and v1' = cogent_globln ()
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_g12ro : () -> U32
cogent_g12ro () =
   let (c'
       , r') = let v2' = let v' = cogent_fcro
         and v1' = cogent_globln ()
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_g13ln : () -> U32
cogent_g13ln () =
   let (c'
       , r') = let v3' = let v' = cogent_fcln
         and v1' = cogent_frln
         and v2' = v1' ()
         and v3' = v' v2'
         in v3'
      in (3, v3')
   in r'
cogent_g13ro : () -> U32
cogent_g13ro () =
   let (c'
       , r') = let v3' = let v' = cogent_fcro
         and v1' = cogent_frln
         and v2' = v1' ()
         and v3' = v' v2'
         in v3'
      in (3, v3')
   in r'
cogent_g14ln : ( CPtr U32, CPtr U32, U32 ) -> U32
cogent_g14ln (pln, qln, i) =
   let (c'
       , r') = let v5' = let v' = cogent_fcln
         and v1' = i
         and v2' = pln
         and v3' = qln
         and v4' = if v1'
            then v2'
            else v3'
         and v5' = v' v4'
         in v5'
      in (3, v5')
   in r'
cogent_g14ro : ( CPtr U32, CPtr U32, U32 ) -> U32
cogent_g14ro (pln, qln, i) =
   let (c'
       , r') = let v5' = let v' = cogent_fcro
         and v1' = i
         and v2' = pln
         and v3' = qln
         and v4' = if v1'
            then v2'
            else v3'
         and v5' = v' v4'
         in v5'
      in (3, v5')
   in r'

-- Probe assigned to variable
cogent_g21ln : GlobState1 -> ( (), GlobState1 )
cogent_g21ln g =
   let (c', g) = let (v5'
                     , g) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = g
         and g { cont = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and g = g { cont = p0' }
         in (v5', g)
      in (0, g)
   in ((), g)
cogent_g21ro : GlobState2 -> ( (), GlobState2 )
cogent_g21ro g =
   let (c', g) = let (v5'
                     , g) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = g
         and g { cont = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and g = g { cont = p0' }
         in (v5', g)
      in (0, g)
   in ((), g)
cogent_g22ln : CPtr U32 -> ( (), CPtr U32 )
cogent_g22ln pln =
   let (c', pln) = let (v4'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = pln
         and v3' = v1'
         and (v4', pln) = (v3', v3')
         in (v4', pln)
      in (0, pln)
   in ((), pln)
cogent_g22ro : (CPtr U32)! -> U32
cogent_g22ro pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v4'
                                        , pro) = let v' = cogent_frln
            and v1' = v' ()
            and v2' = pro
            and v3' = v1'
            and (v4', pro) = (v3', v3')
            in (v4', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v6'
                               , pro) = let v5' = pro
                  and pro { cont = p0' } = v5'
                  and v6' = p0'
                  and pro = pro { cont = p0' }
                  in (v6', pro)
               in (3, v6', pro)
            in (c', pro, r')
   in r'

-- Probe returned as result
cogent_g31ln : () -> CPtr U32
cogent_g31ln () =
   let (c'
       , r') = let v1' = let v' = cogent_frln
         and v1' = v' ()
         in v1'
      in (3, v1')
   in r'
cogent_g31ro : () -> (CPtr U32)!
cogent_g31ro () =
   let (c'
       , r') = let v1' = let v' = cogent_frln
         and v1' = v' ()
         in v1'
      in (3, v1')
   in r'

-- Probe used by accessing a struct component
cogent_g51ln : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_g51ln pln =
   let (c', pln) = let (v4'
                       , pln) = let v' = 5
         and v1' = pln
         and pln { mrg = p0' } = v1'
         and v2' = p0'
         and v3' = v'
         and (v4', p0') = (v3', v3')
         and pln = pln { mrg = p0' }
         in (v4', pln)
      in (0, pln)
   in ((), pln)
cogent_g51ro : Struct_Cogent_ros1 -> U32
cogent_g51ro pln =
   let (c', r', pln) = let (v1'
                           , pln) = let v' = pln
         and pln { mrg = p0' } = v'
         and v1' = p0'
         and pln = pln { mrg = p0' }
         in (v1', pln)
      in (3, v1', pln)
   in r'
cogent_g52ln : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_g52ln pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = pln
         and pln { mro = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and pln = pln { mro = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_g52ro : Struct_Cogent_ros1 -> ( (CPtr U32)!, Struct_Cogent_ros1 )
cogent_g52ro pln =
   let (c', r', pln) = let (v1'
                           , pln) = let v' = pln
         and pln { mro = p0' } = v'
         and v1' = p0'
         and pln = pln { mro = p0' }
         in (v1', pln)
      in (3, v1', pln)
   in (r', pln)
cogent_g53ln : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_g53ln pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = pln
         and pln { mln = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and pln = pln { mln = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_g53ro : Struct_Cogent_ros1 -> ( CPtr U32, Struct_Cogent_ros1 )
cogent_g53ro pln =
   let (c', r', pln) = let (v1'
                           , pln) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and pln = pln { mln = p0' }
         in (v1', pln)
      in (3, v1', pln)
   in (r', pln)
cogent_g54ln : Struct_Cogent_ros1 -> ( U32, Struct_Cogent_ros1 )
cogent_g54ln pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = 5
         and v1' = pln
         and pln { mln = p0' } = v1'
         and v2' = p0'
         and p0' { cont = p1' } = v2'
         and v3' = p1'
         and v4' = v'
         and (v5', p1') = (v4', v4')
         and p0' = p0' { cont = p1' }
         and pln = pln { mln = p0' }
         in (v5', pln)
      in (0, pln)
   in (r', pln)
cogent_g54ro : Struct_Cogent_ros1 -> ( U32, Struct_Cogent_ros1 )
cogent_g54ro pln =
   let (c', pln) = let (v2'
                       , pln) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and p0' { cont = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { cont = p1' }
         and pln = pln { mln = p0' }
         in (v2', pln)
      in (0, pln)
   in (r', pln)
cogent_g55ln : Struct_Cogent_ros1 -> U32
cogent_g55ln pln =
   let (c', r', pln) = let (v3'
                           , pln) = let v' = cogent_fcln
         and v1' = pln
         and pln { mln = p0' } = v1'
         and v2' = p0'
         and pln = pln { mln = p0' }
         and v3' = v' v2'
         in (v3', pln)
      in (3, v3', pln)
   in r'
cogent_g55ro : Struct_Cogent_ros1 -> U32
cogent_g55ro pln =
   let (c', r', pln) = let (v3'
                           , pln) = let v' = cogent_fcro
         and v1' = pln
         and pln { mln = p0' } = v1'
         and v2' = p0'
         and pln = pln { mln = p0' }
         and v3' = v' v2'
         in (v3', pln)
      in (3, v3', pln)
   in r'
cogent_g56ln : ( Struct_Cogent_ros1, GlobState1 ) -> ( (), GlobState1 )
cogent_g56ln (pln, g) =
   let (c', pln, g) = let (v5'
                          , pln
                          , g) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and pln = pln { mln = p0' }
         and v2' = g
         and g { cont = p1' } = v2'
         and v3' = p1'
         and v4' = v1'
         and (v5', p1') = (v4', v4')
         and g = g { cont = p1' }
         in (v5', pln, g)
      in (0, pln, g)
   in ((), g)
cogent_g56ro : ( Struct_Cogent_ros1, GlobState2 ) -> ( (), GlobState2 )
cogent_g56ro (pln, g) =
   let (c', pln, g) = let (v5'
                          , pln
                          , g) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and pln = pln { mln = p0' }
         and v2' = g
         and g { cont = p1' } = v2'
         and v3' = p1'
         and v4' = v1'
         and (v5', p1') = (v4', v4')
         and g = g { cont = p1' }
         in (v5', pln, g)
      in (0, pln, g)
   in ((), g)
cogent_g57ln : ( Struct_Cogent_ros1, CPtr U32 ) -> ( (), CPtr U32 )
cogent_g57ln (pln, qln) =
   let (c', pln, qln) = let (v4'
                            , pln
                            , qln) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and pln = pln { mln = p0' }
         and v2' = qln
         and v3' = v1'
         and (v4', qln) = (v3', v3')
         in (v4', pln, qln)
      in (0, pln, qln)
   in ((), qln)
cogent_g57ro : ( Struct_Cogent_ros1, (CPtr U32)! ) -> U32
cogent_g57ro (pln, qro) =
   let (c', pln, qro, r') = let (c'
                                , pln
                                , qro) = let (v4'
                                             , pln
                                             , qro) = let v' = pln
            and pln { mln = p0' } = v'
            and v1' = p0'
            and pln = pln { mln = p0' }
            and v2' = qro
            and v3' = v1'
            and (v4', qro) = (v3', v3')
            in (v4', pln, qro)
         in (0, pln, qro)
      in if c' > 0
         then (c', pln, qro, r')
         else let (c'
                  , r'
                  , qro) = let (v6'
                               , qro) = let v5' = qro
                  and qro { cont = p1' } = v5'
                  and v6' = p1'
                  and qro = qro { cont = p1' }
                  in (v6', qro)
               in (3, v6', qro)
            in (c', pln, qro, r')
   in r'
cogent_g58ln : Struct_Cogent_ros1 -> CPtr U32
cogent_g58ln pln =
   let (c', r', pln) = let (v1'
                           , pln) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and pln = pln { mln = p0' }
         in (v1', pln)
      in (3, v1', pln)
   in r'
cogent_g58ro : Struct_Cogent_ros1 -> (CPtr U32)!
cogent_g58ro pln =
   let (c', r', pln) = let (v1'
                           , pln) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and pln = pln { mln = p0' }
         in (v1', pln)
      in (3, v1', pln)
   in r'
cogent_g59ln : ( Struct_Cogent_ros1, CPtr U32, U32 ) -> ( U32, CPtr U32 )
cogent_g59ln (pln, qln, i) =
   let (c', r', pln) = let (v6'
                           , pln) = let v' = cogent_fcro
         and v1' = i
         and v4' = qln
         and (v5', pln) = if v1'
            then let v2' = pln
               and pln { mln = p0' } = v2'
               and v3' = p0'
               and pln = pln { mln = p0' }
               in (v3', pln)
            else (v4', pln)
         and v6' = v' v5'
         in (v6', pln)
      in (3, v6', pln)
   in (r', qln)
cogent_g59ro : ( Struct_Cogent_ros1, (CPtr U32)!, U32 ) -> U32
cogent_g59ro (pln, qro, i) =
   let (c', r', pln) = let (v6'
                           , pln) = let v' = cogent_fcro
         and v1' = i
         and v4' = qro
         and (v5', pln) = if v1'
            then let v2' = pln
               and pln { mln = p0' } = v2'
               and v3' = p0'
               and pln = pln { mln = p0' }
               in (v3', pln)
            else (v4', pln)
         and v6' = v' v5'
         in (v6', pln)
      in (3, v6', pln)
   in r'

cogent_g61ln : Struct_Cogent_ros2 -> ( (), Struct_Cogent_ros2 )
cogent_g61ln pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = 5
         and v1' = pln
         and pln { sln = p0' } = v1'
         and v2' = p0'
         and p0' { mrg = p1' } = v2'
         and v3' = p1'
         and v4' = v'
         and (v5', p1') = (v4', v4')
         and p0' = p0' { mrg = p1' }
         and pln = pln { sln = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_g61ro : Struct_Cogent_ros2 -> ( U32, Struct_Cogent_ros2 )
cogent_g61ro pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v' = pln
         and pln { sln = p0' } = v'
         and v1' = p0'
         and p0' { mrg = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { mrg = p1' }
         and pln = pln { sln = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in (r', pln)
cogent_g62ln : Struct_Cogent_ros2 -> ( (), Struct_Cogent_ros2 )
cogent_g62ln pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = pln
         and pln { sln = p0' } = v2'
         and v3' = p0'
         and p0' { mro = p1' } = v3'
         and v4' = p1'
         and v5' = v1'
         and (v6', p1') = (v5', v5')
         and p0' = p0' { mro = p1' }
         and pln = pln { sln = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)
cogent_g62ro : Struct_Cogent_ros2 -> ( (CPtr U32)!, Struct_Cogent_ros2 )
cogent_g62ro pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v' = pln
         and pln { sln = p0' } = v'
         and v1' = p0'
         and p0' { mro = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { mro = p1' }
         and pln = pln { sln = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in (r', pln)
cogent_g63ln : Struct_Cogent_ros2 -> ( (), Struct_Cogent_ros2 )
cogent_g63ln pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = pln
         and pln { sln = p0' } = v2'
         and v3' = p0'
         and p0' { mln = p1' } = v3'
         and v4' = p1'
         and v5' = v1'
         and (v6', p1') = (v5', v5')
         and p0' = p0' { mln = p1' }
         and pln = pln { sln = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)
cogent_g63ro : Struct_Cogent_ros2 -> ( CPtr U32, Struct_Cogent_ros2 )
cogent_g63ro pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v' = pln
         and pln { sln = p0' } = v'
         and v1' = p0'
         and p0' { mln = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { mln = p1' }
         and pln = pln { sln = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in (r', pln)
cogent_g64ln : Struct_Cogent_ros2 -> ( (), Struct_Cogent_ros2 )
cogent_g64ln pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = pln
         and pln { sub = p0' } = v2'
         and v3' = p0'
         and p0' { mro = p1' } = v3'
         and v4' = p1'
         and v5' = v1'
         and (v6', p1') = (v5', v5')
         and p0' = p0' { mro = p1' }
         and pln = pln { sub = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)
cogent_g64ro : Struct_Cogent_ros2 -> ( (CPtr U32)!, Struct_Cogent_ros2 )
cogent_g64ro pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v' = pln
         and pln { sub = p0' } = v'
         and v1' = p0'
         and p0' { mro = p1' } = v1'
         and v2' = p1'
         and p0' = p0' { mro = p1' }
         and pln = pln { sub = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in (r', pln)

-- Probe used by accessing an array element
cogent_g71ln : Cogent_roa1 -> ( (), Cogent_roa1 )
cogent_g71ln pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = 5
         and v2' = 1
         and v1' = pln
         and (pln @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and v4' = v'
         and (v5', p0') = (v4', v4')
         and pln = pln @{ @i0' = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_g71ro : Cogent_roa1 -> U32
cogent_g71ro pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pln = pln @{ @i0' = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in r'
cogent_g72ln : Cogent_roa2 -> ( (), Cogent_roa2 )
cogent_g72ln pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v3' = 1
         and v2' = pln
         and (pln @{ @v3' = p0' }
             , i0') = (v2', v3')
         and v4' = p0'
         and v5' = v1'
         and (v6', p0') = (v5', v5')
         and pln = pln @{ @i0' = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)
cogent_g72ro : Cogent_roa2 -> (CPtr U32)!
cogent_g72ro pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pln = pln @{ @i0' = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in r'
cogent_g73ln : Cogent_roa3 -> ( (), Cogent_roa3 )
cogent_g73ln pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v3' = 1
         and v2' = pln
         and (pln @{ @v3' = p0' }
             , i0') = (v2', v3')
         and v4' = p0'
         and v5' = v1'
         and (v6', p0') = (v5', v5')
         and pln = pln @{ @i0' = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)
cogent_g73ro : Cogent_roa3 -> CPtr U32
cogent_g73ro pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pln = pln @{ @i0' = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in r'
cogent_g74ln : Cogent_roa3 -> ( (), Cogent_roa3 )
cogent_g74ln pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = 5
         and v2' = 1
         and v1' = pln
         and (pln @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and p0' { cont = p1' } = v3'
         and v4' = p1'
         and v5' = v'
         and (v6', p1') = (v5', v5')
         and p0' = p0' { cont = p1' }
         and pln = pln @{ @i0' = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)
cogent_g74ro : Cogent_roa3 -> U32
cogent_g74ro pln =
   let (c', r', pln) = let (v3'
                           , pln) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and p0' { cont = p1' } = v2'
         and v3' = p1'
         and p0' = p0' { cont = p1' }
         and pln = pln @{ @i0' = p0' }
         in (v3', pln)
      in (3, v3', pln)
   in r'
cogent_g75ln : Cogent_roa3 -> U32
cogent_g75ln pln =
   let (c', r', pln) = let (v4'
                           , pln) = let v' = cogent_fcln
         and v2' = 1
         and v1' = pln
         and (pln @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and pln = pln @{ @i0' = p0' }
         and v4' = v' v3'
         in (v4', pln)
      in (3, v4', pln)
   in r'
cogent_g75ro : Cogent_roa3 -> U32
cogent_g75ro pln =
   let (c', r', pln) = let (v4'
                           , pln) = let v' = cogent_fcro
         and v2' = 1
         and v1' = pln
         and (pln @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and pln = pln @{ @i0' = p0' }
         and v4' = v' v3'
         in (v4', pln)
      in (3, v4', pln)
   in r'
cogent_g76ln : ( Cogent_roa3, GlobState1 ) -> ( (), GlobState1 )
cogent_g76ln (pln, g) =
   let (c', pln, g) = let (v6'
                          , pln
                          , g) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pln = pln @{ @i0' = p0' }
         and v3' = g
         and g { cont = p1' } = v3'
         and v4' = p1'
         and v5' = v2'
         and (v6', p1') = (v5', v5')
         and g = g { cont = p1' }
         in (v6', pln, g)
      in (0, pln, g)
   in ((), g)
cogent_g76ro : ( Cogent_roa3, GlobState2 ) -> ( (), GlobState2 )
cogent_g76ro (pln, g) =
   let (c', pln, g) = let (v6'
                          , pln
                          , g) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pln = pln @{ @i0' = p0' }
         and v3' = g
         and g { cont = p1' } = v3'
         and v4' = p1'
         and v5' = v2'
         and (v6', p1') = (v5', v5')
         and g = g { cont = p1' }
         in (v6', pln, g)
      in (0, pln, g)
   in ((), g)
cogent_g77ln : ( Cogent_roa3, CPtr U32 ) -> ( (), CPtr U32 )
cogent_g77ln (pln, qln) =
   let (c', pln, qln) = let (v5'
                            , pln
                            , qln) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pln = pln @{ @i0' = p0' }
         and v3' = qln
         and v4' = v2'
         and (v5', qln) = (v4', v4')
         in (v5', pln, qln)
      in (0, pln, qln)
   in ((), qln)
cogent_g77ro : ( Cogent_roa3, (CPtr U32)! ) -> U32
cogent_g77ro (pln, qro) =
   let (c', pln, qro, r') = let (c'
                                , pln
                                , qro) = let (v5'
                                             , pln
                                             , qro) = let v1' = 1
            and v' = pln
            and (pln @{ @v1' = p0' }
                , i0') = (v', v1')
            and v2' = p0'
            and pln = pln @{ @i0' = p0' }
            and v3' = qro
            and v4' = v2'
            and (v5', qro) = (v4', v4')
            in (v5', pln, qro)
         in (0, pln, qro)
      in if c' > 0
         then (c', pln, qro, r')
         else let (c'
                  , r'
                  , qro) = let (v7'
                               , qro) = let v6' = qro
                  and qro { cont = p1' } = v6'
                  and v7' = p1'
                  and qro = qro { cont = p1' }
                  in (v7', qro)
               in (3, v7', qro)
            in (c', pln, qro, r')
   in r'
cogent_g78ln : Cogent_roa3 -> CPtr U32
cogent_g78ln pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pln = pln @{ @i0' = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in r'
cogent_g78ro : Cogent_roa3 -> (CPtr U32)!
cogent_g78ro pln =
   let (c', r', pln) = let (v2'
                           , pln) = let v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and pln = pln @{ @i0' = p0' }
         in (v2', pln)
      in (3, v2', pln)
   in r'
cogent_g79ln : ( Cogent_roa3, CPtr U32, U32 ) -> ( U32, CPtr U32 )
cogent_g79ln (pln, qln, i) =
   let (c', r', pln) = let (v7'
                           , pln) = let v' = cogent_fcro
         and v1' = i
         and v5' = qln
         and (v6', pln) = if v1'
            then let v3' = 1
               and v2' = pln
               and (pln @{ @v3' = p0' }
                   , i0') = (v2', v3')
               and v4' = p0'
               and pln = pln @{ @i0' = p0' }
               in (v4', pln)
            else (v5', pln)
         and v7' = v' v6'
         in (v7', pln)
      in (3, v7', pln)
   in (r', qln)
cogent_g79ro : ( Cogent_roa3, (CPtr U32)!, U32 ) -> U32
cogent_g79ro (pln, qro, i) =
   let (c', r', pln) = let (v7'
                           , pln) = let v' = cogent_fcro
         and v1' = i
         and v5' = qro
         and (v6', pln) = if v1'
            then let v3' = 1
               and v2' = pln
               and (pln @{ @v3' = p0' }
                   , i0') = (v2', v3')
               and v4' = p0'
               and pln = pln @{ @i0' = p0' }
               in (v4', pln)
            else (v5', pln)
         and v7' = v' v6'
         in (v7', pln)
      in (3, v7', pln)
   in r'

cogent_g81ln : Cogent_roa4 -> ( (), Cogent_roa4 )
cogent_g81ln pln =
   let (c', pln) = let (v7'
                       , pln) = let v' = 5
         and v4' = 1
         and v2' = 1
         and v1' = pln
         and (pln @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and (p0' @{ @v4' = p1' }
             , i1') = (v3', v4')
         and v5' = p1'
         and v6' = v'
         and (v7', p1') = (v6', v6')
         and p0' = p0' @{ @i1' = p1' }
         and pln = pln @{ @i0' = p0' }
         in (v7', pln)
      in (0, pln)
   in ((), pln)
cogent_g81ro : Cogent_roa4 -> U32
cogent_g81ro pln =
   let (c', r', pln) = let (v4'
                           , pln) = let v3' = 1
         and v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and (p0' @{ @v3' = p1' }
             , i1') = (v2', v3')
         and v4' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pln = pln @{ @i0' = p0' }
         in (v4', pln)
      in (3, v4', pln)
   in r'
cogent_g82ln : Cogent_roa5 -> ( (), Cogent_roa5 )
cogent_g82ln pln =
   let (c', pln) = let (v8'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v5' = 1
         and v3' = 1
         and v2' = pln
         and (pln @{ @v3' = p0' }
             , i0') = (v2', v3')
         and v4' = p0'
         and (p0' @{ @v5' = p1' }
             , i1') = (v4', v5')
         and v6' = p1'
         and v7' = v1'
         and (v8', p1') = (v7', v7')
         and p0' = p0' @{ @i1' = p1' }
         and pln = pln @{ @i0' = p0' }
         in (v8', pln)
      in (0, pln)
   in ((), pln)
cogent_g82ro : Cogent_roa5 -> (CPtr U32)!
cogent_g82ro pln =
   let (c', r', pln) = let (v4'
                           , pln) = let v3' = 1
         and v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and (p0' @{ @v3' = p1' }
             , i1') = (v2', v3')
         and v4' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pln = pln @{ @i0' = p0' }
         in (v4', pln)
      in (3, v4', pln)
   in r'
cogent_g83ln : Cogent_roa6 -> ( (), Cogent_roa6 )
cogent_g83ln pln =
   let (c', pln) = let (v8'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v5' = 1
         and v3' = 1
         and v2' = pln
         and (pln @{ @v3' = p0' }
             , i0') = (v2', v3')
         and v4' = p0'
         and (p0' @{ @v5' = p1' }
             , i1') = (v4', v5')
         and v6' = p1'
         and v7' = v1'
         and (v8', p1') = (v7', v7')
         and p0' = p0' @{ @i1' = p1' }
         and pln = pln @{ @i0' = p0' }
         in (v8', pln)
      in (0, pln)
   in ((), pln)
cogent_g83ro : Cogent_roa6 -> CPtr U32
cogent_g83ro pln =
   let (c', r', pln) = let (v4'
                           , pln) = let v3' = 1
         and v1' = 1
         and v' = pln
         and (pln @{ @v1' = p0' }
             , i0') = (v', v1')
         and v2' = p0'
         and (p0' @{ @v3' = p1' }
             , i1') = (v2', v3')
         and v4' = p1'
         and p0' = p0' @{ @i1' = p1' }
         and pln = pln @{ @i0' = p0' }
         in (v4', pln)
      in (3, v4', pln)
   in r'

-- probe assigned to struct component or array element
cogent_g91ln : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_g91ln pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = pln
         and pln { mln = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and pln = pln { mln = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_g91ro : Struct_Cogent_ros1 -> ( (), Struct_Cogent_ros1 )
cogent_g91ro pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v2' = pln
         and pln { mro = p0' } = v2'
         and v3' = p0'
         and v4' = v1'
         and (v5', p0') = (v4', v4')
         and pln = pln { mro = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_g92ln : Cogent_roa3 -> ( (), Cogent_roa3 )
cogent_g92ln pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v3' = 1
         and v2' = pln
         and (pln @{ @v3' = p0' }
             , i0') = (v2', v3')
         and v4' = p0'
         and v5' = v1'
         and (v6', p0') = (v5', v5')
         and pln = pln @{ @i0' = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)
cogent_g92ro : Cogent_roa2 -> ( (), Cogent_roa2 )
cogent_g92ro pln =
   let (c', pln) = let (v6'
                       , pln) = let v' = cogent_frln
         and v1' = v' ()
         and v3' = 1
         and v2' = pln
         and (pln @{ @v3' = p0' }
             , i0') = (v2', v3')
         and v4' = p0'
         and v5' = v1'
         and (v6', p0') = (v5', v5')
         and pln = pln @{ @i0' = p0' }
         in (v6', pln)
      in (0, pln)
   in ((), pln)

-- banging in nested bang positions
cogent_nst11 : ( Struct_Cogent_ros1, U32 ) -> ( Struct_Cogent_ros1, Struct_Cogent_ros1 )
cogent_nst11 (pln, i) =
   let (c', pln, i, r') = let (c'
                              , pln
                              , i) = let (v4'
                                         , pln
                                         , i) = let v' = pln
            and pln { mrg = p0' } = v'
            and v1' = p0'
            and pln = pln { mrg = p0' }
            and v2' = i
            and v3' = v1'
            and (v4', i) = (v3', v3')
            in (v4', pln, i)
         in (0, pln, i)
      in if c' > 0
         then (c', pln, i, r')
         else let (c', pln, r') = let (c'
                                      , pln) = let (v10'
                                                   , pln) = let v5' = i
                     and v6' = pln
                     and pln { mln = p1' } = v6'
                     and v7' = p1'
                     and p1' { cont = p2' } = v7'
                     and v8' = p2'
                     and v9' = v5'
                     and (v10', p2') = (v9', v9')
                     and p1' = p1' { cont = p2' }
                     and pln = pln { mln = p1' }
                     in (v10', pln)
                  in (0, pln)
               in if c' > 0
                  then (c', pln, r')
                  else let (c'
                           , r') = let v11' = pln
                        in (3, v11')
                     in (c', pln, r')
            in (c', pln, i, r')
   in (r', pln)
cogent_nst12 : ( Struct_Cogent_ros1, U32 ) -> ( Struct_Cogent_ros1, Struct_Cogent_ros1 )
cogent_nst12 (pln, i) =
   let (c', pln, i, r') = let (c'
                              , pln
                              , i) = let (v4'
                                         , pln
                                         , i) = let v' = pln
            and pln { mrg = p0' } = v'
            and v1' = p0'
            and pln = pln { mrg = p0' }
            and v2' = i
            and v3' = v1'
            and (v4', i) = (v3', v3')
            in (v4', pln, i)
         in (0, pln, i)
      in if c' > 0
         then (c', pln, i, r')
         else let (c'
                  , pln
                  , i
                  , r') = let (c'
                              , pln
                              , i) = let (v10'
                                         , pln
                                         , i) = let v5' = pln
                     and pln { mro = p1' } = v5'
                     and v6' = p1'
                     and p1' { cont = p2' } = v6'
                     and v7' = p2'
                     and p1' = p1' { cont = p2' }
                     and pln = pln { mro = p1' }
                     and v8' = i
                     and v9' = v8' + v7'
                     and (v10', i) = (v9', v9')
                     in (v10', pln, i)
                  in (0, pln, i)
               in if c' > 0
                  then (c', pln, i, r')
                  else let (c', pln, r') = let (c'
                                               , pln) = let (v16'
                                                            , pln) = let v11' = i
                              and v12' = pln
                              and pln { mln = p3' } = v12'
                              and v13' = p3'
                              and p3' { cont = p4' } = v13'
                              and v14' = p4'
                              and v15' = v11'
                              and (v16', p4') = (v15', v15')
                              and p3' = p3' { cont = p4' }
                              and pln = pln { mln = p3' }
                              in (v16', pln)
                           in (0, pln)
                        in if c' > 0
                           then (c', pln, r')
                           else let (c'
                                    , r') = let v17' = pln
                                 in (3, v17')
                              in (c', pln, r')
                     in (c', pln, i, r')
            in (c', pln, i, r')
   in (r', pln)

-- banging in binding sequences
cogent_bs11 : ( Struct_Cogent_ros1, U32 ) -> ( Struct_Cogent_ros1, Struct_Cogent_ros1 )
cogent_bs11 (pln, i) =
   let (c', r', pln, i) = let (v11'
                              , pln
                              , i) = let v' = pln
         and pln { mrg = p0' } = v'
         and v1' = p0'
         and pln = pln { mrg = p0' }
         and v2' = i
         and v3' = v1'
         and (v4', i) = (v3', v3')
         and v5' = i
         and v6' = pln
         and pln { mln = p1' } = v6'
         and v7' = p1'
         and p1' { cont = p2' } = v7'
         and v8' = p2'
         and v9' = v5'
         and (v10', p2') = (v9', v9')
         and p1' = p1' { cont = p2' }
         and pln = pln { mln = p1' }
         and v11' = pln
         in (v11', pln, i)
      in (3, v11', pln, i)
   in (r', pln)
cogent_bs12 : ( Struct_Cogent_ros1, (CPtr U32)!, U32 ) -> ( Struct_Cogent_ros1, Struct_Cogent_ros1 )
cogent_bs12 (pln, qro, i) =
   let (c'
       , r'
       , pln
       , qro
       , i) = let (v15'
                  , pln
                  , qro
                  , i) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and pln = pln { mln = p0' }
         and v2' = qro
         and v3' = v1'
         and (v4', qro) = (v3', v3')
         and v5' = qro
         and qro { cont = p1' } = v5'
         and v6' = p1'
         and qro = qro { cont = p1' }
         and v7' = i
         and v8' = v6'
         and (v9', i) = (v8', v8')
         and v10' = i
         and v11' = pln
         and pln { mrg = p2' } = v11'
         and v12' = p2'
         and v13' = v10'
         and (v14', p2') = (v13', v13')
         and pln = pln { mrg = p2' }
         and v15' = pln
         in (v15', pln, qro, i)
      in (3, v15', pln, qro, i)
   in (r', pln)
cogent_bs13 : ( Struct_Cogent_ros1, (CPtr U32)!, MayNull (CPtr U32) ) -> ( Struct_Cogent_ros1, Struct_Cogent_ros1, MayNull (CPtr U32) )
cogent_bs13 (pln, qro, i) =
   let (c'
       , r'
       , pln
       , qro
       , i) = let (v16'
                  , pln
                  , qro
                  , i) = let v' = pln
         and pln { mln = p0' } = v'
         and v1' = p0'
         and pln = pln { mln = p0' }
         and v2' = qro
         and v3' = v1'
         and (v4', qro) = (v3', v3')
         and v5' = qro
         and qro { cont = p1' } = v5'
         and v6' = p1'
         and qro = qro { cont = p1' }
         and v7' = i
         and i { cont = p2' } = v7'
         and v8' = p2'
         and v9' = v6'
         and (v10', p2') = (v9', v9')
         and i = i { cont = p2' }
         and v11' = i
         and v12' = pln
         and pln { mln = p3' } = v12'
         and v13' = p3'
         and v14' = v11'
         and (v15', p3') = (v14', v14')
         and pln = pln { mln = p3' }
         and v16' = pln
         in (v16', pln, qro, i)
      in (3, v16', pln, qro, i)
   in (r', pln, i)

-- Direct use of NULL in context
cogent_n11ln : () -> U32
cogent_n11ln () =
   let (c'
       , r') = let v2' = let v' = cogent_fcln
         and v1' = cogent_NULL
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_n11ro : () -> U32
cogent_n11ro () =
   let (c'
       , r') = let v2' = let v' = cogent_fcro
         and v1' = cogent_NULL
         and v2' = v' v1'
         in v2'
      in (3, v2')
   in r'
cogent_n14ln : ( MayNull (CPtr U32), U32 ) -> ( U32, MayNull (CPtr U32) )
cogent_n14ln (qln, i) =
   let (c'
       , r') = let v5' = let v' = cogent_fcln
         and v1' = i
         and v2' = cogent_NULL
         and v3' = qln
         and v4' = if v1'
            then v2'
            else v3'
         and v5' = v' v4'
         in v5'
      in (3, v5')
   in (r', qln)
cogent_n14ro : ( MayNull (CPtr U32), U32 ) -> ( U32, MayNull (CPtr U32) )
cogent_n14ro (qln, i) =
   let (c'
       , r') = let v5' = let v' = cogent_fcro
         and v1' = i
         and v2' = cogent_NULL
         and v3' = qln
         and v4' = if v1'
            then v2'
            else v3'
         and v5' = v' v4'
         in v5'
      in (3, v5')
   in (r', qln)

-- NULL assigned to variable
cogent_n21ln : GlobState1 -> ( (), GlobState1 )
cogent_n21ln g =
   let (c', g) = let (v4'
                     , g) = let v' = cogent_NULL
         and v1' = g
         and g { cont = p0' } = v1'
         and v2' = p0'
         and v3' = v'
         and (v4', p0') = (v3', v3')
         and g = g { cont = p0' }
         in (v4', g)
      in (0, g)
   in ((), g)
cogent_n21ro : GlobState2 -> ( (), GlobState2 )
cogent_n21ro g =
   let (c', g) = let (v4'
                     , g) = let v' = cogent_NULL
         and v1' = g
         and g { cont = p0' } = v1'
         and v2' = p0'
         and v3' = v'
         and (v4', p0') = (v3', v3')
         and g = g { cont = p0' }
         in (v4', g)
      in (0, g)
   in ((), g)
cogent_n22ln : MayNull (CPtr U32) -> ( (), MayNull (CPtr U32) )
cogent_n22ln pln =
   let (c', pln) = let (v3'
                       , pln) = let v' = cogent_NULL
         and v1' = pln
         and v2' = v'
         and (v3', pln) = (v2', v2')
         in (v3', pln)
      in (0, pln)
   in ((), pln)
cogent_n22ro : (MayNull ((CPtr U32)!))! -> U32
cogent_n22ro pro =
   let (c', pro, r') = let (c'
                           , pro) = let (v3'
                                        , pro) = let v' = cogent_NULL
            and v1' = pro
            and v2' = v'
            and (v3', pro) = (v2', v2')
            in (v3', pro)
         in (0, pro)
      in if c' > 0
         then (c', pro, r')
         else let (c'
                  , r'
                  , pro) = let (v5'
                               , pro) = let v4' = pro
                  and pro { cont = p0' } = v4'
                  and v5' = p0'
                  and pro = pro { cont = p0' }
                  in (v5', pro)
               in (3, v5', pro)
            in (c', pro, r')
   in r'

-- NULL returned as result
cogent_n31ln : () -> MayNull (CPtr U32)
cogent_n31ln () =
   let (c'
       , r') = let v' = cogent_NULL
      in (3, v')
   in r'
cogent_n31ro : () -> (MayNull ((CPtr U32)!))!
cogent_n31ro () =
   let (c'
       , r') = let v' = cogent_NULL
      in (3, v')
   in r'

-- Using NULL twice
cogent_n41lnln : () -> U32
cogent_n41lnln () =
   let (c'
       , r') = let v6' = let v' = cogent_fcln
         and v1' = cogent_NULL
         and v2' = v' v1'
         and v3' = cogent_fcln
         and v4' = cogent_NULL
         and v5' = v3' v4'
         and v6' = v2' + v5'
         in v6'
      in (3, v6')
   in r'
cogent_n42lnro : () -> U32
cogent_n42lnro () =
   let (c'
       , r') = let v6' = let v' = cogent_fcln
         and v1' = cogent_NULL
         and v2' = v' v1'
         and v3' = cogent_fcro
         and v4' = cogent_NULL
         and v5' = v3' v4'
         and v6' = v2' + v5'
         in v6'
      in (3, v6')
   in r'
cogent_n43roro : () -> U32
cogent_n43roro () =
   let (c'
       , r') = let v6' = let v' = cogent_fcro
         and v1' = cogent_NULL
         and v2' = v' v1'
         and v3' = cogent_fcro
         and v4' = cogent_NULL
         and v5' = v3' v4'
         and v6' = v2' + v5'
         in v6'
      in (3, v6')
   in r'

-- NULL assigned to struct component or array element
cogent_n91ln : MayNull Struct_Cogent_ros1 -> ( (), MayNull Struct_Cogent_ros1 )
cogent_n91ln pln =
   let (c', pln) = let (v4'
                       , pln) = let v' = cogent_NULL
         and v1' = pln
         and pln { mln = p0' } = v1'
         and v2' = p0'
         and v3' = v'
         and (v4', p0') = (v3', v3')
         and pln = pln { mln = p0' }
         in (v4', pln)
      in (0, pln)
   in ((), pln)
cogent_n91ro : MayNull Struct_Cogent_ros1 -> ( (), MayNull Struct_Cogent_ros1 )
cogent_n91ro pln =
   let (c', pln) = let (v4'
                       , pln) = let v' = cogent_NULL
         and v1' = pln
         and pln { mro = p0' } = v1'
         and v2' = p0'
         and v3' = v'
         and (v4', p0') = (v3', v3')
         and pln = pln { mro = p0' }
         in (v4', pln)
      in (0, pln)
   in ((), pln)
cogent_n92ln : Cogent_roa3 -> ( (), Cogent_roa3 )
cogent_n92ln pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = cogent_NULL
         and v2' = 1
         and v1' = pln
         and (pln @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and v4' = v'
         and (v5', p0') = (v4', v4')
         and pln = pln @{ @i0' = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
cogent_n92ro : Cogent_roa2 -> ( (), Cogent_roa2 )
cogent_n92ro pln =
   let (c', pln) = let (v5'
                       , pln) = let v' = cogent_NULL
         and v2' = 1
         and v1' = pln
         and (pln @{ @v2' = p0' }
             , i0') = (v1', v2')
         and v3' = p0'
         and v4' = v'
         and (v5', p0') = (v4', v4')
         and pln = pln @{ @i0' = p0' }
         in (v5', pln)
      in (0, pln)
   in ((), pln)
