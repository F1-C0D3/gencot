The goal of this step is to translate a single C source file which is part of the translation set to Cogent.
This is done by first using Gencot to translate the file to Cogent with embedded partially translated C code,
and then manually translating the embedded C code.

The translated file is either a \code{.c} file which can be seperately compiled by the C compiler as a compilation unit,
or it is a \code{.h} file which is a part of one or more compilation units by being included by other files. In both cases
the file can include \code{.h} files, both in the package and standard C include files such as \code{stdio.h}.

\subsection{Automatic Translation by Gencot}
\label{app-trans-auto}

To be translated by Gencot the C source file must first be prepared for being read by Gencot as described in
Section~\ref{app-prep}. Then the parameter modification descriptions for all functions and function types defined 
in the source file must be created and evaluated as described in Section~\ref{app-parmod-defined}. 

A \code{.c} file is translated using the command
\begin{verbatim}
  gencot [options] cfile file.c [<parmod>]
\end{verbatim}
where \code{file.c} is the file to be translated and \code{<parmod>} is the file containing the parameter modification 
descriptions. If it is not provided, Gencot assumes for all functions and function types, that linear parameters 
may be modified. The result of the translation is stored as \code{file.cogent} in the current directory.

An \code{.h} file is translated using the command
\begin{verbatim}
  gencot [options] hfile file.h [<parmod>]
\end{verbatim}
where \code{file.h} is the file to be translated and \code{<parmod>} is as above. The result of the translation is 
stored as \code{file-incl.cogent} in the current directory.

Special support is provided for translating configuration files. A configuration file is a \code{.h} file mainly
containing preprocessor directives for defining flags and macros, some of which are deactivated by being ``commented
out'', i.e., they are preceded by \code{//}. If such a file is translated using the command
\begin{verbatim}
  gencot [options] config file.h [<parmod>]
\end{verbatim}
it is translated like a normal \code{.h} file, but before, all \code{//} comment starts at line beginnings are 
removed, and afterwards the corresponding Cogent comment starts \code{--} are re-inserted before the definitions.

\subsection{Manual Translation of C Function Bodies}
\label{app-trans-manbody}

The manual part of the translation is mainly required for the bodies of all C functions defined in the C source file.
A \code{.h} file normally does not contain function or object definitions, then it may be the case that no manual actions 
are necessary. But some \code{.h} files define functions, typically as \code{static inline}, then also their bodies
must be translated manually.

The manual translation is done by modifying the \code{.cogent} file generated by the automatic translation in an 
editor. As described in Section~\ref{design-fundefs-body}, the result of automatically translating a function
definition has the form
The generated Cogent function definition has the form
\begin{verbatim}
  <name> :: (<ptype1>, ..., <ptypen>) -> <restype>
  <name> (<pname1>, ..., <pnamen>) = <dummy result>
  {- <compound statement> -}
\end{verbatim}
where the \code{<compound statement>} is plain C code with global names mapped to Cogent. The task of the manual
translation is to replace the \code{<dummy result>} by a Cogent expression equivalent to the \code{<compound statement>}.

In the following sections we provide some patterns how to translate typical C constructs occurring in a
\code{<compound statement>}.

\subsection{Function Pointer Invocation}
\label{app-trans-funpointer}

In C a function pointer may be \code{NULL}, therefore it is typically tested for being valid before the
referenced function is invoked, such as in 
\begin{verbatim}
  if( fptr == NULL ) ...
  else fptr( params );
\end{verbatim}
We assume that fptr shall have a type which is binary compatible to the function pointer type in C.
This prevents to use a Cogent type \code{Option a} as the natural equivalent of a value that may be undefined.
\code{Option a} is a Cogent variant type and is not binary equivalent to the C function pointer type.

If \code{fptr} is a member of a C struct, it would be possible to use a Cogent recored with a taken field,
if the function pointer is undefined. Then it would be clear from the record type whether the function pointer
is valid and can be invoked. However, this would require two implementations for all functions with such a records 
as parameter, which is usually infeasible.

The simplest solution is to assume that function pointers are always defined. Instead of using the value 
\code{NULL}, they must then be set to point to a default function. Then no test is required, the function
can simply be invoked in Cogent.

Note that to be binary compatible the Cogent type of \code{fptr} is an abstract type of the form \code{\#F\_...}.
To invoke the referenced function the translation function \code{invk\_F\_...} must be used (see 
Section~\ref{design-types-function}). 

For example, if the function pointer is declared in C as 
\begin{verbatim}
  int (*fptr)(int p1, const char *p2);
\end{verbatim}
the corresponding invocation in Cogent would be
\begin{verbatim}
  invk_F_'U32'RP_U8'_U32 (fptr,arg1,arg2)
\end{verbatim}
with result type \code{U32}.

\subsection{The Address Operator \code{\&}}
\label{app-trans-addrop}

The address operator \code{\&} is used in C to determine a pointer to data which is not yet accessed through a 
pointer. The main use cases are
\begin{itemize}
\item determine a pointer for a local or global variable as in the example
\begin{verbatim}
  int i = 5;
  int *ptr = &i;
\end{verbatim}

\item determine a pointer for a member in a struct as in the example
\begin{verbatim}
  struct ii { int i1; int i2; } s = {17,4};
  int *ptr = &(s.i2);
\end{verbatim}

determine a pointer to a function as in the example
\begin{verbatim}
  int f(int p) { return p+1; }
  ...
  int *ptr = &f;
\end{verbatim}
\end{itemize}

In all these cases the pointer is typically used as reference to pass it to other functions or store it
in a data structure.

The binary compatible Cogent equivalent of the pointer is a value of a linear type. However, there is
no Cogent functionality to create such values. Hence it must be implemented by an abstract function.

In the first use case there are several problems with this approach. First, there is no true equivalent
for C variables in Cogent. Second, it is not possible to pass the variable to the implementation of the
abstract function, without determining its address using the address operator. Third, if the address
operator is applied to the variable in the implementation of the abstract function, the Isabelle c-parser
will not be able to process the abstract function, since it only supports the address operator when 
the result is a heap address.

All these problems can be solved by allocating the variable on the heap instead. Then the variable definition
must be replaced by a call to the (abstract) creation function for the corresponding linear type 
(see Section~\ref{design-types-pointer}) and 
at the end of its scope a call to the (abstract) discarding function must be added. Then the address
operator need not be translated, since the creation function already returns the linear value which can be 
used for the same purposes. The resulting Cogent code would be
\begin{verbatim}
  let ptr = create_P_U32 5
  in free_P_U32(...ptr...)
\end{verbatim}
where the argument of \code{free\_P\_U32} is an expression which uses and returns the \code{ptr} in the 
usual way for a value of linear type.

The second use case cannot be translated in this way, since the referenced data is a part of a larger structure.
If it is separated from the structure and allocated on the heap, the structure is not binary compatible any more.

If the overall structure is not allocated on the heap, the same three problems apply as in the first use case.
This can be solved in the same way, by moving the overall structure to the heap. Then it can be represented
by the linear Cogent type
\begin{verbatim}
  type Struct_Cogent_ii = { i1: U32, i2: U32 }
\end{verbatim}
and it is possible to define and implement abstract functions
\begin{verbatim}
  take_i2 : Struct_Cogent_ii -> (P_U32, Struct_Cogent_ii take i2)
  put_i2 : (P_U32, Struct_Cogent_ii take i2) -> Struct_Cogent_ii
\end{verbatim}
The first one is implemented in C by applying the address operator to the member \code{i2} of its argument
and return it together with the argument. The second function is implemented by simply returning the second 
tuple member. 

Using a partial record type here is not necessary, but it makes the code safer, since the member \code{i2}
cannot be accessed as long as the type has not been changed to the full record type again, which should be 
done by \code{put\_i2}, discarding the pointer. However, it is possible to apply any other explicit \code{put}
operation which writes the member \code{i2} while the pointer still exists, causing the shared content to
be overwritten. To prevent this it must be proven for the Cogent program that no \code{put} operation for field 
\code{i2} is applied to the result of \code{take\_i2} until it is restored by \code{put\_i2}.

An alternative implementation of \code{take\_i2} would allocate a new copy of member \code{i2} on the heap
and return this heap pointer as first result component. The implementation of \code{put\_i2} would copy the 
value back from the heap and free the heap entry. Then no sharing can occur and the program has the 
same type safety properties as a usual Cogent program. However, the copying makes it less efficient.

In both cases the Cogent code has the form
\begin{verbatim}
  let (ptr,s') = take_i2 s
  in put_i2 (...ptr...,s')
\end{verbatim}
where the first argument of \code{put\_i2} is an expression which uses and returns the \code{ptr} in the 
usual way for a value of linear type.

If the overall structure in Cogent is readonly the \code{take\_i2} function cannot be used, since it modifies
the structure. For this case a function 
\begin{verbatim}
  takeRO_i2 : Struct_Cogent_ii! -> P_U32!
\end{verbatim}
can be used. It returns the member as readonly, thus it is safe since neither the member nor the structure
can be modified.

The third use case is translated in a specific way for function pointers, using the translation function
\code{to\_F\_...} (see Section~\ref{design-types-function}), which is generated by Gencot for all function
pointer types. The resulting Cogent code has the form
\begin{verbatim}
  Cogent_f : U32 -> _U32
  Cogent_f p = p+1
  ...
  let ptr = to_F_'U32'_U32 Cogent_f
  in ...
\end{verbatim}
In this case \code{ptr} has the nonlinear type \code{\#F\_'U32'\_U32} in Cogent and may freely be copied and
discarded in its scope.

\subsection{Using Pointers for Array Access}
\label{app-trans-arrpoint}

A common pattern in C programs is to explicitly use a pointer type instead of an array type for referencing an array,
in particular if the array is allocated on the heap. This is typically done if the number of elements in the
array is not statically known at compile time. The C concept of variable length array types can sometimes be
used for a similar purpose, but is restricted to function parameters and local variables and cannot be used for
structure members.

In C the array subscription operator can be applied to terms of pointer type. The semantics is to access an element 
in memory at the specified offset after the element referenced by the pointer. This makes it possible to use 
a pointer as struct member which references an array as in
\begin{verbatim}
  struct ip {... int *p, ...} s;
\end{verbatim}
and access the array elements using the subscription operator as in \code{s.p[i]}.

Gencot translates the struct type to a record type of the form
\begin{verbatim}
  type Struct_Cogent_ip = {... p: P_U32, ...}
\end{verbatim}
and does not generate abstract functions which allow to treat \code{p} as an array, this must be done manually.

The main problem here is the unknown array size. In the C program, however, for working with the array it must be
possible to determine the array size in some way at runtime. Here we distinguish two approaches how this is done.

In the first case the array size can always be determined from the array content. Then the pointer to the first 
element is always sufficient for working with the array. The two typical patterns of this kind either use a 
stop element to mark the array end, such as the zero character ending C strings, or store the array size in a
specific element or elements, such as in a network package represented as a byte array.

Working with the array is supported by manually defining and implementing an abstract data type for the array as follows.
Let \code{tt} be a unique name for the specific kind of array (how its size is determined) and let \code{El} be the
name of the array element type. We use \code{CArray\_tt\_El} as type name for the array, thus the 
type of \code{p} must be manually changed as follows:
\begin{verbatim}
  type Struct_Cogent_ip = {... p: CArray_tt_El, ...}
\end{verbatim}

Then the abstract functions for the array type are defined in the same way as for the mapped array types as described in
Section~\ref{design-types-array}. The functions for creating and disposing arrays are:
\begin{verbatim}
  create_CArray_tt_El : U32 -> TCArray_tt_El
  dispose_CArray_tt_El : TCArray_tt_El -> ()
\end{verbatim}
where the \code{create}-function takes the actual array size (number of elements) as argument. The type 
\code{TCArray\_tt\_El} is used for the uninitialized array, corresponding abstract functions for initializing
and freeing the array elements must be provided.

The element access functions in the case of a non-linear element type are:
\begin{verbatim}
  get_CArray_tt_El : (CArray_tt_El!,U32) -> Option El
  put_CArray_tt_El : (CArray_tt_El,U32,El) -> CArray_tt_El
\end{verbatim}
and for a linear element type:
\begin{verbatim}
  replacein_CArray_tt_El : (CArray_tt_El,U32,El) -> (CArray_tt_El,El)
  modifyin_CArray_tt_El : (CArray_tt_El,U32,#F_'El'_El) -> CArray_tt_El
  get_CArray_tt_El : (CArray_tt_El!,U32) -> Option El!
\end{verbatim}

The implementation in antiquoted C has the following form:
\begin{verbatim}
  typedef el *CArray_tt_El, *TCArray_tt_El;
  
  $ty:TCArray_tt_El $id:create_CArray_tt_El($ty:U32 size) { 
    return calloc(size,sizeof(el));
  }
  $ty(()) $id:dispose_CArray_tt_El($ty:TCArray_tt_El arr) {
    free(arr); return $exp(());
  }
  ...
\end{verbatim}

In the second case the array size is determined by additional information seperate from the pointer to the array.
Either the size is specified as an integer value as in 
\begin{verbatim}
  struct ip {... int *p, int psize; ...} s;
\end{verbatim}
or it is specified by a second pointer, e.g., pointing to the last element as in
\begin{verbatim}
  struct ip {... int *p, int *pend; ...} s;
\end{verbatim}
In general there may be additional information, such as pointers into the array which are used to reference
``current'' positions in the array. We assume that all this information is provided by a sequence of members
in the surrounding struct:
\begin{verbatim}
  struct ip {...; t1 m1;...tn mn; ...} s;
\end{verbatim}
When working with the array all additional information is required, therefore it must be included in the abstract
type. This is achieved by replacing the sequence of variables containing information about the array by a single
field of the array type in Cogent:
\begin{verbatim}
  type Struct_Cogent_ip = {... a: #CArray_tt_El, ...}
\end{verbatim}
with the array type being defined in C as
\begin{verbatim}
  typedef struct { t1 m1;...tn mn; } CArray_tt_El;
\end{verbatim}
This makes the Cogent type \code{Struct\_Cogent\_ip} binary compatible with the C type \code{struct ip} and it allows
to represent several groups of related members in the struct by a common abstract type. Of course this approach is 
only possible if the members are contiguous in the struct.

To access the group in the struct the abstract functions
\begin{verbatim}
  take_a: Struct_Cogent_ip -> (CArray_tt_El, Struct_Cogent_ip take a)
  put_a: (CArray_tt_El, Struct_Cogent_ip take a) -> Struct_Cogent_ip
\end{verbatim}
are used in the same way as described in Section~\ref{app-trans-addrop}.

The abstract functions for working with the array now look different from those above, since type \code{CArray\_tt\_El}
does not correspond to a pointer to the array elements, but to a pointer to the substructure with members describing
the array. The specific form and functionality of these functions depend on the actual members and their use.
