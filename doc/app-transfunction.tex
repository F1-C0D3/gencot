The manual part of the translation is mainly required for the bodies of all C functions defined in the C source file.
A \code{.h} file normally does not contain function or object definitions, then it may be the case that no manual actions 
are necessary. But some \code{.h} files define functions, typically as \code{static inline}, then also their bodies
must be translated manually.

The manual translation is done by modifying the \code{.cogent} file generated by the automatic translation in an 
editor. As described in Section~\ref{design-fundefs-body}, the result of automatically translating a function
definition has the form
\begin{verbatim}
  <name> :: (<ptype1>, ..., <ptypen>) -> <restype>
  <name> (<pname1>, ..., <pnamen>) = <dummy result>
  {- <compound statement> -}
\end{verbatim}
where the \code{<compound statement>} is plain C code with global names mapped to Cogent. The task of the manual
translation is to replace the \code{<dummy result>} by a Cogent expression equivalent to the \code{<compound statement>}.

In the following sections we provide some rules and patterns how to translate typical C constructs occurring in a
\code{<compound statement>}. These rules and patterns are not exhaustive but try to cover most of the common cases.

\subsection{General}
\label{app-transfunction-general}

The basic building blocks of C function bodies are declarations and statements. Here we only cover declarations of 
local variables. Such a declaration specifies a name for the local variable and optionally an initial value.

A C statement causes modifications in its context. Cogent, as a functional language, does not support this concept,
in particular, it does not support modifying the value of a variable. Cogent only supports expressions which functionally
depend on their input, and it supports introducing immutable variables by binding them to a value. 
The main task of translating function bodies is to translate C statements to Cogent expressions.

The main idea of the translation is to translate a C variable which is modified to a sequence of bindings of Cogent
variables to the values stored in the C variable over time. Everytime when a C statement modifies a variable, a new
variable is introduced in Cogent and bound to the new value. A major difference of both approaches is that in Cogent 
the old variable and its value are still available after the modification. To prevent this, we use the same name for
both variables. Then the new variable ``shadows'' the old one in its scope, making the old value unaccessible there.
For example the C code
\begin{verbatim}
  int i = 0; i = i+1; ...
\end{verbatim}
is translated to
\begin{verbatim}
  let i = 0 in let i = i+1 in ...
\end{verbatim}
where the single C variable \code{i} is translated to two Cogent variables which are both named \code{i}.

\subsubsection{Statements}

A C statement in a function can modify several of the following:
\begin{itemize}
\item function parameters
\item local variables
\item global variables
\end{itemize}
All of them are specified by an identifier which is unique at the position of the statement. The modification
may replace the value as a whole or only modify one or more parts in the case of a structured value.

As a first step modifications of global variables must be eliminated by passing all such variables as additional 
parameters to the function and returning them as additional component in the result. Then a modification of a
global variable becomes a modification of a function parameter and only the first two cases remain.

After this step the effect of the modification caused by a C statement can be described by a set of identifiers 
of all modified parameters and local variables together with the new values for them. Syntactically this corresponds
to a Cogent \textit{binding} of the form
\begin{verbatim}
  (id1,...,idn) = expr
\end{verbatim}
where \code{expr} is a Cogent expression for the tuple of new values for the identifiers.

\subsubsection{Pointers}

Cogent treats C pointers in a special way as values of ``linear type'' and guarantees that no memory is shared
among different values of these types. More general, all values which may contain pointers (such as a struct with
some pointer members) have this property. All other values are of ``nonlinear type'' and never have common parts 
in C.

If a C program uses sharing between values of linear type, it cannot be translated directly to Cogent. We use 
the following approach for a translation of such cases. 

If several parameters of a function may share common memory, they are grouped together to a Cogent record or
abstract data type and treated as a single parameter. All functions which operate on one of the values are
changed to operate on the group value. Then no sharing occurs between the remaining function parameters.

If several local variables share common memory they can be treated in the same way. 

If a variable shares memory with a parameter this solution is not applicable. In this case the variable must be
eliminated. This is easy if the variable is only used as a shortcut to a part of the parameter value, then it
can be replaced by explicit access to the part of the parameter. For example, in the C function
\begin{verbatim}
  void f (struct{int i; x *p;} p1) {
    x *v = p1.p; ...
  }
\end{verbatim}
the occurrences of variable \code{v} can be replaced by accesses to \code{p1.p}. 
In other cases individual solutions must be found. Note that parameters and variables of nonlinear type never
cause such problems.

After these steps no sharing occurs among the parameters and local variables in the function. This implies that 
a C statement can only modify parameters and variables for which the identifiers occur literally in the statement
source code text. Thus it is possible to determine the effect of the modification caused by a C statement
syntactically from the statement.

\subsubsection{Variable Declarations}

An initializer \code{init} in a variable declaration \code{t v = init;} is either an expression or an initializer for
a struct or an array. The C declaration can be rewritten as
\begin{verbatim}
  t v;
  v = init;
\end{verbatim}
with a separate statement for initializing the variable. In the first case this is valid C code. In the other cases 
the statement is not, but we will translate it according to the intended semantics. For a struct type Cogent provides
corresponding expressions for unboxed records, for an array type Gencot provides the function \code{initArr} for
simple cases or the initialization can be done by several applications of \code{setArr} (see Section~\ref{design-operations-array}).

A declaration without an initializer should always be followed by an assignment to it before it is accessed. If not
we insert an assignment of a default value before the first access.

Then the declarations need not be translated to Cogent, since in Cogent a new variable is introduced whenever
the C variable is modified by a statement. Therefore, only the C statements need to be translated to Cogent.

\subsection{Expressions}
\label{app-transfunction-expr}

C statements usually have C expressions as syntactic parts. For translating C statements the contained C expressions must be 
translated. C expressions have a value but may also cause modifications as side effects. Especially, in C an assignment
is syntactically an expression. C expressions are translated depending on whether they have side effects or not.

\subsubsection{Expressions without Side Effects}

C expressions without side effects are literals, variable references, member accesses of the form \code{s.m} or 
\code{s->m}, index
expressions of the form \code{a[e]}, applications of binary operators of the form \code{e1 op e2}, 
applications of the unary operators \code{+,-,!,~} of the form \code{op e}, and function 
call expressions of the form \code{f(e1,...,en)}, if all subexpressions
\code{s,a,e,f,e1,...,en} have no side effects and function \code{f} does not modify its parameter values. 

These expressions are translated to Cogent expressions in a straightforward way with the same or a similar syntax.
A member access \code{s->m} is translated as \code{s.m}. An index expression \code{a[e]} is translated as function 
call \code{getArr(a,e)}. Note, that some C operators have a different form in Cogent:
\begin{verbatim}
  C  Cogent
  !=   /=
  ^    .^.
  &    .&.
  |    .|.
  !    not
  ~    complement
\end{verbatim}

Member accesses of the form \code{s->m} (or written \code{(*s).m}) and index expressions \code{a[e]} can only be 
translated in this way if the
container value \code{s} or \code{a}, respectively, is translated to a readonly value in Cogent. If it is a parameter,
variable, or record field, it may have been defined as readonly. Otherwise, it can be made readonly in the expression's
context by applying the bang operator \code{!} to it at the end of the context:
\begin{verbatim}
  ... s.m ...  !s
\end{verbatim}
The resulting expressions are also of readonly type. For expressions of nonlinear type this is irrelevant, for expressions
of linear type it implies that they cannot be modified. If they are used in C by modifying them, they must be translated
in a different way. For example in the C code fragment
\begin{verbatim}
  *(s->p) = 5
\end{verbatim}
the expression \code{s->p} denotes a pointer which is modified, therefore it cannot be translated to \code{s.m} where 
s is readonly.

For resultig expressions of linear types, using the bang operator \code{!} also means that the readonly result cannot
escape from the banged context, it can only be used inside the context.

Translation of expressions using the address operator \code{\&} are described in Section~\ref{app-transfunction-addrop}.

Dereferencing (application of the indirection operator \code{*} to) a pointer is translated depending on the type of value referenced by 
the pointer. If it points to a function, \code{*p} is translated as \code{fromFunPtr(p)} 
(See Section~\ref{design-operations-function}). 

If it points to a primitive type, an enum type, or again a pointer type, 
\code{*p} is translated as \code{getPtr(p)} (See Section~\ref{design-operations-pointer}). In this case \code{p} 
must be readonly as above, and the result is readonly. If it should be modified it must be translated differently.

Otherwise it points to a type which is mapped to Cogent as a record or abstract type. Then \code{*p} is translated as \code{p}. 

Expressions using the C operators \code{sizeof} or \code{\_Alignof} cannot be translated to Cogent. Usually, an abstract
function implemented in C is required here.

\subsubsection{Expressions with Side Effects}

We translate an expression with side effects to a Cogent binding of the form \code{pattern = expr}. Here, the
\code{pattern} is a tuple of variables \code{(v,v1,...,vn)} or a single variable \code{v}. The variable \code{v} is a
new variable which is not already bound in the context of the expression, it is used to bind the result value of the
expression. The other variables are the identifiers of all parameters and local variables modified by the expression.
The \code{expr} is a Cogent expression for a tuple consisting of the result value of the C expression and the new values
of the identifiers modified by the C expression.

If the result value of the expression is the same as the new value of one of the modified identifiers the new variable
is omitted. Then, if only one identifier is modified by the expression, the pattern consists of the single modified variable 
\code{v1}.

Expressions with side effects are applications of the increment and decrement operators \code{++,--}, assignments,
and invocations of functions which modify one or more parameter values.

Applications of increment and decrement operators must be rewritten in C using assignments. Assignments using assignment
operators other than \code{=} must be rewritten in C using the \code{=} operator. After these steps the only 
remaining expressions with side effects are assignments using \code{=} and invocations of functions which modify parameter 
values.

If for such an expression all subexpressions are without side effects, they are translated as follows. 

The translation of an assignment expression of the form \code{lhs = e} depends on the form of \code{lhs}. If it is
a single identifier \code{v} (name of a parameter or local variable), it is translated as
\begin{verbatim}
  v = e
\end{verbatim}
If \code{lhs} is a logical chain of member access, index, and dereferencing expressions starting with identifier \code{v} 
(name of a parameter or local variable), the most general translation is
\begin{verbatim}
  v = fst(modify1(v,(modify2,(...(modifyn,(setPtr,e))...))))
\end{verbatim}
where the sequence of \code{modifyi} functions is determined by the chain of access expressions.
For example the C assignment expression
\begin{verbatim}
  s->a[i]->x = 5
\end{verbatim}
is translated according to this rule to the Cogent binding
\begin{verbatim}
  s = fst(modrefAInS(s,(modifyArr,(i,setXInEl,5))))
\end{verbatim}
where \code{modrefAInS} and \code{setXInEl} are abstract modification functions for the fields \code{a} and \code{x},
respectively, as described in Section~\ref{design-operations-record}.

No other cases for \code{lhs} are valid in a C assignment.

If \code{lhs} logically starts with a chain of member accesses \code{v->m1->...->mn...} an alternative translation using the Cogent
take and put operations is the binding
\begin{verbatim}
  v = let v{m1=m1{m2=...mn-1{mn}...}} 
      in v{m1=m1{m2=...mn-1{mn=expr}...}}
\end{verbatim}
where \code{mn=expr} is the binding to which \code{mn... = e} is translated, if \code{mn} is assumed to be a local variable. 
For example, a corresponding translation of \code{*(s->m1->m2) = 5} is
\begin{verbatim}
  s = let s{m1} and m1{m2}
      in s{m1=m1{m2=setPtr(m2,5)}}
\end{verbatim}
This approach avoids the need to manually define and implement the functions \code{modifyMiIn...}.

A C function which modifies parameter values is translated by Gencot to a Cogent function returning the tuple \code{(y,p1,...,pn)}
of the original function result \code{y} and the modified parameter values \code{p1,...,pn} (which must be pointers). 
A C function call \code{f(...)} is
translated depending on the form of the actual arguments passed to \code{f} for the modified parameters.

If all such arguments are identifiers (names of parameters and local variables) the function call is translated to
the binding
\begin{verbatim}
  (y,p1,...,pn) = f(...)
\end{verbatim}
where \code{y} is a new Cogent variable not already bound in the context.

If some of the arguments are member access chains of the form \code{vi->mi1->...->miki} they must be translated using the 
Cogent take and put operations as above to a binding of the form
\begin{verbatim}
  (y,v1,...,vn) = 
  let v1{m11=...{m1k1}...}
  and ... 
  and vn{mn1=...{mnkn}...}
  and (y,m1k1,...,mnkn)=f(...)
  in (y,v1{m11=...{m1k1=m1k1}...},
       ...
        vn{mn1=...{mnkn=mnkn}...})
\end{verbatim}
where in the arguments of \code{f} the chains are replaced by their last member name \code{miki}.

For example, the function call \code{f(5,s->m,t->n,z)} where \code{f} modifies its second and third parameter, is translated
to the binding
\begin{verbatim}
  (y,s,t) = 
  let s{m}
  and t{n}
  and (y,m,n)=f(5,m,n,z)
  in (y,s{m=m},t{n=n})
\end{verbatim}

If function \code{f} modifies only one parameter \code{p} of Cogent type \code{P} its standard type generated by
Gencot can be modified to the form of a modification function
\begin{verbatim}
  f: ModFun P (...) Res
\end{verbatim}
where \code{(...)} is the tuple of types of the other parameters and \code{Res} is the result type. Then for an arbitrary
chain of member access, index, and dereferencing expressions used as actual argument for \code{p} the function call 
can be translated to a binding of the form
\begin{verbatim}
  (v,y) = modify1(v,(modify2,(...(modifyn,(f,(a1,...,an)))...)))
\end{verbatim}
where the sequence of \code{modifyi} functions is determined by the chain of access expressions. Note
that now \code{y} is the second component in the tuple pattern due to the way \code{ModFun} is defined.

For example, the function call \code{f(5,s->a[i]->x,z)} can be translated by first modifying the translation of 
\code{f} so that it takes as parameters instead of the tuple \code{(a,b,c)} the pair \code{(b,(a,c))}. Then a translation
for the function call is
\begin{verbatim}
  (s,y) = modrefAInS(s,(modifyArr,(i,modifyXInEl,(f,(5,z)))))
\end{verbatim}
Again, if the chain logically starts with member accesses, that part of the chain can be translated using take and put operations.

In all other cases the function \code{f} must be modified so that it takes the starting identifiers of the chains as
arguments instead of the chains, then it can be translated as in the first case where all actual arguments are identifiers.
Note that different translations of the function to Cogent may be required for translating different function calls.

\subsubsection{Nested Expressions with Side Effects}

\subsubsection{Readonly Access and Modification of the Same Value}


\subsection{Statements}
\label{app-transfunction-stat}

\subsubsection{Simple Statements}

A simple C statement consists of a C expression, where the result is discarded. Therefore it makes only sense
if the C expression has side effects.

The translation of a simple C statement \code{e;} is the binding resulting from the translation of the expression \code{e},
as described in Section~\ref{app-transfunction-expr}.




If \code{lhs} is a member access \code{r.m} or \code{r->m} it can be translated using a Cogent put operation:
\begin{verbatim}
  let r = r{m = <E>} in ...
\end{verbatim}
Again, the \code{r} on the left and on the right are different variables in Cogent, the former is bound to the 
record after the assignment, the latter is bound to the old record value.

If \code{<e>} evaluates to a pointer (not a function pointer), \code{m} has linear type in Cogent and the put
operation may only be applied if the field \code{m} has been taken in the old record value. If it is not taken, the
statement cannot be translated directly to Cogent. Only if \code{r->m} is used once in \code{<e>} the take operation
can be provided as part of the translation:
\begin{verbatim}
  let r{m} = r and r = r{m = <Em>} in ...
\end{verbatim}
The binding \code{r{m} = r} is the take operation and binds the taken field value to the local variable \code{m}.
The expression \code{<Em>} must be the translation of \code{<e>} with the access \code{r->m} replaced by \code{m}.
For example the translation of the statement \code{r->p = f(r->p);} is
\begin{verbatim}
  let r{p} = r and r = r{p = f(p)} in ...
\end{verbatim}

More generally, if \code{lhs} denotes a part of a structured value \code{s}, the assignment can be translated using
a chain of modification functions, as described in Section~\ref{design-operations-concept}. The side effect is
that \code{s} is modified, therefore the translation has the general form
\begin{verbatim}
  let s = fst(modify...(s,...)) in ...
\end{verbatim}
where the standard Cogent function \code{fst} is needed because all modification functions return a pair of the modified
object and an additional result. According to this schema a translation of the assignment \code{a[5] = 0;} is
\begin{verbatim}
  let a = fst(modifyArr(a,(5,setPtr,0)) in ...
\end{verbatim}
where \code{setPtr} (see Section~\ref{design-operations-pointer}) is applied to a pointer to the 5th element of \code{a}
and the value \code{0}.

\subsubsection{Return Statements}

A C return statement has the form \code{return;} or \code{return <e>;}. It is always the last statement in the surrounding
control flow. It must be translated to a Cogent expression for the result of the surrounding function. The first form can
only be used in functions returning \code{void}, these are translated to Cogent as returning \code{()}. 

Hence, if the function has no side effects, translations for both forms are
\begin{verbatim}
  ()
  <E>
\end{verbatim}
For example, the C function
\begin{verbatim}
  int f(int i) { return i+1; }
\end{verbatim}
is translated to the Cogent function
\begin{verbatim}
  f: U32 -> U32
  f i = i+1
\end{verbatim}

If the function has side effects it returns a tuple of the modified objects together with the result of the C function.
Then the return statement is preceded by statements with side effects. These are 
translated by binding the new values of the modified objects to local variables \code{o1,...,on}. The translations 
for both forms of the return statement are
\begin{verbatim}
  (o1,...,on)
  (<E>,o1,...,on)
\end{verbatim}
since Gencot appends the additional return values after the original result value.

\subsubsection{Statement Sequences}

\subsubsection{Conditional Statements}

\subsubsection{For Loops}

\subsubsection{While Loops}


\subsection{Function Pointer Invocation}
\label{app-transfunction-pointer}

In C a function pointer may be \code{NULL}, therefore it is typically tested for being valid before the
referenced function is invoked, such as in 
\begin{verbatim}
  if( fptr == NULL ) ...
  else fptr( params );
\end{verbatim}
We assume that fptr shall have a type which is binary compatible to the function pointer type in C.
This prevents to use a Cogent type \code{Option a} as the natural equivalent of a value that may be undefined.
\code{Option a} is a Cogent variant type and is not binary equivalent to the C function pointer type.

If \code{fptr} is a member of a C struct, it would be possible to use a Cogent record with a taken field,
if the function pointer is undefined. Then it would be clear from the record type whether the function pointer
is valid and can be invoked. However, this would require two implementations for all functions with such a records 
as parameter, which is usually infeasible.

The generic type \code{MayNull} (see Section~\ref{app-transfunction-null} cannot be used for function pointers since
it is linear and the corresponding abstract functions expect values of the boxed type, whereas function pointers
are always represented by an unboxed type.

The simplest solution is to assume that function pointers are always defined. Instead of using the value 
\code{NULL}, they must then be set to point to a default function. Then no test is required, the function
can simply be invoked in Cogent.

Note that to be binary compatible the Cogent type of \code{fptr} is an abstract type of the form \code{\#F\_...}.
To invoke the referenced function the translation function \code{fromFunPtr} must be used (see 
Section~\ref{design-operations-function}). 

For example, if the function pointer is declared in C as 
\begin{verbatim}
  int (*fptr)(int arg1, const char *arg2);
\end{verbatim}
the corresponding invocation in Cogent would be
\begin{verbatim}
  (fromFunPtr fptr) (arg1,arg2)
\end{verbatim}
with result type \code{U32}.

\subsection{The Null Pointer}
\label{app-transfunction-null}

Translating C code which uses the null pointer is supported by the abstract data type \code{MayNull} defined
in \code{include/gencot/MayNull.cogent} (see Section~\ref{design-operations-null}).

A typical pattern in C is a guarded access to a member of a struct referenced by a pointer:
\begin{verbatim}
  if (p != NULL) res = p->m;
\end{verbatim}
In Cogent the value \code{p} has type \code{MayNull R} where \code{R} is the record type with field \code{m}. 
Then a translation to Cogent is
\begin{verbatim}
  let res = roNotNull p 
            | None -> dflt
            | Some s -> s.m
      !p
\end{verbatim}
Note that a value \code{dflt} must be selected here to bind it to res if the pointer is \code{NULL}. Also note that the access is
done in a banged context for p. Therefore it is only possible if the type of \code{m} is not linear, since otherwise the result
cannot escape from the context.

Another typical pattern in C is a guarded modification of the referenced structure:
\begin{verbatim}
  if (p != NULL) p->m = v;
\end{verbatim}
A translation to Cogent is
\begin{verbatim}
  let p' = notNull p 
           | None -> null ()
           | Some s -> mayNull s{m = v}
\end{verbatim}
where the reference to the modified structure is bound to \code{p'}. Note that in the None-case the result cannot be specified as 
\code{p} since this would be a second use of the linear value \code{p} which is prevented by Cogent.

Alternatively this can be translated using the function \code{modifyNull}:
\begin{verbatim}
  let p' = fst (modifyNull (p, (setMInP, v)))
\end{verbatim}
where the function used for modifying the structure is defined as
\begin{verbatim}
  setMInP: ModFun P M ()
  setMInP (s,v) = (s{m = v}, ())
\end{verbatim}
and \code{M} is the type of field \code{m}.

\subsection{The Address Operator \code{\&}}
\label{app-transfunction-addrop}

The address operator \code{\&} is used in C to determine a pointer to data which is not yet accessed through a 
pointer. The main use cases are
\begin{itemize}
\item determine a pointer to a local or global variable as in the example
\begin{verbatim}
  int i = 5;
  int *ptr = &i;
\end{verbatim}

\item determine a pointer to a member in a struct as in the example
\begin{verbatim}
  struct ii { int i1; int i2; } s = {17,4};
  int *ptr = &(s.i2);
\end{verbatim}

\item determine a pointer to an array elemnt as in the example
\begin{verbatim}
  int arr[20];
  int *ptr = &(arr[5]);
\end{verbatim}

determine a pointer to a function as in the example
\begin{verbatim}
  int f(int p) { return p+1; }
  ...
  int *ptr = &f;
\end{verbatim}
\end{itemize}

In all these cases the pointer is typically used as reference to pass it to other functions or store it
in a data structure.

The binary compatible Cogent equivalent of the pointer is a value of a linear type. However, there is
no Cogent functionality to create such values. Hence it must be implemented by an abstract function.

\subsubsection{Address of Variable}

In the first use case there are several problems with this approach. First, there is no true equivalent
for C variables in Cogent. Second, it is not possible to pass the variable to the implementation of the
abstract function, without first determining its address using the address operator. Third, if the address
operator is applied to the variable in the implementation of the abstract function, the Isabelle c-parser
will not be able to process the abstract function, since it only supports the address operator when 
the result is a heap address.

All these problems can be solved by allocating the variable on the heap instead. Then the variable definition
must be replaced by a call to the polymorphic function \code{create} (see Section~\ref{design-operations-pointer}) and 
at the end of its scope a call to the polymorphic function \code{dispose} must be added. Then the address
operator need not be translated, since \code{create} already returns the linear value which can be 
used for the same purposes. The resulting Cogent code would be
\begin{verbatim}
  let ptr = initPtr[PTRINIINST(U32,)] (create(), 5)
  and ... use ptr ...
  in dispose (fst clearPtr[PTRCLRINST(U32,,,)](ptr,()))
\end{verbatim}
where \code{initPtr} is used to initialize the referenced value. \code{clearPtr} is only used for consistency
with the general framework, it does nothing here since values of type U32 can be discarded.

\subsubsection{Address of Struct Member}

The second use case cannot be translated in this way, since the referenced data is a part of a larger structure.
If it is separated from the structure and allocated on the heap, the structure is not binary compatible any more.

If the overall structure is not allocated on the heap, the same three problems apply as in the first use case.
This can be solved in the same way, by moving the overall structure to the heap. Then it can be represented
by the linear Cogent type
\begin{verbatim}
  type Struct_Cogent_ii = { i1: U32, i2: U32 }
\end{verbatim}

If the overall structure in Cogent is readonly an abstract function of the form
\begin{verbatim}
  accessI2InCogent_ii : Struct_Cogent_ii! -> P_U32!
\end{verbatim}
can be used to access the Cogent field through a pointer. This is an instance of the general \code{access} operation
for records as described in Section~\ref{design-operations-record}.

If the overall structure is modifyable, determining a pointer to the field would introduce sharing for the
field, since it can be modified through the pointer or by modifying the structure. A safe solution is an 
abstract function of the form
\begin{verbatim}
  modifyI2InCogent_ii : all(arg,out). 
    ModPartFun Struct_Cogent_ii P_U32 arg out
\end{verbatim}
which is an instance of the general \code{modify} operation
for records as described in Section~\ref{design-operations-record}.

\subsubsection{Address of Array Element}

The third use case is similar to the second. It often occurs if the array itself is represented by a pointer to its first
element (see Section~\ref{app-transtype-arrpoint}). This case can simply be replaced by using the element index instead of a 
pointer to the element. The array index is nonlinear and thus easier to work with. However, this solution is not binary
compatible, if the element pointer is also accessed outside the Cogent compilation unit.

A binary compatible solution can be achieved in a similar way as for struct members. The first prerequisite for it is
to allocate the array on the heap.

Then the polymorphic functions \code{accessArr} and \code{modifyArr} (see Section~\ref{design-operations-array}) can be used
for working with pointers to elements.

\subsubsection{Address of Function}

The last use case is translated in a specific way for function pointers, using the translation function
\code{toFunPtr} (see Section~\ref{design-operations-function}), which is generated by Gencot for all function
pointer types. The resulting Cogent code has the form
\begin{verbatim}
  Cogent_f : U32 -> U32
  Cogent_f p = p+1
  ...
  let ptr = toFunPtr[_,#F_'U32'_U32] Cogent_f
  in ...
\end{verbatim}
In this case \code{ptr} has the nonlinear type \code{\#F\_'U32'\_U32} in Cogent and may freely be copied and
discarded in its scope.

