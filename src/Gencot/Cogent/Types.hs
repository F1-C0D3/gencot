{-# LANGUAGE PackageImports #-}
module Gencot.Cogent.Types where

import Data.List (find)

import Cogent.Surface as CS
import Cogent.Common.Syntax as CCS
import Cogent.Common.Types (readonly,bangSigil,Sigil(Unboxed),RecursiveParameter(NonRec))

import Gencot.Cogent.Ast -- includes unitType
import Gencot.Origin (noOrigin)

-- Construct Types
------------------

mkU8Type :: GenType
mkU8Type = GenType (CS.TCon "U8" [] Unboxed) noOrigin

mkU32Type :: GenType
mkU32Type = GenType (CS.TCon "U32" [] Unboxed) noOrigin

mkStringType :: GenType
mkStringType = GenType (CS.TCon "String" [] Unboxed) noOrigin

mkBoolType :: GenType
mkBoolType = GenType (CS.TCon "Bool" [] Unboxed) noOrigin

mkTupleType :: [GenType] -> GenType
mkTupleType ts = GenType (CS.TTuple ts) noOrigin

mkCtlType :: GenType
mkCtlType = mkU8Type

mkFunType :: GenType -> GenType -> GenType
mkFunType rt pt = GenType (CS.TFun pt rt) noOrigin

mkRecordType :: [(CCS.FieldName,GenType)] -> GenType
mkRecordType fts = GenType (CS.TRecord NonRec (map (\(f,t) -> (f,(t,False))) fts) Unboxed) noOrigin

mkTakeType :: Bool -> GenType -> [CCS.FieldName] -> GenType
mkTakeType b (GenType (CS.TRecord rp fs s) o) tfs =
    GenType (CS.TRecord rp fs' s) o
    where fs' = map (\fld@(fn, (tp, tk)) -> if elem fn tfs then (fn,(tp,b)) else fld) fs

mkArrTakeType :: Bool -> GenType -> [GenExpr] -> GenType
mkArrTakeType b (GenType (CS.TArray eltp siz s tels) o) es =
    GenType (CS.TArray eltp siz s (tels' b)) o
    where tels' True = (map (\e -> (e,True)) es) ++ tels
          tels' False = filter (\tel -> not $ elem (fst tel) es) tels

-- Access Types
---------------

mkReadonly :: GenType -> GenType
mkReadonly (GenType (CS.TRecord rp fs s) o) = (GenType (CS.TRecord rp fs $ bangSigil s) o)
mkReadonly (GenType (CS.TCon tn ts s) o) = (GenType (CS.TCon tn ts $ bangSigil s) o)
mkReadonly (GenType (CS.TVar v _ ub) o) = (GenType (CS.TVar v True ub) o)
mkReadonly (GenType (CS.TArray t e s ts) o) = (GenType (CS.TArray t e (bangSigil s) ts) o)
mkReadonly (GenType (CS.TTuple ts) o) = (GenType (CS.TTuple $ map mkReadonly ts) o)
mkReadonly t@(GenType (CS.TUnit) o) = t
-- no other types generated by Gencot.

getMemType :: CCS.FieldName -> GenType -> GenType
getMemType f (GenType (CS.TRecord _ fs s) _) =
    case find (\fld -> fst fld == f) fs of
         Nothing -> unitType
         Just (_,(t,_)) -> if readonly s then mkReadonly t else t

getElmType :: GenType -> GenType
getElmType (GenType (CS.TArray t _ s _) _) =
    if readonly s then mkReadonly t else t

getResultType :: GenType -> GenType
getResultType (GenType (CS.TFun _ rt) _) = rt
getResultType _ = unitType

