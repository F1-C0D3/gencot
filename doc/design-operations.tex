For working with the mapped C datatypes, in particular for those mapped to abstract Cogent types., Gencot provides support by
defining and implementing polymorphic Cogent functions, some of which are abstract and some of which are implemented in Cogent.

\subsection{Conceptual Operations}
\label{design-operations-concept}

Although the operations provided for different kinds of datatypes have different semantics, there have common properties
and are represented by common polymorphic functions. Here the operations are introduced conceptually, together with
the polymorphic functions. Gencot provides the polymorphic function definitions in separate Cogent files which can be
included in a Cogent source.

\subsubsection{Dummy Expressions}

For every mapped type Gencot defines a dummy expression of that type. It is used as a replacement for the actual 
body when translating C functions (see Section~\ref{design-fundefs}).

The dummy expression for all mapped numerical and enumeration types is the literal \code{0}.
The dummy expression for the unit type (used for functions which have \code{void} as result type) is the 
unit value \code{()}.

For all other types Gencot provides in \code{include/gencot/DummyExpr.cogent} the polymorphic abstract function
\begin{verbatim}
  gencotDummy: all(a). () -> a
\end{verbatim}
from the unit type to every possible Cogent type. Since the dummy expressions are intended to be eliminated before compiling the 
C code generated by the Cogent compiler, Gencot does not provide C definitions for this abstract function. 

If a function modifies parameters of linear type, it is translated by Gencot to return a tuple consisting of the 
original result and all such parameters (see Section~\ref{design-parmod}).
The dummy result expression is then built as a tuple with a dummy expression for the original result as the first component 
and the unmodified parameters as the remaining components.

\subsubsection{Default Values}

Conceptually, Gencot provides a default value for every regular non-function Cogent type. For the primitive numeric types it is 
\code{0}, for type \code{String} it is \code{""}, and for type \code{()} it is the unit value \code{()}.

For a regular tuple (which has no component of linear or readonly type) it is the tuple of default values. For a
regular unboxed record it is the record where all fields have their default value. For a regular variant type it is
the default value of the first variant.

Gencot defines the polymorphic abstract function
\begin{verbatim}
  defaultVal: all(out). () -> out
\end{verbatim}
in \code{include/gencot/Default.cogent}. 

Gencot provides instances for the numeric types \code{U8,U16,U32,U64} which return 0, for the unit type \code{()} which returns 
\code{()}, and for type \code{String} which returns \code{""}. 
Other instances must currently be defined manually, Gencot could be extended to provide automatic support for them as well.

\subsubsection{Creating and Disposing Boxed Values}

Since all pointer types are mapped to Cogent linear types, Cogent does not provide support for creating values
of these types (``boxed values''). In C a pointer can be created using the address operator \code{\&} or by allocating data on
the heap using a C standard function such as \code{malloc}. The address operator is supported by Gencot
only for data on the heap, as explained in Section~\ref{app-transfunction-addrop}. Therefore, the basic functionality
for pointer creation is allocation on the heap. This must be provided as an abstract Cogent function.

Since values of a linear type cannot be discarded in Cogent, another abstract Cogent function is required for
disposing such values, implemented by using the C standard function \code{free}.

Gencot provides the polymorphic abstract functions defined in \code{include/gencot/Memory.cogent}:
\begin{verbatim}
  create : all(evt). Heap -> Result (evt,Heap) Heap
  dispose : all(evt). (evt,Heap) -> Heap
\end{verbatim}
for creating and disposing values of linear types. Gencot provides instance implementations for all linear
types, i.e. all (boxed) record types and abstract types. \code{Heap} is an abstract data type for modelling
the C heap where the data structures are allocated, it is defined in \code{include/gencot/Memory.cogent}.
\code{Result} is a variant type defined in the Cogent standard library (usually abbreviated as \code{R})
with variants for the success and error cases. In the success case \code{create} returns the newly allocated 
boxed value and the modified heap, in the error case it only returns the heap.

The \code{create} instances only allocate space on the heap but do not initialize it. To model this property in 
Cogent, Gencot uses two different Cogent types for every linear type to represent uninitialized (``empty'') and 
initialized (``valid'') values.
Conceptually, the instances of \code{create} and \code{dispose} are only defined for the empty-value types.
The function \code{create} returns empty values, the function \code{dispose} expects empty values. In particular,
empty values cannot contain linear parts (pointers to other memory regions) and can thus be safely discarded by 
deallocating their memory space. 

Note that according to their definition, the functions \code{create} and \code{dispose} are defined for arbitrary
types \code{evt}. However, Gencot only provides instances for (empty-value) linear types. Since it is not possible
to express this type property in Cogent, the use of unsupported instances of both functions are not detected by the 
Cogent compiler.

\subsubsection{Modifying Values}

Record fields can be modified in Cogent by the put and take operations which in the simplest case have the form
\begin{verbatim}
  let r' = r { f = v } in ...
  let r' { f = p } = r in ...
\end{verbatim}
In the put operation \code{r} is the old record value, \code{f} is the field to be modified, \code{r'} is the 
new record value and \code{v} is the new field value. The type of \code{r'} is either the same as for \code{r} or it
differs, if field \code{f} was taken in \code{r}. In the take operation \code{r} is the old record value, \code{f} 
is the field to be taken, \code{r'} is the record without \code{f} and \code{p} is a pattern for binding the old 
field value. The type of \code{r'} is always different from that of \code{r}.

Here ``modifying'' the field can have several slightly different meanings. The field value may be initialized, replaced,
or removed, or it may be modified in-place, if it is a structured value. Modifying the field always modifies the 
containing record.

We generalize this idea to abstract types, by defining operations for modifying a part in the form of abstract functions.
To provide a common framework for modification operations, Gencot defines function types for such modification functions 
in \code{include/gencot/ModFun.cogent}. The basic function types are
\begin{verbatim}
  type ModTypeFun obj res arg out = (obj,arg) -> (res,out)
  type ModFun obj arg out = ModTypeFun obj obj arg out
\end{verbatim}
The first type covers the genaral case where the type of the new value is different from that of the old value, in the second
case the type is the same before and after the modification. In both cases a value of type \code{arg} is passed to the modification
function, it may provide information about how to modify the value, and the modification function additionally returns a value of
type \code{out}, e.g., an error code. The functions \code{fst} and \code{snd} defined in the Cogent standard library can be used
to retrieve the modified value and the additional output.

The put operation can now be represented as a function of type \code{ModTypeFun R (R put f) V ()} where \code{R} is the type of
\code{r} and \code{V} that of field \code{f} and value \code{v}. If the field is not taken in \code{R} the type is \code{ModFun R V ()}.
The take operation can be represented as a function of type \code{ModTypeFun R (R take f) () V}, it returns 
a pair of the remaining record and the taken field value.

For an abstract type \code{A} we can now define abstract functions with a similar semantics. We use another abstract type \code{TA}
which represents all values of \code{A} where the part is not present, and an arbitrary type \code{V} for the part. Then
a generalized put-function has the type \code{ModTypeFun TA A V ()} and a generalized take-function has the type
\code{ModTypeFun A TA () V}.

A typical pattern for modifying a record field is a combination of a take and a put operation of the form
\begin{verbatim}
  let r' { f = p } = r 
  and r'' = r' { f = m(p) }
\end{verbatim}
where a function \code{m} is used to determine the new field value from the old field value. We can generalize function
\code{m} to a modification function of type \code{ModFun V arg out} which takes additional input of type \code{arg} and
returns additional output of type \code{out}. Now we can define a function for the combined field modification as
\begin{verbatim}
  modify (r,(m,x)) = 
    let r' { f = p } = r
    and (v,y) = m(p,x)
    in (r' { f = v }, y)
\end{verbatim}
It has the function type \code{ModFun R (ModFun V arg out, arg) out}, accepts as additional input a pair of a modification
function for the field value and its additional input, and returns the modified record and the additional result of
the field modification function. Note that \code{modify} also respects the type constraints if the field type \code{V}
is linear. The field value is neither duplicated nor discarded. In this case an alternative semantics is that the field 
value modification function \code{m} modifies the field value in-place.

For this kind of modifying a part Gencot defines the corresponding generalized function type
\begin{verbatim}
  type ModPartFun obj prt arg out = ModFun obj (ModFun prt arg out, arg) out
\end{verbatim}
where \code{obj} is the type of the modified object, \code{prt} is the type of the part to be modified, \code{arg} is the type
of the information passed to the part modification function, and \code{out} is the type of additional output of both modification functions.

Since every \code{ModPartFun} is a \code{ModFun}, modification functions of this type can be chained to modify parts arbitrarily 
deep embedded in other parts. 

As an example, to modify a part \code{p} of type \code{P} in a part \code{q} of type \code{Q} in a value \code{r} of type \code{R}
an expression of the form
\begin{verbatim}
  modifyQInR (r, (modifyPInQ, (modifyP, arg)))
\end{verbatim}
modifies \code{p} by replacing it by \code{modifyP (p,arg)}. To make the modification functions generic for the type of the additional input
to the part modification function and for the type of its additional output they can be defined as polymorphic:
\begin{verbatim}
  modifyQInR: all(arg,out). ModPartFun R Q arg out
  modifyPInQ: all(arg,out). ModPartFun Q P arg out
  modifyP: ModFun P A O
\end{verbatim}

If the modification function \code{modifyP} needs as input information of nonlinear type from other linear parts of \code{q} or \code{r} it is not
possible to pass these parts to \code{modifyP}. For a record type \code{R} either they must be taken from \code{r} and put back in after the modification, then
the type of \code{r} is \code{R take (...)} and \code{modifyQInR} cannot be applied because of type incompatibility. Or the parts are
accessed as readonly in a banged context for \code{r}, then the readonly parts cannot escape from the banged context to be passed to the
modification operation (which must be outside of the banged context since it modifies \code{r}). Instead, the required nonlinear information must 
be retrieved from the linear parts in a banged context for \code{r}. Since it is nonlinear it may escape from the context and can be passed 
to the modification operation.

In C it is a common pattern to pass pointers to other parts of a data structure around for efficiency and access values through these pointers 
only when needed to modify parts of the structure. In the Cogent translation the values must be accessed separately in a banged context and then
passed to the modification operation.

\subsubsection{Initializing and Clearing Boxed Values}

Gencot uses the terms ``initialization'' and ``clearing'' for the conversions between empty and valid boxed values.
After a boxed value has been created it must be initialized to be used, before it is disposed it must be cleared.

Initialization must set every part of a structured value to a valid value. For parts of nonlinear type this is
straightforward, since values of nonlinear types can be directly denoted in Cogent programs in most cases. Parts
of unboxed record and abstract types are made valid by converting them to a boxed value and initializing it.

For parts of linear type there are two possible approaches: they can be created during initialization 
or they can be passed as arguments. If they are created, the initialization function needs the heap as additional 
in- and output. Otherwise it takes all parts of linear type as additional input. Of course, if several parts
of linear type exist, some of them can be created and some passed as arguments.

Parts of readonly type \code{S!} cannot be initialized by creating a value for them. If a value is created in the 
initialization function it must be banged there but then it may not leave the banged context. The readonly value 
must either be created by a function which returns a value of type \code{S!}, or it must be passed as argument
to the initialization function. Another solution is to use type \code{(MayNull S)!} (see Section~\ref{design-operations-null})
instead for the part and use \code{roNull()} as initial value. Then a readonly non-null value can be set later. 

Clearing must convert every part of a structured value to an empty value. For parts of nonlinear type nothing
needs to be done, or the value can be explicitly set to a default value to overwrite the stored information for
security reason. Parts of unboxed record and abstract types are made empty by converting them to a boxed value 
and clearing it. 

Parts of linear type, dually to initializing them, can be disposed during clearing, or they can be returned
as result. If they are disposed, the clearing function takes the heap as additional in- and output. Otherwise
it returns all parts of linear type as output. if several parts
of linear type exist, some of them can be disposed and some returned as results.

Parts of readonly type need no specific treatment during clearing, since they can be discarded in the same way as
parts of nonlinear type.

Gencot defines the following generic types in \code{Memory.cogent}:
\begin{verbatim}
  type IniFun evt vvt arg out = ModTypeFun evt vvt arg out
  type ClrFun vvt evt arg out = ModTypeFun vvt evt arg out
\end{verbatim}
They can be used by the developer to mark functions as initialization or clearing functions. This is purely 
informal since no constraint between the type parameters can be enforced by Cogent, so a correct pair of 
empty-value type and the corresponding valid-value type must be specified by the developer.

Initialization and clearing functions are defined by Gencot to always expect additional input and output values of 
arbitrary types \code{arg} and \code{out}. The input value can be used to specify default values to be used,
the heap for creating and disposing parts of linear type, and initialization and clearing 
functions for parts of the value. If a function only uses fixed default values and functions for parts 
the unit type \code{()} is used for type \code{arg}. The output value can be used to return an error code,
the modified heap, or parts of linear type which have not been disposed.

The additional input is also required for cases where Gencot automatically defines initialization and clearing
functions for types which may have parts of types for which Gencot does not define such functions. Then 
it cannot specify fixed initialization and clearing functions for the parts, the functions to be used must be
passed as arguments.

An initialization or clearing function for a type with several parts must handle all parts together because it must
transform from the empty-value type, where all parts are taken, to the valid-value type, where all parts are present.
If an initialization or clearing function handles only one part, its type must respect which other parts are 
taken and which are not. This is not feasible for types with many parts. However, if all parts must be handled together,
there are many ways how to do so, especially if there are parts of linear and/or readonly type. 

Gencot provides the following polymorphic abstract initialization and clearing functions which are defined for only 
some of these cases, determined by the types of the additional in- and output:
\begin{verbatim}
  init : IniFun evt vvt arg out
  clear : ClrFun vvt evt arg out
\end{verbatim}
Generally, these functions are only defined if \code{evt} is the empty-value type corresponding to the valid-value
type \code{vvt}. Moreover, one of the following three cases must be apply:
\begin{itemize}
\item Passing the full content as argument: type \code{arg} for \code{init} and type \code{out} for \code{clear} is the 
unboxed type \code{\#vvt}. It is used to pass all content for the referenced memory region to \code{init} which
copies it there. For \code{clear} it is used to return all content, in particular, all content of linear type, so that 
it is not discarded. Type \code{out} for \code{init} and type \code{arg} for \code{clear} must be \code{()}.
\item Passing the heap as argument: all types \code{arg} and \code{out} must be \code{Heap}. Additionally, \code{vvt}
must be escapeable (no readonly parts). In this case \code{init}
allocates all parts of linear type on the heap and \code{clear} disposes them. All parts of nonprimitive type are
initialized or cleared using function \code{init} or \code{clear}, respectively, in the same way passing the heap to 
it. All parts of primitive type are initialized to their default value \code{defaultVal ()} and are cleared by
doing nothing. 
\item Passing nothing: all types \code{arg} and \code{out} must be \code{()}. Moreover, \code{vvt} must be regular
(no linear or readonly parts). In this case \code{init} and \code{clear} work as when the heap is passed as argment, 
but the heap is not required since there are no linear parts which must be allocated or disposed.
\end{itemize}

The first case is the most general, it is applicable to all kinds of valid-value types \code{vvt}. However, it bears the
most overhead, since all content must be passed as argument and copied to the memory to be initialized. The other
two cases support ``in-place'' operation, however, they are more restrictive.

Gencot defines the following preprocessor macros for the three cases 


For specific types \code{vvt} custom initialization and clearing functions can be defined manually. Typically, they 
pass values for some parts as parameters (in particular those of readonly types), and use default values or heap
allocation for the others.





It would be possible for Gencot to provide initialization and clearing functions for every pair of empty-value
and valid-value types generated by mapping the types in the translated C program. However, in general there are 
several diffent ways how to initialize a specific data structure. Moerover, for types introduced manually the developer 
must implement initialization and clearing functions anyways. Therefore Gencot automatically generates
monomorphic initializing and clearing functions only for some types of boxed values.


\subsubsection{Accessing Parts of Structured Values}

All types generated by Gencot are either primitive, records, or abstract. For record and abstract types both 
unboxed and boxed types are generated. Abstract types may be used to represent structured C values.

For working with a structured value it is often necessary to access its parts for reading or modifying them.
Gencot supports the following conceptual operations on structured values:
\begin{description}
  \item[\code{get}] access the value of a part for reading,
  \item[\code{set}] replace the value of a part by a given value, discarding the old value,
  \item[\code{exchng}] replace the value of a part by a given value, returning the old value,
  \item[\code{modify}] apply a modification function in-place to a part.
\end{description}

Every function accesses only a single part of the structured value, if several parts must be accessed at the same
time other operations must be defined manually.

The actual function types of the operations differ depending on the way how the part is specified for them.
However, if the structured value has type \code{T} and the part has type \code{S} the conceptual functionalities 
are as follows:

The function \code{get} has functionality \code{T! -> S!}. It expects a readonly value as input and returns
a readonly copy of the part's value. This operation can be defined in Cogent for arbitrary types \code{S}
because the returned value can be shared with the value remaining in the structure since both are readonly.

An alternative to the function \code{get} would be a function which takes a modifyable structure and returns the structure
together with the element. However, this would be cumbersome in many applications and misleading for proofs, since 
the function never modifies the structure. 

The function \code{set} has functionality \code{(T,S) -> (T,())} which is equivalent to \code{ModFun T S ()}. 
It expects a structure and the new value as input
and returns a structure where only the value of the part has been replaced by the new value. The result value is 
structured as a pair, so that the function has the form of a modification function. Since the old
value of the part is discarded, function \code{set} is only defined if type \code{S} is discardable.

The function \code{exchng} has functionality \code{(T,S) -> (T,S)} which is equivalent to \code{ModFun T S S}. 
It works like \code{set}, but instead of
discarding the old value of the part it returns it in the result. This can be done for arbitrary types \code{S}
since values of this type are neither shared nor discarded.

The function \code{modify} has functionality \code{ModPartFun T S A O} where \code{A} and \code{O} are
arbitrary types.
According to the definition of \code{ModPartFun} \code{modify} applies a part modification function of
type \code{ModFun S A O} to modify the part. All types may be linear, since the corresponding values are
only passed through to the part modification function and back.
The part modification function determines the new part value from the old part value. If the part's type \code{S}
is linear it can be implemented by modifying the part's value ``in-place''. In particular, this can be done by
again using \code{modify} as part modification function modifying a part's part, as it has been described
for the function type \code{ModPartFun} above.

If the part's type \code{S} is not linear, function \code{modify} removes the part's value from the structure,
passes it to the part modification function and puts the result back into the structure. This is
inefficient for large parts when only a small subpart is modified, since the whole part value must be copied.
In C the typical way of dealing with this situation is to pass a pointer to the part modification function 
instead. Gencot supports this with the following two operations:
\begin{description}
  \item[\code{getref}] return a pointer to a part,
  \item[\code{modref}] apply a modification function in-place to a part.
\end{description}

The function \code{getref} has functionality \code{T! -> PS!} where \code{PS} is the mapped type used by Gencot
for pointer to \code{S}. If \code{S} is an unboxed record or abstract type \code{\#B} then \code{PS} is the
corresponding boxed type \code{B}. Otherwise \code{PS} is the type \code{P\_S} generated by Gencot for pointers
to values of type \code{S}. The function cannot be implemented in Cogent and is usually implemented in C using the address 
operator \code{\&}. The operation is safe since both the structure and the result type are readonly. The shared
memory used by both can neither be modified through the structure nor through the resulting pointer. 

The function \code{modref} has functionality \code{ModPartFun T PS A O} where \code{A} and \code{O} are
arbitrary types. It behaves like \code{modify} but uses a part modification function of
type \code{ModFun PS A O} to modify the part, which is passed as a pointer.
Note that the use of the pointer is safe, no sharing can occur for the part's memory
space. For sharing to occur, the structure value or a part of it must be passed to the part modification function as
part of the additional input of type \code{A}. If the structure is modifyable, type \code{T} is linear and passing 
the value as part of the additional input would be a double use which is prevented by the Cogent type constraints.

Note that all part access functions are defined in a way that they never allocate or deallocate memory on the heap.
therefore they never need the heap as additional in- and output.

An alternative to the function \code{modref} would be a pair of functions \code{ref} and \code{deref} where \code{ref}
returns the pointer together with the structure converted to a type which marks the part as removed (for a record this
corresponds to the type with a field taken), and \code{deref} converts the type back to normal. 
Since the structure has the converted type the part cannot be accessed through it
as long as the type has not been changed back which is done by \code{deref}, consuming the pointer.
However, it is possible to apply \code{deref} to another pointer of the same type, causing sharing between the 
structure and the original pointer. To prevent this it must be proven for the Cogent program that the \code{deref}
operation is always applied to a pointer retrieved by a \code{ref} operation before any other \code{deref}
is applied to the structure. This implies that
for proving the type safety properties an arbitrary complex part of the Cogent program must be taken into
account. Therefore Gencot does not support such functions.

To make the other parts of the structure available in the modification operation the \code{modref} operation could
pass the structure to it together with the additional input, with the type converted to a readonly type where the modified
part is marked as removed. This is safe because in the modification function the part cannot be accessed
through the structure and the structure cannot be modified by inserting another value for the part since it is
readonly in the modification operation. Note however, that instead of passing the structure to the modification operation,
all (nonlinear) values required from it can also be retrieved outside of \code{modref} and passed to it as part of the 
additional information of type \code{A}.

\subsection{Primitive Types}
\label{design-operations-prim}

The primitive Cogent types are the numerical types, \code{Bool} and \code{String}. 

\subsubsection{Creating and Disposing Values}

Values of primitive types cannot be created and disposed. If instances such as \code{create[U32]} are used in a program 
this is not detected as error by the Cogent compiler. However, since Gencot does not provide implementations for such
instances the resulting C program will not compile.

\subsubsection{Modifying Values}

Values of primitive types cannot be modified, they can only be replaced. The type constructors \code{ModTypeFun} and \code{ModFun}
can be used to define such replacement functions for primitive types. The type constructor \code{ModPartFun} also
can be applied to primitive types, however the resulting function type does not have the
intended semantics of ``modification functions''. Therefore such types should not be used.

\subsubsection{Initializing and Clearing Values}

Values of primitive types cannot be initialized or cleared. For primitive types there is no corresponding empty-value type.
Like for the modification function types the type constructors
\code{IniFun} and \code{ClrFun} can be applied to primitive types with useful results, but not with the intended semantics.
Therefore they should not be used.

\subsubsection{Accessing Parts of Values}

Primitive values have no parts, therefore the part access operations are not provided for them.

Although the type \code{String} has a structure consisting of a sequence of characters, access to characters is not supported
by Gencot because there is no known size for \code{String} values.

\subsection{Pointer Types}
\label{design-operations-pointer}

Here we denote as ``Gencot pointer types'' all mappings of C pointer types \code{t*} where \code{t} is no C struct, union, array or function.
As described in Section~\ref{design-types-pointer} , Gencot pointer types are 
Cogent abstract types with a name of the form \code{P\_T} where \code{T} is the Cogent mapping of a primitive, enumeration, struct, or union 
type \code{t} or a name of the form \code{PT} where \code{T} is the Cogent mapping of a function pointer or array or \code{T} is again a 
Gencot pointer type.

Gencot pointer types do not include the type \code{P\_Void}. For \code{P\_Void} no information about the referenced data structure is available. 
Therefore Gencot cannot support any operations 
for it. Values of this type are fully opaque, they can be passed around but neither created, nor manipulated or disposed. 

It is possible for the developer to manually define additional Gencot pointer types by defining abstract types using the same naming schema.
Gencot provides the operation support described in the following sections also for such types.

\subsubsection{Creating and Disposing Pointers}

The empty-value type corresponding to a Gencot pointer type \code{P...} is the type \code{TP...} which
is automatically generated by Gencot. It has a similar meaning as a Cogent
record with all fields taken. It statically marks the pointer as referencing uninitialized memory. It is mapped to the same C 
type as \code{P...}.

Gencot defines in \code{include/gencot/Memory.cogent} the preprocessor macro 
\begin{verbatim}
  PTREMPTY(P...)
\end{verbatim}
to specify the empty-value type for the valid-value Gencot pointer type \code{P...}. (It is implemented 
as preprocessor macro because it cannot be implemented as generic type in Cogent.)

For every Gencot pointer type \code{P...} used in the Cogent program Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[PTREMPTY(P...)]
  dispose[PTREMPTY(P...)]
\end{verbatim}

\subsubsection{Modifying Pointers}

Since pointer types are always abstract, all modifications of pointer values must be performed using abstract functions.

The only modification function applicable to a pointer consists of replacing the referenced value. Such modifications correspond
either to initialization and clearing operations or to dereferencing operations, described in the next two sections.

\subsubsection{Initializing and Clearing Pointers}

Before a pointer returned by \code{create} can be used it must be initialized by storing a value into the referenced memory region.
Dually, before disposing a pointer the memory region may be cleared.

Since Gencot pointer types \code{P...} point to a value of primitive type or again a pointer (which may be a function pointer,
or a pointer used to represent an array or a boxed record), an in-place
stepwise initialization of the referenced value is not possible. Initialization is always done by writing a single value or pointer
into the referenced memory. Clearing disposes a referenced non-function pointer, in all cases it may overwrite the referenced value
for security reasons.

Gencot defines generic types for such pointer initialization and clearing functions in \code{include/gencot/Memory.cogent}:
\begin{verbatim}
  type PtrIniFun evt vvt ref = IniFun evt vvt ref ()
  type PtrClrFun vvt evt = ClrFun vvt evt () ()
  type PtrPtrClrFun vvt evt ref eref arg out = ClrFun vvt evt (ClrFun ref eref arg out, arg, Heap) (out,Heap)
\end{verbatim}
where \code{evt} is the empty-value pointer type, \code{vvt} is the valid-value pointer type, and \code{ref} is the valid-value
type of the referenced values. A pointer initialization function always expects as additional input the value to be stored in
the referenced memory region and does not return any output. A function of type \code{PtrClrFun} has no additional input or output, 
it may overwrite the referenced memory
with a fixed value or leave it unchanged. The type \code{PtrPtrClrFun} is used if \code{ref} is a non-function pointer type. It takes 
as additional input a clearing function for type \code{ref} together with its argument, and the heap. \code{eref} is the empty-value type
corresponding to \code{ref}, \code{arg} is the type of the additional input for the clearing function for the referenced value,
and \code{out} is the type of it's additional output. The heap is required for deallocating the referenced pointer and is returned 
together with the clearing function's output.
All types besides \code{arg} and \code{out} are uniquely determined by the 
pointer type \code{vvt}, although this cannot be expressed by Cogent type constraints. Therefore Gencot  defines in 
\code{include/gencot/Memory.cogent} the preprocessor macros
\begin{verbatim}
  PTRINIFUN(REF,k)
  PTRCLRFUN(REF,k,AIT,AOT)
\end{verbatim}
for the types of initialization and clearing functions for a Gencot pointer type referencing a value of type \code{REF}
The additional parameter \code{k} is used to tell the kind of \code{REF}. It may be empty for a primitive type,
\code{F} for a function pointer type, \code{R} for a record type, or \code{P} for all other pointer types. Types \code{AIT}
and \code{AOT}
are the types of the additional input and output for the clearing function for the referenced value. If \code{k} is \code{F} or
empty they are ignored and may be empty.

For example the macro call \code{PTRINIFUN(U32,)} expands to the pointer initialization function type
\begin{verbatim}
  PtrIniFun TP_U32 P_U32 U32
\end{verbatim}
and the macro call \code{PTRCLRFUN(P\_U32,P,Arg,Out)} expands to the pointer clearing function type
\begin{verbatim}
  PtrClrFun PP_U32 TPP_U32 P_U32 TP_U32 Arg Out
\end{verbatim}

Gencot defines the polymorphic functions
\begin{verbatim}
  initPtr: all(evt,vvt,ref). PtrIniFun evt vvt ref
  clearPtr: all(vvt,evt). PtrClrFun evt vvt
  clearPtrPtr: all(vvt,evt,ref,eref,arg,out). PtrPtrClrFun vvt evt ref eref arg out
\end{verbatim}
Gencot defines instances of \code{initPtr} for all Gencot pointer types. It provides instances of \code{clearPtr} only for Gencot pointer types which
reference a primitive or function pointer value, and it provides instances of \code{clearPtrPtr} only for all other Gencot pointer types.
The \code{initPtr} instances store the additional input value 
into the referenced memory. The \code{clearPtr} instances do nothing and return their first argument (they do not overwrite the referenced memory).
The \code{clearPtrPtr} instances invoke the clearing function on the referenced value and the additional input and apply \code{dispose} to the result.
They leave the referenced memory unchanged. 

Gencot defines the preprocessor macros
\begin{verbatim}
  PTRINIINST(REF,k)
  PTRCLRINST(REF,k,AIT,AOT)
\end{verbatim}
with the same parameters as above. They can be added to the initialization and clearing functions to select a specific instance
to employ the Cogent type checker for checking the type consistency of the function use.

For example a pointer \code{p} of type \code{TP\_U32} can be initialized to the value \code{5} with typechecks by the Cogent expression
\begin{verbatim}
  initPtr[PTRINIINST(U32,)] (p,5)
\end{verbatim}
and a pointer \code{p} of type \code{PP\_U32} can be cleared with typechecks by the Cogent expression
\begin{verbatim}
  clearPtrPtr[PTRCLRINST(P_U32,P,(),())] (p,(clearPtr,(),heap))
\end{verbatim}

\subsubsection{Dereferencing Pointers}

If a pointer is seen as a structured value, it has the referenced value as a single part.
Then the operations for accessing parts of a structured value can be defined for a Gencot pointer type as follows
The operation \code{getref} corresponds to the identity, the operation \code{modref} is equivalent to applying the
part modification function directly to the pointer. Both are not provided separately for pointers.
The other operations all dereference the pointer in some way. Gencot provides the polymorphic functions
\begin{verbatim}
  getPtr: all(ptr,ref). ptr! -> ref! 
  setPtr: all(ptr,ref:<D). ModFun ptr ref ()
  exchngPtr: all(ptr,ref). ModFun ptr ref ref
  modifyPtr: all(ptr,ref,arg,out). ModPartFun ptr ref arg out
\end{verbatim}
Instances of these functions are only defined if \code{ptr} is a Gencot pointer type and \code{ref} is the corresponding
type of the referenced values. 

The function \code{getPtr} dereferences a readonly pointer and returns the result as readonly. The function \code{setPtr}
replaces the referenced value by its second argument, discarding the old value. Therefore the type \code{ref} of the referenced 
value must be discardable. The function \code{exchngPtr} works like \code{setPtr} but returns the old referenced value as 
additional result. The function \code{modifyPtr} applies a modification function to the referenced value, replacing or
modifying it.

\subsection{Function Pointer Types}
\label{design-operations-function}

As described in Section ~\ref{design-types-function}, function pointer types are mapped by Gencot to abstract types of the form 
\code{\#F...}. They are not covered by Gencot pointer types since they behave differently.

\subsubsection{Creating and Disposing Function Pointers}

Function pointers cannot be created and disposed. Gencot does not provide instances of \code{create} and \code{dispose}
for function pointer types.

\subsubsection{Modifying Values}

Function pointers cannot be modified. As for primitive types the type constructor \code{ModPartFun} should not be used for them.

\subsubsection{Initializing and Clearing Values}

Function pointers cannot be initialized or cleared, there is no corresponding empty-value type.
Like for the modification function types the type constructors
\code{IniFun} and \code{ClrFun} can be applied to function pointer types with useful results, but not with the intended semantics.
Therefore they should not be used.

\subsubsection{Accessing Parts of Values}

Function pointers have no parts, therefore the part access operations are not provided for them.

\subsubsection{Converting between Functions and Function Pointers}

For the values of the abstract type for function pointers in Cogent there are two relevant operations: invoking
it as a function and converting a Cogent function to a value of that type. Both are supported by Gencot
by providing polymorphic abstract functions in \code{inlude/gencot/CPointer.cogent} for the task.

The latter operation is supported by the polymorphic abstract function
\begin{verbatim}
  toFunPtr: all(fun, fptr). fun -> fptr
\end{verbatim}
where \code{code} is a Cogent function type and \code{fptr} is the corresponding function pointer type.
Although \code{fptr} is uniquely determined by \code{fun} Gencot does not provide support for this constraint.
However, Gencot provides implementations of instances only for valid pairs of function and function pointer types.

Invoking a function is supported by the polymorphic abstract function
\begin{verbatim}
  fromFunPtr: all(fptr, fun). fptr -> fun
\end{verbatim}
which translates the function pointer to the Cogent function (equivalent to the enumeration value) which
then can be invoked in the usual way in Cogent. 

The Cogent compiler cannot derive the type \code{fptr} when instances of these functions are used. It
must me xplicitly specified such as in 
\begin{verbatim}
  toFunPtr[_,#F_...]
  fromFunPtr[#F_...,_]
\end{verbatim}

All functions for which a function pointer is accepted or returned by these functions must be known to
Cogent so that there is an enumeration constant for it. It is not possible to pass a pointer to an arbitrary 
C function to Cogent as a parameter or as a field in a record. The function must either be defined in Cogent 
or it must be defined as an abstract function 
in Cogent. Moreover, if no function of type \code{fun} is defined in the Cogent program, the
generated C code from an invocation of the result of \code{fromFunPtr} in Cogent is incomplete, 
since it invokes the dispatcher function which does not exist.

An alternative approach for invoking a function pointer would be a polymorphic abstract function 
\begin{verbatim}
  invkFunPtr: all(ptr,args,res). (ptr, args) -> res
\end{verbatim}
where \code{args} is the type of the single argument of the Cogent function (possibly a tuple) and \code{res}
is the result type of the Cogent function. In its C implementation \code{invkFunPtr} applies the function pointer
to the argument and returns its result. 
This approach always causes correct C code to be generated by the Cogent compiler. However, since the Isabelle
C parser does not support function pointer invocations, no refinement proof can be processed for the resulting
C program.

Therefore Gencot does not support this alternative approach.

Hence for example for the C type
\begin{verbatim}
  int *()(int, short)
\end{verbatim}
the following function instances are provided
\begin{verbatim}
  toFunPtr[(U32,U16) -> P_U32, #F_'U32'U16'_P_U32]
  fromFunPtr[#F_'U32'U16'_P_U32, (U32,U16) -> P_U32]
\end{verbatim}


\subsection{The NULL Pointer}
\label{design-operations-null}

The type safety of Cogent relies on the fact that the pointers representing values of linear types are never \code{NULL}.
If null pointers are used in the C source, there is no immediate translation. The way how to translate C code which uses 
null pointers in a binary compatible way depends on the way how the null pointers are used.

A null pointer can be used as struct member \code{f} to mark the corresponding part as ``uninitialized''. 
It is set when the struct is created and later
replaced by a valid pointer. It remains valid until the struct is disposed. If additionally the struct is used only in places
during the ``uninitialized state'' which are different from those afterwards, the ``uninitialized state'' can be represented
by marking the part \code{f} as not present in the type used for the struct. Setting the pointer to a non-null value 
changes the struct type to the normal type used for it in Cogent. In a similar way NULL pointers can be used in array
elements and in referenced values while the array or pointer has its empty-value type.

If the field \code{f} is initialized ``on demand'', i.e., not at a statical point in the program, or if not all elements
of an array are initialized together, this solution is not possible.
A null pointer can also be used as an ``error'' or ``escape'' value for function parameters or results. 

The main problem in both cases is that it must be possible to determine at runtime whether a value is null or not. So simply
allocating a ``dummy'' to get a valid non-null pointer is not sufficient, it must also be possible to recognize the dummy pointer.

One possibility for this is if there is a value referenced by the pointer which never occurs in normal execution,
it can be used to mark the pointer as dummy. 

Another possibility is to use a single dummy pointer for all values of a specific linear type which can be null and store it 
in a seperate place for comparing it. However, this cannot be done in Cogent since the dummy pointer would be a shared linear 
value. Even if implemened in C through abstract functions, to prove memory safety every access to such a value must 
be guarded with a test for the dummy pointer. Thus it is easier to actually use the null pointer instead of the dummy pointer,
in combination with a guard testing for the null pointer

Moreover using a dummy pointer is not binary compatible if the pointer is 
also accessed in external existing C code where it is set to \code{NULL} or tested for being \code{NULL}.

A straightforward approach for working with the null pointer uses polymorphic abstract functions
\begin{verbatim}
  null: all(a). () -> a
  ronull: all(a). () -> a!
  isNull: all(a). a! -> Bool
\end{verbatim}
To dispose the null pointer the function \code{dispose} must also check for the null pointer and ignore
invocations for it. The function \code{ronull} is required to create null values of readonly types. This cannot be done 
by applying the bang operator to the result of \code{null} since then the readonly null value
cannot escape the banged context. 

However, the polymorphic functions cannot be restricted to specific types \code{T} by Cogent, therefore all values of all
types must be assumed to be null and their use must be guarded by \code{isNull}.

If Gencot generates monomorphic functions \code{null\_T}, \code{ronull\_T}, \code{isNull\_T} only for linear types or a
specific subset of them, this approach is also not safe. The existence of the function \code{null\_T} makes it necessary to guard all accesses to values of type
\code{T} and \code{T!} with the help of \code{isNull\_T}. The existence of the function \code{ronull\_T} makes it necessary to guard
all accesses to values of type \code{T!}, the values of type \code{T} need not be guarded since a readonly value can never be 
made modifyable again. Cogent cannot detect cases where values which may be null are accessed without guard.
Therefore Gencot does not automatically define the functions for linear types \code{T}.

\subsubsection{The abstract data type \code{MayNull}}

A safer approach replaces type \code{T} by an abstract type and uses type \code{T} only in places where a value has been checked
for not being null. The abstract type must be specific for \code{T} and it must be complemented with abstract functions for
generating and testing the null pointer. Gencot provides the following generic abstract data type in \code{include/gencot/MayNull.cogent}.
It is available for all linear Cogent types, not only for types generated by Gencot by mapping a C pointer type.
\begin{verbatim}
  type MayNull a 
  null:      all(a). () -> MayNull a
  roNull:    all(a). () -> (MayNull a)!
  mayNull:   all(a). a -> MayNull a
  roMayNull: all(a). a! -> (MayNull a)!
  notNull:   all(a). MayNull a -> Option a
  roNotNull: all(a). (MayNull a)! -> (Option a)!
\end{verbatim}
The function \code{null} returns the null pointer, the function \code{mayNull} casts a non-null pointer of type \code{a}
to type \code{MayNull a}. The operations \code{roNull} and \code{roMayNull} do the same for readonly pointers. 

The type \code{Option} is used from the Cogent standard library. 
The function \code{notNull} returns \code{None} if the argument is null and \code{Some x} if the argument \code{x} is not null.
The function \code{roNotNull} does the same for a readonly argument. 
Since \code{notNull} and \code{roNotNull} are the only functions which make the value available as a value of type \code{a} 
it is guaranteed by the Cogent type constraints that all accesses to the value are guarded by one of these two functions. 

As usual,
the type parameter \code{a} cannot be restricted by Cogent to linear types. However, Gencot provides instances of the functions only for
linear types \code{a}.

Note that since the type \code{MayNull a} is not denoted by a single type name it is not possible to construct Cogent mappings of derived types for it, such
as a function type with a parameter of type \code{MayNull a}. This is correct, since the function would be polymorphic. If a Cogent type name 
is defined for a specific instance of \code{MayNull}, mappings of derived types for the instance can be constructed using this type name.

Based on the abstract functions the function
\begin{verbatim}
  isNull: all(a). (MayNull a)! -> Bool
  isNull mn = roNotNull mn | None -> True | Some x -> False
\end{verbatim}
is defined in Cogent for an explicit test for the null pointer.

\subsubsection{General Operations}

Values of type \code{MayNull a} cannot be created, disposed, initialized, or cleared. Either they are null, or they are pointers of
a valid-value pointer type, for which the type-specific functions for creating, initializing, cearing, and disposing are available.

The type constructors \code{ModFun}, \code{ModTypeFun}, and \code{ModPartFun} can be applied to \code{MayNull a} with the usual intended
semantics.

\subsubsection{Part Access Operations}

Conceptually, the type \code{MayNull a} can be seen as a structured value with the value referenced by the non-null pointer of type \code{a} being
an optional part. Then the operations for accessing parts of a structured value can be defined for \code{MayNull a} as follows
The operation \code{get} corresponds to \code{roNotNull}. The operation \code{set} cannot be defined, since the type \code{a} of the 
``part'' is always linear and thus not discardable. The operations \code{getref} and \code{modref} cannot be defined, since
the ``part'' is identical to the container and need not be stored somewhere on the heap. 
All four operations are not provided separately. The other two operations are provided
by the polymorphic functions
\begin{verbatim}
  exchngNull: all(a).
     ModFun (MayNull a) a a
  modifyNull: all(a,arg:<D,out).
     ModPartFun (MayNull a) a arg out
\end{verbatim}
Again, instances of the functions are only defined if \code{a} is a linear type. 

The function \code{exchngNull (mn, p)} takes as input two pointers, one of which may be null. If \code{mn} is null the result is
\code{(mn,p)}, otherwise it is the pair of \code{mayNull p} and the non-null pointer corresponding to \code{mn}.

The function \code{modifyNull (mn, (modfun,addinput))} is a 
modification function according to the description of \code{ModPartFun} in Section~\ref{design-operations-concept}.
If \code{mn} is not null it modifies the object referenced by \code{mn} by applying the part modification function \code{modfun} of type 
\code{ModFun a arg} to \code{mn} and returns \code{mn} and the additional result of type \code{out}. Otherwise it returns the null pointer \code{mn}
together with a fixed additional result. The type \code{arg} of the additional input
must be discardable, because it is discarded, if \code{mn} is null and the part modification function is never used. 
For the fixed result Gencot uses the polymorphic abstract function
\begin{verbatim}
  defaultVal: all(out). () -> out
\end{verbatim}
defined in \code{include/gencot/Default.cogent}. 
It provides instances for the numeric types \code{U8,U16,U32,U64} which return 0 and for the unit type \code{()} which returns \code{()}. 
Other instances must be defined manually.

\subsection{Record Types}
\label{design-operations-record}

As described in Section~\ref{design-types-struct} C struct types are always mapped to Cogent record types, no other 
record types are generated by Gencot. 
Additional record types may be introduced manually in the translated Cogent program.

\subsubsection{Creating and Disposing Records}

The empty-value type corresponding to a record type \code{R} is the type \code{R take (..)} where all fields are taken.
Gencot defines in \code{include/gencot/Memory.cogent} the preprocessor macro 
\begin{verbatim}
  RECEMPTY(R)
\end{verbatim}
to specify the empty-value type for \code{R}. (It is implemented 
as preprocessor macro because, like \code{PTREMPTY}, it cannot be implemented as generic type in Cogent.)

For every record type \code{R} used in the Cogent program (not only those generated by mapping a C type) Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[RECEMPTY(R)]
  dispose[RECEMPTY(R)]
\end{verbatim}

\subsubsection{Modifying Records}

The type constructors \code{ModFun}, \code{ModTypeFun}, and \code{ModPartFun} can be applied to record types with the 
usual intended semantics. 

A specific kind of modification functions for records are functions which put or take a record field. 
Gencot defines macros in \code{include/gencot/ModFun.cogent} to generate the type of simple put and take operations for
record types.

A macro call of the form 
\begin{verbatim}
  PUTFUN(R,f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take f) R A ()
\end{verbatim}
for a function which puts field \code{f} in a record of type \code{R}. A macro call of the form
\begin{verbatim}
  TAKEFUN(R,f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun R (R take f) A ()
\end{verbatim}
for a function which takes field \code{f} in a record of type \code{R} (without returning the taken value).

A macro call of the form 
\begin{verbatim}
  PUTFUN<n>(R,(f1,...,fn),f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f,f1,...,fn)) (R take (f1,...,fn)) A ()
\end{verbatim}
for a function which puts field \code{f} while the fields \code{fi} are already taken. A macro call of the form
\begin{verbatim}
  TAKEFUN<n>(R,(f1,...,fn),f,A)
\end{verbatim}
expands to the type
\begin{verbatim}
  ModTypeFun (R take (f1,...,fn)) (R take (f,f1,...,fn)) A ()
\end{verbatim}
for a function which takes field \code{f} while the fields \code{fi} are already taken.

Gencot does not automatically define modification functions for record types, since a record can be modified using the
Cogent get and put operations for its fields. Only if a field of record type is modified through a modification function for 
its context, the record fields
must be manipulated using modification functions for the record. Then such operations must be defined manually.

\subsubsection{Initializing and Clearing Records}

Gencot defines in \code{include/gencot/Memory.cogent} the preprocessor macros
\begin{verbatim}
  RECINIFUN(R,AIT,AOT)
  RECCLRFUN(R,AIT,AOT)
\end{verbatim}
for the types of initialization and clearing functions for a record type \code{R} with additional input and output of types
\code{AIT} and \code{AOT}.

Before a record returned by \code{create} can be used it must be initialized by putting values for all fields. 
Dually, before disposing a record it must be cleared by taking all fields.

Functions
for initializing and clearing a record \code{r} of type \code{R} can be defined in Cogent by putting or taking values 
into/from all fields.

Putting values into fields of primitive type is straightforward. For fields of a boxed record type \code{S} a value can be created 
using the function \code{create}, then applying an initialization function of type RECINIFUN(S) and putting the result into the field using the
Cogent put operation. For fields of a boxed abstract type it depends which abstract functions are available for creating and 
initializing values. Fields of type \code{MayNull a} can be initialized by putting \code{null()}. For fields of array type and Gencot
pointer type, instances of \code{create} are available and the type specific initialization functions described in 
Sections~\ref{design-operations-pointer} and~\ref{design-operations-array}.

Fields of a readonly boxed type \code{S!} cannot be initialized according to this schema. If a value is created in the 
initialization function for \code{r} it must be banged there but then it may not leave the banged context. The readonly value must be created
outside and then passed to a banged context. The initialization of \code{r}, its use and its clearing must all happen inside
this context. To support this, the initialization functions for type \code{R} must take as additional input a tuple of all
values to be used for readonly fields. A simpler solution is to use type \code{(MayNull S)!} instead for the field and 
put the value \code{roNull()} during initialization. Then a readonly non-null value can be set later in the corresponding
banged context. Fields of type \code{(MayNull a)!} can be initialized by putting \code{roNull()}.

A field \code{f} with an unboxed record type \code{\#S} corresponds to an embedded struct in C. The space for this struct is allocated together
with the space for \code{r} by function \code{create}, so it needs only to be initialized. The initialization should be possible by using
an initialization function of type \code{RECINIFUN(S,AIT)}.

The most natural way of initializing an embedded struct would be in-place using a pointer to the embedded struct as described
for operation \code{modify} in Section~\ref{design-operations-concept}. But \code{modify} takes as argument a value of type \code{R}
where no field is taken, so it cannot be used to put the taken field \code{f} into the record. Separate modification functions
are required for the record with taken fields. If the record contains several embedded structs every modification function
puts one field and the result type has one field less taken. Thus, defining such modification functions imposes an order
in which the embedded structs must be initialized and whether they are initialized before or after the other fields. A corresponding
modification function for field \code{f} which must be initialized before field \code{g} but after all other fields would be
\begin{verbatim}
  putFInR : PUTFUN1(R,(g),f,(RECINIFUN(S,AIT,AOT),AIT))
\end{verbatim}
It is invoked with the initialization function for the embedded record and its argument 
as additional information.

A more flexible way would be to use the Cogent put operation. However, for field \code{f} it needs a value of type 
\code{\#S} which is not produced by the initialization function. To bridge this gap we can use an abstract function
\begin{verbatim}
  deref : S -> #S
\end{verbatim}
which dereferences the argument pointer, and returns a copy of its content. Additionally it frees the pointer so that the
linear input value is safely disposed. (Note that the argument cannot be readonly to avoid freeing the pointer, since then
the result must also be readonly if it contains linear values.) Then the Cogent code to initialize the embedded struct 
\code{f} in a record \code{r} using the initialization function \code{init} with additional input \code{arg} would be
\begin{verbatim}
  r { f = deref (fst (init (create (),arg))) }
\end{verbatim}
It is not as efficient as in-place initialization, since it allocates a struct of type \code{S} on the heap, initializes it,
copies it to the embedded struct \code{f} and deallocates it.

Since both ways may be useful in certain contexts Gencot does not generate one or both of them, they must be provided manually.

Another approach could be that the function \code{create[RECEMPTY(R)]} returns a value where only the fields of primitive and linear type
are taken and the embedded structs are present, but again with all primitive and linear fields taken. Then the initialization function for
field \code{f} could be directly applied to a pointer to field \code{f}. However, it is still necessary to retrieve the pointer to \code{f}
with the help of an abstract function which now has to respect the fact that other embedded record fields have types with
some fields taken. So the same number of additional abstract functions is needed as in the approach above and their argument
types are of similar complexity.

Fields of an unboxed abstract type are created by Gencot only in the case of arrays and function pointers (see 
Section~\ref{design-types-array} and~\ref{design-types-function}). Initializing an embedded array field \code{f} of type 
\code{\#UA'<size>'\_El} can be done in-place or separate like an embedded record field. In the first case an abstract
function of the form 
\begin{verbatim}
  putFInR : PUTFUN1(R,(g),f,(ARRINIFUN(A'<size>'_El,AIT,AOT),AIT))
\end{verbatim}
is required which uses an array initialization function and puts \code{f} while field \code{g} is still taken. 
In the second case an abstract function of the form
\begin{verbatim}
  deref : A'<size>'_El -> #UA'<size>'_El
\end{verbatim}
is required which copies the array content and frees the array on the heap.

Initializing a field \code{f} of a function pointer type \code{\#F\_...} can always be done using the Cogent put operation.
The value to be put must be constructed using the function \code{to\_F\_...} (see Section~\ref{design-types-function}). To
avoid null pointers to functions, as described in Section~\ref{app-transfunction-pointer}, a dummy function should be defined in
Cogent and passed to the \code{to\_F\_...} function.

In a clearing function for a record all content shall be discarded. For fields of primitive and readonly type this is
straightforward by using the Cogent take operation and ignoring the taken value. For fields of linear type the taken value
cannot be simply discarded, it needs special treatment.

For a field of a boxed type \code{S} the taken value must be disposed by applying the function \code{dispose}.
For a field of type
\code{MayNull S} the value must be tested whether it is null, otherwise the function \code{dispose} must be applied. In
all these cases a clearing function for type \code{S} must be applied first, so that the dispose-function is applicable.

A field of unboxed record type \code{\#S} is linear, if the embedded record contains linear fields. During clearing these must be
disposed. This can be achieved by applying a clearing function for type \code{S} before taking the field. Dually to the 
initialization of an embedded record this can be done in-place or using a copy. The in-place approach requires an abstract
function of the form
\begin{verbatim}
  takeFInR : TAKEFUN1(R,(g),f,(RECCLRFUN(S,AIT,AOT),AIT))
\end{verbatim}
which applies a clearing function of type \code{RECCLRFUN(S,AIT,AOT)} and takes the field \code{f} while field \code{g} is already taken.
The other approach requires an abstract function 
\begin{verbatim}
  refer : #S -> S
\end{verbatim}
which allocates an object on the heap and stores the content of its argument into it. Then field \code{f} can be taken, the taken
value passed to \code{refer}, and a clearing function applied to its result, before it is disposed.

A field of an unboxed abstract type is never linear, so the field can always be taken and the taken value discarded.
However, if the C implementation of the abstract type contains pointers, they must be deallocated. This can be achieved by
applying a clearing function in the same way as for an unboxed record field with the help of an abstract function
\code{takeFInR} or \code{refer}.

\subsubsection{Accessing Record Fields}

The parts of a record are its fields. The conceptual operations for accessing parts of a structured value can be defined for a record type 
\code{R} as follows.

The field to be accessed by the operation must be specified by its name. This can only be done as part of the function name.
Therefore Gencot does not define polymorphic functions for accessing the fields of arbitrary record types. For every record type
\code{R} a set of differently named functions must be defined for every field \code{f}. Since only some of the functions are needed, Gencot
does not automatically generate such functions, they must be defined manually, if required, then they have the following forms

\begin{verbatim}
  getFInR : R! -> S!
  getFInR r = r.f
  setFInR : ModFun R S ()
  setFInR (r,v) = r{f=v}
  exchngFInR : ModFun R S S
  exchngFInR (r,v) = let r{f=v'} in (r{f=v},v')
  modifyFInR : all(arg,out). ModPartFun R S arg out
  modifyFInR (r,(m,x)) = 
    let r{f} and (f,y) = m(f,x) in (r{f=f},y)
\end{verbatim}

The operation \code{get} for a field \code{f} of a record \code{r} corresponds to the Cogent member access operation \code{r.f}.
Since the \code{get} operation is not passed as argument to other functions, it need not be defined for record fields, it is always possible
to use the Cogent member access operation instead.

The operation \code{set} for a field \code{f} of a record \code{r} and a value \code{v} corresponds to the Cogent put operation r{f = v}, if
the field has a nonlinear type. Otherwise it is not supported.

The operation \code{exchng} for a field \code{f} of a record \code{r} and a value \code{v} can be implemented in Cogent by first taking the 
old value of \code{f}, then putting \code{v} and finally returning the record together with the old value.

The operation \code{modify} for a field \code{f} of a record \code{r} and a field modification function can be implemented in Cogent 
by first taking the value of \code{f}, then applying the modification function to it, and finally putting the result back into
the field.

The operations \code{getref} and \code{modref} cannot be implemented in Cogent, they must be defined as abstract function which are implemented in 
C with the help of the address operator \code{\&}. For a field \code{f} of type \code{S} the corresponding function definitions have the form
\begin{verbatim}
  getrefFInR : R! -> PS!
  modrefFInR : all(arg,out). ModPartFun R PS arg out
\end{verbatim}
where \code{PS} is the Gencot mapping of the type of pointer to \code{S}. Remember that according to the definition of 
\code{ModPartFun} the function \code{modrefFInR} is invoked in the form
\begin{verbatim}
  (r',o) = modrefFInR(r, (m,a))
\end{verbatim}
where \code{r} is a boxed record value which is not readonly, \code{m} is a modification function of type \code{ModFun PS arg out} which
is equivalent to type \code{(PS,arg) -> (PS,out)}, \code{a} is the argument of type \code{arg} passed to \code{m}, \code{r'} is
the record value \code{r} after the modification, and \code{o} is the additional result of type \code{out} returned by \code{m}.

\subsection{Array Types}
\label{design-operations-array}

The abstract types generated for arrays with known size are complemented by Gencot by abstract polymorphic 
functions for working with
arrays. For these functions Gencot automatically generates the instance 
implementations in C. All these implementations involve the array size in some way. The developer may manually introduce
other array types by adhering to the Gencot naming schema for array types. Then Gencot also supports these types and
generates instances of all polymorphic functions for them.

If the array size is unknown (types of the form \code{A\_El}) or too complex (types of the form \code{A''\_El})
no instances of the polymorphic functions are provided by Gencot. However, implementations may be provided manually. Often
this is possible by the developer determining the array size from the context. If several array types with 
different unknown sizes have been mapped to the same abstract type, they must be disambiguished manually.

Gencot only supports arrays which are allocated on the heap. In C, arrays can also be introduced by defining
them as global or local variable, but Cogent has no language constructs which support this.

\subsubsection{Creating and Disposing Arrays}

Gencot represents array values in Cogent always by an abstract type of the form \code{A'<size>'...}.
Hence Cogent does not provide a language construct to create such values. 

The empty-value type corresponding to type \code{A'<size>'...} is the abstract type \code{TA'<size>'...} which
is automatically generated by Gencot. It has a similar meaning as a Cogent
record with all fields taken. It statically marks the array as uninitialized. It is mapped to the same C 
type as \code{A'<size>'...}.

Gencot defines in \code{include/gencot/Memory.cogent} the preprocessor macro 
\begin{verbatim}
  ARREMPTY(A...)
\end{verbatim}
to specify the empty-value type for an array type \code{A...}.

For every array type \code{A...} used in the Cogent program (not only those generated by mapping a C type) Gencot automatically
generates instances of the functions \code{create} and \code{dispose} of the form:
\begin{verbatim}
  create[ARREMPTY(A...)]
  dispose[ARREMPTY(A...)]
\end{verbatim}

Both functions also support multidimensional array types of the form \code{A'<size>'UA'<size>'...\_El}.

\subsubsection{Modifying Arrays}

Since array types are always abstract, all modifications of array values must be performed using abstract functions.

The type constructors \code{ModFun}, \code{ModTypeFun}, and \code{ModPartFun} can be applied to array types with the 
usual intended semantics. 

Gencot provides no equivalent for the Cogent take and put operations for array elements. It would be
necessary to statically encode the set of array indices for which the elements have been taken in the type expression,
this is not feasible.

\subsubsection{Initializing and Clearing Arrays}

An array initialization function sets a valid value for every element. An array clearing function clears every element, 
clearing and disposing all linear values contained in elements. Since all elements are of the same type, they can all be
treated in the same way by an initialization or clearing function for the element type. Initializing and clearing an element
can be done ``in-place'' by passing a pointer to the element to the element initialization or clearing function. As usual,
an additional input given to the array function is passed through to every invocation of the element function. 

It could be useful to also know the element index in the element function. This could by supported by passing the index
as additional input to the elemet functions. However, this implies that the normal initialization and clearing functions
for the element type cannot be used as element functions here, since they do not expect the index as additional input.
Therefore the functions automatically supported by Gencot for initializing and clearing array do not pass the index 
to the element functions. If needed, such functions can be defined manually.

Gencot defines generic types for array initialization and clearing functions in \code{include/gencot/Memory.cogent}:
\begin{verbatim}
  type ArrIniFun evt vvt epe vpe arg out =
    IniFun evt vvt (IniFun epe vpe arg out, arg) out
  type ArrClrFun vvt evt vpe epe arg out =
    ClrFun vvt evt (ClrFun vpe epe arg out, arg) out
\end{verbatim}
where \code{evt} is the empty-value array type, \code{vvt} is the valid-value array type, \code{epe} is the empty-value
element pointer type and \code{vpe} is the valid-value element pointer type. \code{arg} and \code{out}
are the types of the additional input and output for the element function. All types besides \code{arg} and \code{out} are uniquely determined by the 
array type \code{vvt}, although this cannot be expressed by Cogent type constraints. Therefore Gencot  defines in 
\code{include/gencot/Memory.cogent} the preprocessor macros
\begin{verbatim}
  ARRINIFUN(size,k,EL,AIT,AOT)
  ARRCLRFUN(size,k,EL,AIT,AOT)
\end{verbatim}
for the types of initialization and clearing functions for an array type \code{A} with additional input and output of types \code{AIT} and \code{AOT}.
The array type \code{A} is determined by the number of elements \code{size} and the element type 
\code{EL}. The additional parameter \code{k} specifies the kind of the element type. It may be empty for a primitive type,
\code{F} for a function pointer type, \code{R} for a boxed record type, \code{U} for an unboxed record type, or \code{P} for 
all other pointer types. 

For example the macro call \code{ARRINIFUN(16,,U32,(),())} expands to the initialization function type
\begin{verbatim}
  IniFun TA'16'_U32 A'16'_U32 TP_U32 P_U32 () ()
\end{verbatim}
and the macro call \code{ARRCLRFUN(300,U,R,Arg,U16)} expands to the clearing function type
\begin{verbatim}
  ClrFun A'300'U_R TA'300'U_R R (R take (..)) Arg U16
\end{verbatim}

Gencot defines the polymorphic functions
\begin{verbatim}
  initArr: all(evt,vvt,epe,vpe,arg:<S,out). 
     ArrIniFun evt vvt epe vpe arg out
  clearArr: all(vvt,evt,vpe,epe,arg:<S,out). 
     ArrClrFun evt vvt epe vpe arg out
\end{verbatim}
Since the additional input of type \code{arg} is passed to every invocation of the initialization or clearing function
it must be sharable. The outputs of type \code{out} are combined using the function
\begin{verbatim}
  defaultCombine: all(out). (out,out) -> out
\end{verbatim}
defined in \code{include/gencot/Default.cogent}. It provides instances for the numeric types which return the first argument if it
is not 0, otherwise the second, and it provides an instance for the unit type \code{()} which returns \code{()}.

Gencot defines the preprocessor macros
\begin{verbatim}
  ARRINIINST(size,k,EL,AIT,AOT)
  ARRCLRINST(size,k,EL,AIT,AOT)
\end{verbatim}
with the same parameters as above. They can be added to the initialization and clearing functions to select a specific instance
to employ the Cogent type checker for checking the type consistency of the function use.

For example an array \code{a} of type \code{TA'16'\_U32} can be initialized by setting all elements to \code{5} with typechecks by 
the Cogent expression
\begin{verbatim}
  initArr[ARRINIFUN(16,,U32,(),())] (a,(initPtr,5))
\end{verbatim}

Gencot provides instances of these functions also for multidimensional array types of the form \code{A'<size>'UA'<size>'...\_El}.

\subsubsection{Accessing Array Elements}

If an array is seen as a structured value, its elements are its parts.
Then all operations for accessing parts of a structured value are nontrivial. Since elements are specified by an index value
Gencot provides polymorphic functions for all six operations
\begin{verbatim}
  getArr : all(arr,idx,el). (arr!,idx) -> Option el!
  setArr : all(arr,idx,el:<D). ModFun arr (idx,el) ()
  exchngArr : all(arr,idx,el). ModFun arr (idx,el) el
  modifyArr : all(arr,idx,el,arg:<D,out). 
    ModFun arr (idx, ModFun el arg out, arg) out
  getrefArr : all(arr,idx,pel). (arr!,idx) -> Option pel!
  modrefArr : all(arr,idx,pel,arg:<D,out). 
    ModFun arr (idx, ModFun pel arg out, arg) out
\end{verbatim}
The type variable \code{arr} denotes the array type, \code{idx} denotes the index type,
\code{el} denotes the array element type, and \code{pel} denotes the type of pointers to elements. 
The result types of \code{getArr} and \code{getrefArr} use the generic type \code{Option} defined in
the Cogent standard library.

Instances of these functions are only defined if \code{arr} is a Gencot array type. Type \code{idx}
must be one of \code{U8, U16, U32} according to the \code{<size>} of the array. Types \code{el} and
\code{pel} must be as determined by \code{arr}. \code{arg} and \code{out} may be arbitrary types.

Function \code{getArr} retrieves the indexed element as readonly. If the specified index 
is not in the range \code{0..<size>-1} the function returns \code{None}.

Function \code{setArr} is only defined for a discardable element type. 
It simply discards the old value of the indexed element and sets it to the specified value.
If the specified index is not in the range \code{0..<size>-1} the function returns the unmodified array.

Function \code{exchngArr}
replaces the element at the specified position by the element passed as parameter and returns the old element in the result.
If the specified
index is not in the range \code{0..<size>-1} the function returns the same element which has been
passed as input, together with the unmodified array. 

Function \code{modifyArr} modifies the element at the specified position by applying the element modification function
to it. If the specified
index is not in the range \code{0..<size>-1} the function returns the unmodified array together with the default value
\code{defaultVal ()} for type \code{out}. Since in this case the 
additional input to the modification function is discarded, its type \code{arg} must be discardable.

Function \code{getrefArr} returns a pointer to the element in the array without copying the element. This is safe since 
both the array and the result
type are readonly. If the specified index is not in the range \code{0..<size>-1} the function returns \code{None}. 

Function \code{modrefArr} works like \code{modifyArr} but passes a pointer to the element to the element modification function.

The types of \code{modifyArr} and \code{modrefArr} are similar to a \code{ModPartFun}, but differ because in addition to the 
element modification function and its argument the element index must be passed as argument.

Note that it is not possible
to pass the array or parts of it as additional information in the parameter of type \code{arg}, since that would always be
a second use of the array of linear type. If several elements must be modified together, a specific modification function
must be defined and used instead of \code{modifyArr} or \code{modrefArr}.

Gencot does not provide instances of these functions for multidimensional array types of the form \code{A'<size>'UA'<size>'...\_El}.

