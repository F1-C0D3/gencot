The Cogent code generated for C expressions and statements in the first translation phase as described in 
Section~\ref{impl-ccode-cstats} is in general neither correct nor efficient. Therefore it must be improved, 
which is done by postprocessing. The postprocessing is done directly in the Cogent AST. 

This approach taken by Gencot has several advantages over generating the Cogent code in a single phase.
First, the actual translation step ist rather simple and straightforward and even needs not take the C types
into account. Second, the postprocessing is done on a restricted subset of a purely functional language where 
there is no difference between statements and expressions, so it tends to be simpler. Third, it can be separated
into arbitrary many different processing steps which can be freely combined, since they all process the same
data structures (the Cogent AST). The drawback is that the code generation is not very efficient, because it
first builds a quite voluminous code which is then simplified by the postprocessing. However, the quality 
of the resulting code has been considered more important than the performance of the Gencot translation.

In the following sections the postprocessing steps are described independently of each other and in the last
section it is described how they are combined. Every postprocessing step corresponds to a transformation from
a Cogent expression to a Cogent expression and is implemented by a Haskell function of the form
\begin{verbatim}
  procX :: GenExpr -> GenExpr
\end{verbatim}
Note that no monadic actions are used, all information required for the processing must already be present in the 
expressions.

Postprocessing is applied to all expressions which occur in the generated Cogent program. These are function 
body expressions, the expressions in constant definitions, and the expressions in array type size specifications.

\subsection{Variable Substitution}
\label{imp-post-vsubst}

One of the simplest and most straightforward postprocessing steps is substitution of bound variables by the
expression bound to them. In Cogent variables can be bound by \code{let} expressions and by \code{match} and \code{lambda}
expressions. Variables bound in \code{match} and \code{lambda} expressions can usually only be substituted in special cases, 
therefore this processing step only substitutes variables bound in \code{let} expressions. 

The basic transformation is for an expression
\begin{verbatim}
  let v = expr1 in expr2
\end{verbatim}
to replace it by \code{expr2} where every free occurrence of \code{v} is substituted by \code{expr1}. This is only 
possible if after the substitution all free variables in \code{expr1} are still free in the resulting expression, i.e., 
they are not ``drawn under a binding'' in \code{expr2}. This could be avoided by consistent renaming of variables bound in 
\code{expr2}.

This scheme can directly be extended to expressions of the form \code{let v1 = e1 and ... vn = en in e} using the
equivalence to an expression of the form \code{let v1 = e1 in let ... in let vn = en in e}.

\subsubsection{Applicable Patterns}

If the pattern used in the binding is not a single variable, it depends on its form and on the form of the bound expression whether
a substitution is applicable:
\begin{itemize}
\item A wildcard pattern \code{\_}: since the pseudo variable \code{\_} cannot occur free in \code{expr2} it is substituted like
a normal variable which does not occur in \code{expr2}.
\item A tuple pattern \code{(p1,...,pn)}: this is only processed if \code{expr1} is a tuple expression \code{(e1,...,en)} of the 
same length \code{n}. Then for each \code{i} for which substitution is applicable for the binding \code{pi = ei} the corresponding 
substitution may be performed and the pattern \code{pi} and the expression \code{ei} are removed from their tuples. If this results
in 1-tuples \code{(p) = (e)} it is converted to the plain binding \code{p = e}. The patterns are tried in the order in which they 
occur in the tuple. No optimization attempt is made to, e.g., substitute the largest possible number of variables, because such
an optimization usually has a high complexity.
\item Record and array patterns: these could be treated in a similar way, however, they are not generated by Gencot and are not processed.
\item A \code{take} pattern for a record or array: this could be processed for substitution, if \code{expr1} is a corresponding 
\code{put} expression. However, in a sequence of bindings Gencot always generates all put operations after all take operations, 
so this case cannot occur and \code{take} patterns are not processed.
\end{itemize}

\subsubsection{Substitution Rules}

This kind of substitution may lead to exponentially larger code, which must be avoided. Also, the resulting code should be 
optimized both for performance and for readability. 

If Variable \code{v} does not occur free in \code{expr2} the \code{let} expression can be replaced by the unmodified 
expression \code{expr2}. This is always done. Since this step eliminates \code{expr1}, the free variables in the resulting expression may be 
reduced which may make the same rule applicable for a variable bound in the context. Therefore substitution of nested
\code{let} expressions always starts with the innermost \code{let} expression.

If \code{v} occurs free in \code{expr2} the goal is to substitute only if the resulting expression is not much larger than 
the original expression. Gencot uses a simple expression metrics which roughly corresponds to the size of the printed expression.
If the metrics of the result is not much larger than the metrics of the original \code{let} expression the substitution is 
performed. If the substitution is performed, always all free occurrences of \code{v} are substituted, partial substitutions are 
not done. If a free variable in \code{expr1} would be bound at one of the occurrences of \code{v} in \code{expr2} the substitution 
is never performed, no variable renaming is applied.

Note that the second case also covers the first one, since the metrics of \code{expr2} alone is always smaller than that of the 
\code{let} expression. Note also that this approach always eliminates ``chain bindings'' where \code{v} is bound to the value of another
variable. In this case the substitution will not change the metrics of \code{expr2} (all variables have the same metrics) and so it 
will also be smaller than that of the \code{let} expression, so that the substitution is executed.

Gencot uses different kinds of variables in its generated code (see Section~\ref{impl-ccode-cstats}): value variables, component and 
index variables, control variables, and variables corresponding to C object names. These are prioritized as follows: first as many value 
variables are substituted as possible in a complete expression, then the control variables, then the component and index variables and
finally the C object names. In this way the most ``technical'' variables are substituted before the more ``semantical''.

\subsection{Take/Put Processing}
\label{imp-post-takeput}

\subsection{Control Processing}
\label{imp-post-control}

\subsection{Combining the Steps}
\label{imp-post-combine}

