#! /bin/sh

# Modify an Isabelle theory. Intended to be applied to X_ShallowShared.thy or 
# X_ShallowShared_Tuples.thy generated by Cogent.
# This is a filter from stdin to stdout.

awk \
'{
  if ($0 == "This file is generated by Cogent") {
    print $0
    print "and modified by Gencot"
  } else if ($1 == "theory" && NF == 2) {
    if ($2 ~ /_ShallowShared_Tuples$/) { tup = "_Tuples"; print }
    else if ($2 ~ /_ShallowShared$/) { tup = ""; print }
    else {
      printf("Error: auxcog-shalshared input must be a theory named X_ShallowShared or X_ShallowShared_Tuples.\n")
      exited = 1
      exit 1
    }
  } else if ($0 == "imports \"Cogent.Util\"") {
    print "imports \"CogentShallowUtil.Util\""
  } else if ($0 == "\"CogentShallow.ShallowUtil\"") {
    print "\"CogentShallowUtil.ShallowUtil\""
  } else if ($1 == "typedecl" && $3 == "MayNull") {
    printf("type_synonym %s MayNull = \"%s option\"\n", $2, $2)
  } else if ($1 == "type_synonym" && substr($3,1,7) == "CArrPtr" && substr($6,1,7) == "CArrPtr") {
    printf("type_synonym %s %s = \"%s list\"\n", $2, $3, $2)
  } else if ($1 == "record") { 
    tt_name[num_tt+1] = $(NF-1)
    tt_args[num_tt+1] = ""
    for (i = 2; i < NF-1; i++) tt_args[num_tt+1] = tt_args[num_tt+1] " " $i;
    tt_parse = 1
    print
  } else if ($1 ~ /^p[0-9]+\\<\^sub>f/) { 
    match($1,/[0-9]+/,pnum)
    if (tt_parse == pnum[0]) tt_parse++
    else tt_parse = 0
    print
  } else if (NF == 0) { 
    if (tt_parse) tt_size[++num_tt] = tt_parse-1
    print
  } else if (tt_parse) { 
    tt_parse = 0
    print 
  } else if ($0 == "end" && tup == "") {
    printf("(* Tuple synonyms added by Gencot *)\n\n") 
    for (i = 1; i <= num_tt; i++) {
      printf("type_synonym %s Tup%s = \"%s %s\"\n", tt_args[i], tt_size[i], tt_args[i], tt_name[i])
      printf("abbreviation \"makeTup%s \\<equiv> %s.make\"\n", tt_size[i], tt_name[i])
      for (j = 1; j <= tt_size[i]; j++) {
        printf("abbreviation \"p%sTup%s \\<equiv> %s.p%s\\<^sub>f\"\n",j,tt_size[i],tt_name[i],j)
        printf("abbreviation \"p%sTup%s_update \\<equiv> %s.p%s\\<^sub>f_update\"\n",j,tt_size[i],tt_name[i],j)
      }
      printf("\n")
    }
    print
  }
  else print
}'

# documentation:
#
# - the name of the input theory must be X_ShallowShared with an optional suffix _Tuples, which
#   is stored in the variable tup. Otherwise an error message is written to stderr.
#
# The input theory is modified in the following ways:
# - after a line "This file is generated by Cogent" the line "and modified by Gencot" is inserted.
# - the line "imports "Cogent.Util"" is changed to "imports "CogentShallowUtil.Util""
# - the line "CogentShallow.ShallowUtil" is changed to "CogentShallowUtil.ShallowUtil"
# - every line
#     typedecl 'a MayNull
#   is replaced by
#     type_synonym 'a MayNull = "'a option"
# - every line
#     type_synonym 'el CArrPtr\<^sub>T = "'el CArrPtr"
#   is replaced by
#     type_synonym 'el CArrPtr\<^sub>T = "'el list"
#
# The modifications are implemented by matching lines and possibly replacing them by one or more lines.
# All non-matching lines are passed through.
#
# If the theory is X_ShallowShared (no suffix) additional abbreviations are generated for tuple types.
# A tuple type has the form
#   record ('a, ..., 'x) <Pn> =
#     p1\<^sub>f :: "'a"
#      ...
#     pn\<^sub>f :: "'x"
#
# where <Pn> is the record name and n > 1. The definition is terminated by an empty line.
# For every n there is atmost one such type definition in the theory.
# For every tuple type the following additional abbreviations are generated:
#   type_synonym ('a, ..., 'x) Tup<n> = "('a, ..., 'x) <Pn>"
#   abbreviation "makeTup<n> ≡ <Pn>.make"
#   abbreviation "p1Tup<n> ≡ <Pn>.p1⇩f"
#   abbreviation "p1Tup<n>_update ≡ <Pn>.p1⇩f_update"
#     ...
#   abbreviation "pnTup<n> ≡ <Pn>.pn⇩f"
#   abbreviation "pnTup<n>_update ≡ <Pn>.pn⇩f_update"
#
# Implementation in awk:
# - Since in '...' the ' cannot be escaped, we avoid using it in match expressions and print it 
#   by reusing parts of the input.
# - Information about detected tuple types are stored in arrays indexed from 1 to num_tt.
#   Array tt_args stores the type argument list ('a, ..., 'x), array tt_name stores the record name <Pn>,
#   array tt_size stores n.
# - Every record definition is parsed as potential tuple type. In the first line, tt_args and tt_name is stored
#   and tt_parse is set to 1. For every subsequent line starting with pi\<^sub>f :: "' where i = tt_parse
#   tt_parse is incremented. For an empty line, if tt_parse is not 0, tt_size is set to tt_parse-1, tt_parse
#   is set to 0, and num_tt is incremented. For every other line tt_parse is set to 0.
