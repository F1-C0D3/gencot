The Cogent code generated for C expressions and statements in the first translation phase as described in 
Section~\ref{impl-ccode-cstats} is in general neither correct nor efficient. Therefore it must be improved, 
which is done by postprocessing. The postprocessing is done directly in the Cogent AST. 

This approach taken by Gencot has several advantages over generating the Cogent code in a single phase.
First, the actual translation step ist rather simple and straightforward and even needs not take the C types
into account. Second, the postprocessing is done on a restricted subset of a purely functional language where 
there is no difference between statements and expressions, so it tends to be simpler. Third, it can be separated
into arbitrary many different processing steps which can be freely combined, since they all process the same
data structures (the Cogent AST). The drawback is that the code generation is not very efficient, because it
first builds a quite voluminous code which is then simplified by the postprocessing. However, the quality 
of the resulting code has been considered more important than the performance of the Gencot translation.

In the following sections the postprocessing steps are described independently of each other and the last
section describes how they are combined. Every postprocessing step corresponds to a transformation from
a Cogent expression to a Cogent expression and is implemented by a Haskell function of the form
\begin{verbatim}
  procX :: GenExpr -> GenExpr
\end{verbatim}
Note that no monadic actions are used, all information required for the processing must already be present in the 
expressions.

Postprocessing is applied to all expressions which occur in the generated Cogent program. These are function 
body expressions, the expressions in constant definitions, and the expressions in array type size specifications.

\subsection{Simplifying \code{let}-Expressions}
\label{imp-post-let}

One of the simplest and most straightforward postprocessing steps is substitution of bound variables by the
expression bound to them. In Cogent variables can be bound by \code{let} expressions and by \code{match} and \code{lambda}
expressions. Variables bound in \code{match} and \code{lambda} expressions can usually only be substituted in special cases, 
therefore this processing step only substitutes variables bound in \code{let} expressions. 

The basic transformation is for an expression
\begin{verbatim}
  let v = expr1 in expr2
\end{verbatim}
to replace it by \code{expr2} where every free occurrence of \code{v} is substituted by \code{expr1}. This is only 
possible if after the substitution all free variables in \code{expr1} are still free in the resulting expression, i.e., 
they are not ``drawn under a binding'' in \code{expr2}. This could be avoided by consistent renaming of variables bound in 
\code{expr2}. Gencot never renames variables and does not substitute in this case.

This scheme can directly be extended to expressions of the form \code{let v1 = e1 and ... vn = en in e} using the
equivalence to an expression of the form \code{let v1 = e1 in let ... in let vn = en in e}.

In a Cogent \code{let} expression instead of a variable \code{v} an (irrefutable) pattern \code{p} can be used:
\begin{verbatim}
  let p = expr1 in expr2
\end{verbatim}
An irrefutable pattern
is a variable or wildcard or it is a pattern for a tuple, record, array or the unit value were the components are again
irrefutable patterns. In other words, it is a complex structure of variables which is bound to an expression \code{expr1}
of a type for which the values have a corresponding structure. Every variable may occur only once in a pattern.

If the pattern occurs as a whole in \code{expr2} it can be
substituted by \code{expr1} as described above. If only parts of the pattern occur (such as a single variable) it depends
on the structure of \code{expr2} whether such a part can be substituted. The substitution is only done if all parts of the 
pattern in \code{expr2} can be substituted, otherwise the binding is retained and \code{expr2} is not changed.

If the substitution is successful the \code{let} expression is replaced by \code{expr2} which may again be a \code{let}
expression or any other kind of expression. Therefore the simplification may reduce the number of \code{let} expressions
and may replace a \code{let} expression by an expression of another kind.

Substitution of bound variables may lead to exponentially larger code, which must be avoided. Gencot uses an expression metrics
which roughly measures the size of the printed expression in the Cogent surface syntax. A binding is only substituted if the 
resulting expression is not much larger than the original expression.

Simplifying a \code{let} expression by substitution can reduce the variables which occur free in it. This is the case if no
parts of the pattern \code{p} occur free in \code{expr2}, then \code{expr1} is removed and all variables which only occur free
in \code{expr1} are removed with it.

\subsubsection{Processing Subexpressions}

When an expression \code{let p = expr1 in expr2} is simplified, first the subexpressions \code{expr1} and \code{expr2} are
simplified by processing all contained \code{let} expressions. Simplifying \code{expr1} has the following advantages for the 
substitution:
\begin{itemize}
\item The resulting expression usually is smaller. Then its substitution into \code{expr2} leads to a lower increase of
size and may be allowed whereas substitution of the original \code{expr1} would not be accepted.
\item Simplifying may reduce the free variables so that it may be possible to substitute it in more places than
the original expression without drawing free variables under a binding.
\item If \code{expr1} is again a \code{let} expression the pattern can only be substituted as a whole. After simplification 
it may have a form which corresponds more with the pattern so that also parts of the pattern can be substituted.
\end{itemize}
Simplifying \code{expr2} has the following advantages for the substitution:
\begin{itemize}
\item Simplifying may reduce the free variables so that there are fewer places for substituting the pattern
or parts of it. This may allow substitutions of patterns which where not possible in the original \code{expr2}.
It may also allow substitutions which would have lead to a too large growth of the original \code{expr2}.
\end{itemize}

Since an expression \code{let p1 = expr1 and p2 = expr2 in expr3} is equivalent to \code{let p1 = expr1 in (let p2 = expr2
in expr3)} this means that a sequence of bindings connected by \code{and} in a \code{let} expression is processed
from its end backwards.

\subsubsection{Pattern Substitution}

If (after its simplification) \code{expr1} has the same structure as the pattern \code{p} the binding could be split and 
the parts could be substituted independently. This would correspond to the transformation of the binding \code{p = expr1}
to the sequence 
\begin{verbatim}
  p1 = expr11 and ... pn = expr1n
\end{verbatim}
where the \code{pi} are the subpatterns of \code{p} and the \code{expr1i} are the corresponding subexpressions of \code{expr1}.
Note that the variables in the \code{pi} are pairwise disjunct since every variable may occur only once in \code{p}.
Then the sequence could be processed from its end, as described above.

However, the transformation is only correct, if no variable in \code{pi} occurs free in an expression \code{expr1j} with 
\code{j > i}, otherwise the transformation would draw it under the binding \code{pi = expr1i}. It could be tried to sort
the bindings to minimize this problem but in general it cannot be avoided. Additionally, there may be cases where \code{expr1}
even after its simplification has no structure corresponding with that of \code{p}, which also prevents the transformation.

For this reason, instead of transforming the binding and substituting it sequentially, Gencot tries to substitute the split 
binding all at once, by matching all subpatterns \code {pi} in parallel as follows. 
The expression \code{expr2} is depth-first traversed by matching every subexpression with all \code{pi}.
A subexpression matches \code{pi} if it has the same structure with the same variables. Since the variables in the \code{pi}
are pairwise disjunct a subexpression matches atmost one of the \code{pi}. If it matches a \code{pi} it can be 
replaced by \code{expr1i} and all ancestor expressions need not be matched, since they cannot match any of the \code{pi}.
If it does not match any of the \code{pi} and no variable of \code{p} occurs free in it, it remains unchanged. 

If there is a subexpression which does not match any of the \code{pi} but a variable of \code{p} occurs free in it, then 
the simplest such subexpression is the variable itself. This means that the subpattern \code{pi} which contains the variable 
cannot be substituted and removed from the binding. Gencot retains all such subpatterns in the binding. This means that 
the other subpatterns can only be substituted if they do not draw free variables under this binding. Gencot iteratively 
determines these subpatterns and also retains them in the binding. Only the remaining subpatterns are actually substituted in 
\code{expr2}.

If a subpattern \code{pi} contains wildcards it cannot match a subexpression in \code{expr2}. If it does not contain any variables
or the variables do not occur free in \code{expr2} it can be removed from the binding, otherwise it must be retained.

If a subpattern \code{pi} contains a \code{take} pattern for a record or array it can only match a \code{put} subexpression 
of exactly the same in \code{expr2}. That is only present if the component is taken and put back without modifying it or the 
remaining record or array. In this case the \code{put} expression is replaced by \code{expr1i}. 
The \code{take} pattern can only be split if \code{expr1i} is a corresponding \code{put} expression. However, in a sequence
of bindings Gencot always generates all put operations after all take operations, so this case cannot occur and \code{take} 
patterns are never split.

It may be the case that a \code{pi} has the same structure and the same variables as a subexpression of \code{expr2}, but the
variables appear in another order. Since \code{expr1i} has not the same structure (otherwise \code{pi} would have been split
further), it is not possible to rearrange the variables in \code{pi} so that it matches the subexpression. It may be possible 
to rearrange the variables in the subexpression, but this may require to rearrange other parts of \code{expr2} and even in 
its context. Therefore variables are never rearranged, if they are not in the correct order the subpattern is not substituted.

Another reason for not substituting a subpattern code{pi} may be that a free variable of \code{expr1i} is drawn under a binding
in \code{expr2}. Such a binding may be in a \code{let} subexpression which has been retained by the simplification of \code{expr2}
or it may be a binding in a \code{match} or \code{lambda} expression which is not processed by the simplification.

The substitution and binding simplification is implemented in two phases. In the first phase the subpatterns are matched in 
\code{expr2} and for each of them the number of successful matches is determined and whether there are places where contained 
variables cannot be substituted. Then the subpatterns which do not occur at all are removed from the binding and for the rest
those which must be retained are determined. The other subpatterns are actually substituted in \code{expr2} in the second phase 
and the reduced binding is constructed. If it is empty the \code{let} expression is replaced by the modified \code{expr2}.

\subsubsection{Growth Restriction}

As size metrics for an expression the number of characters used in its surface representation is used. It could be determined
by actually prettyprinting the expression and measuring the size of the resulting string. However, it is assumed to be more
efficient to traverse the expression and calculate the size from the number of characters in the names and literals and in
the keywords, special characters and separating blanks needed for constructing composed expressions.

After the first phase the metrics of the \code{let} expression is calculated. Since for every subpattern to be substituted it 
has been determined in the first phase how often it occurs in \code{expr2} the metrics for the simplified expression can be 
calculated and it is known how much each subpattern contributes to its size. If the size is larger than for the original 
expression and its growth exceeds a fixed limit factor additional subpatterns are determined which are retained in the binding. 
Beginning with the subpattern with the largest contribution, subpatterns are retained until the growth is below the limit.

Instead of only taking its contribution to the size into account, subpatterns could also be selected according to the kind of
variables they contain. 
Gencot uses different kinds of variables in its generated code (see Section~\ref{impl-ccode-cstats}): value variables, component and 
index variables, the control and result variables, and variables corresponding to C object names. These could be prioritized
as follows: first as many value 
variables are substituted as possible in a complete expression, then the control variables, then the component and index variables and
finally the C object names. In this way the most ``technical'' variables are substituted before the more ``semantical''.

The reference metrics is calculated for the expression after simplifying its subexpressions. This means that the growth limit factor
applies to every subexpression simplification step separately. This has two implications. First, a subexpression simplification
may strongly reduce the size of the subexpression and that may also reduce the size of the \code{let} expression, which becomes 
the reference for its own simplification. Thus it is not possible to tolerate a larger growth after strongly reducing the size for
subexpressions. Alternatively, the reference size could be measured before simplifying the subexpressions. In the code generated
by Gencot there are typically large nestings of \code{let} expressions with unnecessary ``chain bindings''. It is assumed that it
does not yield good results when these unnecessary large expressions are used as reference, therefore Gencot uses the first approach.

Second, in the worst case each simplification step grows the expression by the limit factor which still results in an overall exponential growth
relative to the number of subexpressions. Therefore the growth limit factor should not be much larger than 1. The effect of this
factor and a good selection for it must be determined by practical tests. Alternatively the factor could be specified as an input 
parameter for Gencot so that it can be selected specifically for every translated C program.

\subsection{Simplifying If-Expressions}
\label{imp-post-if}

\subsection{Function Call Processing}
\label{imp-post-funcall}

\subsection{Take/Put Processing}
\label{imp-post-takeput}

\subsection{Combining the Steps}
\label{imp-post-combine}

