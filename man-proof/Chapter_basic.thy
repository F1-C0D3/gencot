theory Chapter_basic
  imports Chapter_intro
  "HOL-Library.Adhoc_Overloading"
  "HOL-Library.LaTeXsugar"
begin
chapter "Isabelle Basics"
text_raw\<open>\label{basic}\<close>

text \<open>
Isabelle is a ``proof assistant'' for formal mathematical proofs. It supports a notation for propositions and 
their proofs, it can check whether a proof is correct, and it can even help to find a proof.
\<close>

section "Invoking Isabelle"
text_raw\<open>\label{basic-invoke}\<close>

text \<open>
After installation, Isabelle can be invoked interactively as an editor for entering propositions and proofs,
or it can be invoked noninteractively to check a proof and generate a PDF document which displays the 
propositions and proofs.
\<close>

subsection "Installation and Configuration"
text_raw\<open>\label{basic-invoke-install}\<close>
text \<open>** todo **\<close>

subsection "Theories and Sessions"
text_raw\<open>\label{basic-invoke-theory}\<close>
text \<open>
The propositions and proofs in Isabelle notation are usually collected in ``theory files'' with names of the 
form \<^verbatim>\<open>name.thy\<close>. A theory file must import at least one other theory file to build upon its content. For theories
based on higher order logic (``HOL''), as it is the case for the Cogent shallow embedding, the usual starting point to
import is the theory @{theory Main}.

Several theory files can be grouped in a ``session''. A session is usually stored in a directory in the file system.
It consists of a file named \<^verbatim>\<open>ROOT\<close> which contains a specification of the session, and the theory files which
belong to the session.

When Isabelle loads a session it loads and checks all its theory files. Then it can generate a ``heap file'' for
the session which contains the processed session content. The heap file can be reloaded by Isabelle to avoid 
the time and effort for processing and checking the theory files.

A session always has a single parent session, with the exception of the Isabelle builtin session @{session Pure}.
Thus, every session depends on a linear sequence of ancestor sessions which begins at @{session Pure}. The ancestor 
sessions have separate heap files. A session is always loaded together with all ancestor sessions. 

Every session has a name of the form \<^verbatim>\<open>chap/sess\<close> where \<^verbatim>\<open>chap\<close> is an arbitrary ``chapter name'', it defaults to
\<^verbatim>\<open>Unsorted\<close>. The session name and the name of the parent session are specified in the \<^verbatim>\<open>ROOT\<close> file in the session
directory. When a session is loaded by Isabelle, its directory and the directories of all ancestor sessions must
be known by Isabelle.

Every session may be displayed in a ``session document''. This is a PDF document generated by translating the 
content of the session theory files to \LaTeX. A frame \LaTeX\ document must be provided which includes all content
generated from the theory files. The path of the frame document, whether a session document shall be generated and 
which theories shall be included is specified in the \<^verbatim>\<open>ROOT\<close> file.

The command
\begin{verbatim}
  isabelle mkroot [OPTIONS] [Directory]
\end{verbatim}
can be used to initialize the given directory (default is the current directory) as session directory. It creates
an initial \<^verbatim>\<open>ROOT\<close> file to be populated with theory file names and other specification for the session, and it
creates a simple frame \LaTeX\ document.
\<close>

subsection "Invocation as Editor"
text_raw\<open>\label{basic-invoke-edit}\<close>
text \<open>
Isabelle is invoked for editing using the command
\begin{verbatim}
  isabelle jedit [OPTIONS] [Files ...]
\end{verbatim}
It starts an interactive editor and opens the specified theory files. If no file is specified it opens the 
file \<^verbatim>\<open>Scratch.thy\<close> in the user's home directory. If that file does not exist, it is created as an empty file.

The editor also loads (but does not open) all transitively imported theory files. If these are Isabelle standard
theories it finds them automatically. If they belong to the session in the current directory it also finds them.
If they belong to other sessions, the option
\begin{verbatim}
  -d <directory pathname>
\end{verbatim}
must be used to make the session directory known to Isabelle. For every used session a separate option must be
specified. Also the directories of all ancestor sessions of the session the opened files belong to must be
specified using this option if they are not yet known to Isabelle. 

The option
\begin{verbatim}
  -l <session name>
\end{verbatim}
can be used to specify a session to load (together with all ancestor sessions) to use imported theories from it.
If a heap file exists for that session it is used, otherwise a heap file is created by loading all the session's 
theories.
\<close>

subsection "Invocation for Batch Processing"
text_raw\<open>\label{basic-invoke-build}\<close>
text \<open>
Isabelle is invoked for batch processing of all theory files in one or more sessions using the command
\begin{verbatim}
  isabelle build [OPTIONS] [Sessions ...]
\end{verbatim}
It loads all theory files of the specified sessions and checks the contained proofs. It also loads all required
ancestor sessions. If not know to Isabelle, the corresponding session directories must be specified using option
\<^verbatim>\<open>-d\<close> as described in Section~\ref{basic-invoke-edit}. Sessions required for other sessions are loaded from
heap files if existent, otherwise the corresponding theories are loaded and a heap file is created. 

If option \<^verbatim>\<open>-b\<close> is specified, heap files are also created for all sessions specified in the command. Option
\<^verbatim>\<open>-c\<close> clears the specified sessions (removes their heap files) before processing them. Option \<^verbatim>\<open>-n\<close> omits 
the actual session processing, together with option \<^verbatim>\<open>-c\<close> it can be used to simply clear the heap files.

The specified sessions are only processed if at least one of their theory files has changed since the last 
processing or if the session is cleared using option \<^verbatim>\<open>-c\<close>. If option \<^verbatim>\<open>-v\<close> is specified all loaded sessions
and all processed theories are listed on standard output.

If specified for a session in its \<^verbatim>\<open>ROOT\<close> file (see Section~\ref{basic-invoke-doc}), also the session document 
is generated when a session is processed.
\<close>

subsection "Invocation for Document Creation"
text_raw\<open>\label{basic-invoke-doc}\<close>
text \<open>** todo **\<close>

section "Isabelle Theories"
text_raw\<open>\label{basic-theory}\<close>

text \<open>
Remark: This document uses a pretty printed syntax for Isabelle theories. A major difference
to the actual source syntax is that underscores in names are displayed as hyphens (minus signs).
So for example the keyword displayed as \<^theory_text>\<open>type_synonym\<close> must be written \<^verbatim>\<open>type_synonym\<close> in the
theory source text.
\<close>

subsection "Theory Structure"
text_raw\<open>\label{basic-theory-structure}\<close>

text \<open>
The content of a theory file has the structure
@{theory_text[display]
\<open>theory name
imports name\<^sub>1 \<cdots> name\<^sub>n
begin
  \<cdots>
end\<close>}
where \<^theory_text>\<open>name\<close> is the theory name and \<^theory_text>\<open>name\<^sub>1 \<cdots> name\<^sub>n\<close> are the names of the imported theories.
The theory name \<^theory_text>\<open>name\<close> must be the same which is used for the theory file, i.e., the file name 
must be \<^verbatim>\<open>name.thy\<close>.

The theory structure is a part of the Isabelle ``outer syntax'' which is mainly fixed and independent
from the specific theories. Other kind of syntax is embedded into the outer syntax. The main embedded
syntax ist the ``inner syntax'' which is mainly used to denote types and terms. Content in inner
syntax must always be surrounded by double quotes. Note that in the pretty printed forms in this document
these quotes are omitted.

Additionally, text written in \LaTeX\ syntax can be embedded into the outer syntax using the form
\<^theory_text>\<open>text\<open> \<cdots> \<close>\<close>
and \LaTeX\ sections can be created using
\<^theory_text>\<open>chapter\<open> \<cdots> \<close>\<close>, \<^theory_text>\<open>section\<open> \<cdots> \<close>\<close>, \<^theory_text>\<open>subsection\<open> \<cdots> \<close>\<close>, \<^theory_text>\<open>subsubsection\<open> \<cdots> \<close>\<close>, \<^theory_text>\<open>paragraph\<open> \<cdots> \<close>\<close>,
\<^theory_text>\<open>subparagraph\<open> \<cdots> \<close>\<close>.
Note that the delimiters used here are not the ``lower'' and ``greater'' symbols, but the ``cartouche
delimiters'' available in the jedit Symbols subwindow in tab ``Punctuation''.

It is also possible to embed inner and outer syntax in the \LaTeX\ syntax (see the Isabelle reference 
manuals).
\<close>

subsection "Types, Constants, and Functions"
text_raw\<open>\label{basic-theory-typcnst}\<close>

text \<open>
As usual in formal logics, the basic building blocks for propositions are terms. Terms denote arbitrary
objects like numbers, sets, functions, or boolean values. Isabelle is strongly typed, so every term 
must have a type. However, in most situations Isabelle can derive the type of a term automatically,
so that it needs not be specified explicitly. Terms and types are always denoted using the inner syntax.

Types are usually specified by type names. There are predefined type names such as \<open>nat\<close> and \<open>bool\<close>.
Types can be parameterized, then the type arguments are denoted \<^emph>\<open>before\<close> the type name, such as in
\<open>nat set\<close> which is the type of sets of natural numbers.

New type names can be declared in the form
@{theory_text[display]
\<open>typedecl name\<close>}
which introduces the \<^theory_text>\<open>name\<close> for a new type for which the values are different from the values of all existing 
types (and no other information about the values is given). 
Alternatively a type name can be introduced as a synonym for an existing type in the form
@{theory_text[display]
\<open>type_synonym name = type\<close>}
such as in \<^theory_text>\<open>type_synonym natset = nat set\<close>.

Terms are mainly built as syntactical structures based on constants and variables. Constants are usually
denoted by names, using the same namespace as type names. Whether a name denotes a constant or a 
type depends on its position in a term. 

A constant name can be introduced by declaring it together with its type. The declaration
@{theory_text[display]
\<open>consts name\<^sub>1 :: type\<^sub>1 \<cdots> name\<^sub>n :: type\<^sub>n\<close>}
declares \<open>n\<close> constant names with their types. Constant names declared in this way are 
``atomic'', no other information is given about them.

A constant name denotes an object, which, according to its type, may also be a function of 
arbitrary order. Functions always
have a single argument. The type of a function is written as \<open>argtype \<Rightarrow> restype\<close>. The result type
of a function may again be a function type, then it may be applied to another argument. This is used
to represent functions with more than one arguments. Function types are right associative, thus a 
type \<open>argtype\<^sub>1 \<Rightarrow> argtype\<^sub>2 \<Rightarrow> \<cdots> \<Rightarrow> argtype\<^sub>n \<Rightarrow> restype\<close> represents a function which can be applied 
to \<open>n\<close> arguments. Function application terms for a function \<open>f\<close> and an argument \<open>a\<close> are denoted by 
\<open>f a\<close>, no parentheses are required around the argument. Function application terms are left 
associative, thus a function application to \<open>n\<close> arguments is written \<open>f a\<^sub>1 \<cdots> a\<^sub>n\<close>. Note that an
application \<open>f a\<^sub>1 \<cdots> a\<^sub>m\<close> where \<open>m < n\<close> (a ``partial application'') is a correct term and denotes a
function taking \<open>n-m\<close> arguments.

Functions can be denoted by lambda terms of the form \<open>\<lambda>x.term\<close> where \<open>x\<close> is a ``variable name''
which can occur in the \<open>term\<close>. A function to be applied to \<open>n\<close> arguments can be denoted by the
lambda term \<open>\<lambda>x\<^sub>1 \<cdots> x\<^sub>n.term\<close> where \<open>x\<^sub>1 \<cdots> x\<^sub>n\<close> are distinct variable names.
\<close>

subsection "Definitions"
text_raw\<open>\label{basic-theory-definition}\<close>

text \<open>
Constant names can also be introduced as ``synonyms'' for terms. There are two forms for introducing
constant names in this way, definitions and abbreviations.

A definition introduces the name as a new entity in the logic, in the same way as a declaration.
A definition is denoted in the form
@{theory_text[display]
\<open>definition name :: type
where "name \<equiv> term"\<close>}
Note that the ``definitional equation'' \<open>name \<equiv> term\<close> is specified in inner syntax and must be
delimited by quotes in the source text.

If the type of the defined name is a function type, the \<open>term\<close> may be a lambda term. Alternatively,
the definition for a function applicable to \<open>n\<close> arguments can be written in the form
@{theory_text[display]
\<open>definition name :: type
where "name x\<^sub>1 \<cdots> x\<^sub>n \<equiv> term"\<close>}
with variable names \<open>x\<^sub>1 \<cdots> x\<^sub>n\<close> which may occur in the \<open>term\<close>. This form is mainly equivalent to
@{theory_text[display]
\<open>definition name :: type
where "name \<equiv> \<lambda>x\<^sub>1 \<cdots> x\<^sub>n.term"\<close>}

An abbreviation introduces the name only as a syntactical item which is not known by the internal
logics system, upon input it is automatically expanded, and upon output it is used whenever a term
matches its specification. An abbreviation is denoted in a similar form as a definition:
@{theory_text[display]
\<open>abbreviation name :: type
where "name \<equiv> term"\<close>}
The alternative form for functions is also available.
\<close>

subsection "Overloading"
text_raw\<open>\label{basic-theory-overload}\<close>

text \<open>
A declared constant name can be associated with a definition afterwards by overloading. Overloading
depends on the type. Therefore, if a constant name has a parameterized type, different definitions
can be associated for different type instantiations.

A declared constant name \<open>name\<close> is associated with \<open>n\<close> definitions by the following overloading
specification:
@{theory_text[display]
\<open>overloading
  name\<^sub>1 \<equiv> name
    \<cdots>
  name\<^sub>n \<equiv> name
begin
  definition name\<^sub>1 :: type\<^sub>1 where \<cdots>
    \<cdots>
  definition name\<^sub>n :: type\<^sub>n where \<cdots>
end\<close>}
where all \<open>type\<^sub>i\<close> must be instantiations of the type declared for \<open>name\<close>.

There is also a form of overloading which is only performed on the syntactic level, like abbreviations.
To use it, the theory \<^theory>\<open>HOL-Library.Adhoc_Overloading\<close> must be imported by the surrounding
theory:
@{theory_text[display]
\<open>imports "HOL-Library.Adhoc_Overloading"\<close>}
Then constant \<open>name\<close> can be associated with \<open>n\<close> terms of different type instantiations by
@{theory_text[display]
\<open>adhoc_overloading name term\<^sub>1 \<cdots> term\<^sub>n\<close>}
Several names can be overloaded in a common specification:
@{theory_text[display]
\<open>adhoc_overloading name\<^sub>1 \<cdots> and \<cdots> and name\<^sub>k \<cdots>\<close>}
\<close>

subsection "Statements"
text_raw\<open>\label{basic-theory-statement}\<close>

text \<open>
A statement specifies a proposition together with a proof, that the proposition is true. A simple
form of a statement is
@{theory_text[display]
\<open>theorem "prop" "proof"\<close>}
where \<open>prop\<close> is a proposition in inner syntax and \<open>proof\<close> is a proof as described in 
Section \ref{basic-proof}. The keyword \<^theory_text>\<open>theorem\<close> can be replaced by one of the keywords
\<^theory_text>\<open>lemma\<close>, \<^theory_text>\<open>corollary\<close>, \<^theory_text>\<open>proposition\<close> to give a hint about the use of the statement to
the reader.

Statements are often used in proofs of other statements. For this purpose they can be named so 
that they can be referenced by name. A named statement is specified in the form
@{theory_text[display]
\<open>theorem name: "prop" "proof"\<close>}

It is also possible to introduce named collections of statements. A simple way to introduce
such a named collection is 
@{theory_text[display]
\<open>lemmas name = name\<^sub>1 \<cdots> name\<^sub>n\<close>}
where \<open>name\<^sub>1 \<cdots> name\<^sub>n\<close> are names of existing statements or statement collections.

Alternatively a ``dynamic fact'' can be declared by
@{theory_text[display]
\<open>named_theorems name\<close>}
It can be used as a ``bucket'' where statements can be added afterwards by specifying the bucket
name in the statement:
@{theory_text[display]
\<open>theorem [name]: "prop" "proof"\<close>}
or with also specifying a statement name \<^theory_text>\<open>name\<^sub>s\<close> by
@{theory_text[display]
\<open>theorem name\<^sub>s[name]: "prop" "proof"\<close>}
\<close>

subsection "Propositions"
text_raw\<open>\label{basic-theory-prop}\<close>

text \<open>
A proposition is specified by a statement or may occur in other contexts. In its simplest
form it is a single term of type \<open>bool\<close>, written in inner syntax, such as
@{text[display]
\<open>6 * 7 = 42\<close>}

More complex propositions can express, e.g., ``derivation rules'' used to derive propositions
from other propositions. Complex propositions are denoted using a ``meta logic language''. It is
still written in inner syntax but uses a small set of metalogic operators common to all possible
object logics in Isabelle. 

Derivation rules consist of assumptions and a conclusion. They can be written using the metalogic
operator \<open>\<Longrightarrow>\<close> in the form
@{text[display]
\<open>A\<^sub>1 \<Longrightarrow> \<cdots> \<Longrightarrow> A\<^sub>n \<Longrightarrow> C\<close>}
where the \<open>A\<^sub>1 \<cdots> A\<^sub>n\<close> are the assumptions and \<open>C\<close> is the conclusion, all of them are propositions.
A derivation rule states that if the assumptions are known to be true, the conclusion can be derived
to be true as well. So it can be viewed as a ``meta implication'' with a similar meaning as a boolean
implication, but a different use.

An alternative, Isabelle specific syntax for derivation rules is
@{text[display]
\<open>\<lbrakk>A\<^sub>1; \<cdots>; A\<^sub>n\<rbrakk> \<Longrightarrow> C\<close>}
which is often considered as more readable, because it better separates the assumptions from the
conclusion. In the Jedit editor it may be necessary to switch to this form by setting \<^verbatim>\<open>Print Mode\<close> 
to \<^verbatim>\<open>brackets\<close> in \<^verbatim>\<open>Plugin Options\<close> for \<^verbatim>\<open>Isabelle General\<close>.

Note that in the literature a derivation rule @{thm conjI[no_vars]} is often denoted in the form
@{thm[display,mode=Rule] conjI[no_vars]}

A proposition may contain universally bound variables, using the metalogic quantifier \<open>\<And>\<close> in the
form
@{text[display]
\<open>\<And> x\<^sub>1 \<cdots> x\<^sub>n. P\<close>}
where the \<open>x\<^sub>1 \<cdots> x\<^sub>n\<close> may occur free in the proposition \<open>P\<close>. If a proposition contains free variables
they are implicitly bound in this way.
\<close>

subsection "Locales"
text_raw\<open>\label{basic-theory-locale}\<close>

text \<open>
There are cases where theory content such as definitions and statements occur which has similar 
structure but differs in some types or terms. Then it is useful to define a ``template'' and 
instantiate it several times. This can be done in Isabelle using a ``locale''.

A locale can be seen as a parameterized theory fragment, where the parameters are terms. A locale
with \<open>n\<close> parameters is defined by
@{theory_text[display]
\<open>locale name = 
  fixes name\<^sub>1 :: type\<^sub>1 and \<cdots> and name\<^sub>n :: type\<^sub>n
begin
  \<cdots>
end\<close>}
where for each parameter its name and its type is specified. The content between \<^theory_text>\<open>begin\<close> and \<^theory_text>\<open>end\<close>
may consist of definitions and statements which may use the parameter names like constant names. 
Content may also be added to an existing locale in the form 
@{theory_text[display]
\<open>context name
begin
  \<cdots>
end\<close>}
Therefore the \<^theory_text>\<open>begin \<cdots> end\<close> block can also be omitted in the locale definition and the locale can be
filled later.

An instance of the parameterized theory fragment is created by ``interpreting'' the locale in the form
@{theory_text[display]
\<open>interpretation name term\<^sub>1 \<cdots> term\<^sub>n .\<close>}
where \<open>term\<^sub>1 \<cdots> term\<^sub>n\<close> are the terms to be substituted for the locale parameters, their types must
match the parameter types, i.e., must be instantiations of them. The final dot in the interpretation
is a rudimentary proof. An actual proof is needed, if the locale definition specifies additional
properties for the parameters.

Additional properties for locale parameters can be specified in the form
@{theory_text[display]
\<open>locale name = 
  fixes name\<^sub>1 :: type\<^sub>1 and \<cdots> and name\<^sub>n :: type\<^sub>n
  assumes namp\<^sub>1: prop\<^sub>1 and \<cdots> and namp\<^sub>m: prop\<^sub>m
begin
  \<cdots>
end\<close>}
where \<open>namp\<^sub>1 \<cdots> namp\<^sub>m\<close> are names declared for the properties \<open>prop\<^sub>1 \<cdots> prop\<^sub>m\<close>. They can be used to
reference the properties in proofs in the locale content. If the locale is interpreted, all the
properties must be proved with the actual terms substituted for the parameters. Therefore the more
general form of an interpretation is
@{theory_text[display]
\<open>interpretation name term\<^sub>1 \<cdots> term\<^sub>n "proof"\<close>}

A locale can extend one or more other locales using the form
@{theory_text[display]
\<open>locale name = name\<^sub>1 + \<cdots> + name\<^sub>n +
  fixes \<cdots>
  assumes \<cdots>
begin
  \<cdots>
end\<close>}
where \<^theory_text>\<open>name\<^sub>1 \<cdots> name\<^sub>n\<close> are the names of the extended locales. Their parameters become parameters
of the defined locale, inserted before the parameters declared by the \<^theory_text>\<open>fixes \<cdots>\<close> clause.
\<close>

section "Isabelle Proofs"
text_raw\<open>\label{basic-proof}\<close>

text \<open>
Whenever a proposition occurs somewhere in an Isabelle theory it usually must be proved
immediately by specifying a proof for it. A proof may consist of several steps, its
structure is part of the outer syntax.
\<close>
 
subsection "Goals"
text_raw\<open>\label{basic-proof-goal}\<close>

text \<open>
The proof steps incrementally prove parts of the proposition. The remaining parts which are still
to be proved are called ``subgoals'' of the proof. Goals have the same form as propositions. 
When a proof for a proposition starts, this proposition is the only subgoal. If there are no more
subgoals, the proof is finished.

The set of subgoals is called the ``goal state'' of the proof. In the Jedit editor the proof state
is displayed in a separate window, according to the cursor position in the proof text.
\<close>

subsection "Proof Scripts"
text_raw\<open>\label{basic-proof-script}\<close>

text \<open>
One form of an Isabelle proof is a ``proof script''. It consists of a linear sequence of steps,
each step applies a ``proof method'' to one or more goals in the goal state. Depending on the 
goal state, a proof method may be applicable or not. If it is not applicable the step is marked as 
an error and is omitted from the proof script. If it is applicable it may modify goals, solve
goals (and remove them from the goal state), or create new goals.

A step has the form
@{theory_text[display]
\<open>apply method\<close>}
where \<open>method\<close> is an expression denoting the proof method applied by the step. A proof method can
be elementary or complex. An elementary proof method is denoted by a method name, optionally
followed by arguments. A complex method has one of the following forms:
 \<^item> \<open>m\<^sub>1, \<dots>, m\<^sub>n\<close> : a sequence of methods which are applied in their order,
 \<^item> \<open>m\<^sub>1; \<dots>; m\<^sub>n\<close> : a sequence of methods where each is applied to the goals created by the previous method,
 \<^item> \<open>m\<^sub>1| \<dots>| m\<^sub>n\<close> : a sequence of methods where only the first applicable method is applied,
 \<^item> \<open>m[n]\<close> : the method \<open>m\<close> is applied to the first \<open>n\<close> goals,
 \<^item> \<open>m?\<close> : the method \<open>m\<close> is applied if it is applicable,
 \<^item> \<open>m+\<close> : the method \<open>m\<close> is applied once and then repeated as long as it is applicable.

Parentheses are used to structure and nest complex methods.

The last step of a proof script must result in an empty goal state. After it the
proof script is terminated by a step of the form
@{theory_text[display]
\<open>done\<close>}
Alternatively a proof script may be terminated in an arbitrary goal state (even at the beginning)
by a step of the form
@{theory_text[display]
\<open>sorry\<close>}
This can be used to include statements which are not yet proved in a theory. However, such 
statements cannot be referenced and used in subsequent proofs.

The last step \<^theory_text>\<open>apply method\<close> together with the terminating \<^theory_text>\<open>done\<close> can be combined to
@{theory_text[display]
\<open>by method\<close>}
where this form additionally solves remaining goals which unify with assumptions and applies
a simple form of backtracking if the \<open>method\<close> can be applied in different ways to the goal state.
\<close>

subsection "Backward Reasoning"
text_raw\<open>\label{basic-proof-backward}\<close>

text \<open>
\<^item> Reasoning step
\<^item> conclusion unification
\<^item> rule with one assumption
\<^item> rule with several assumptions
\<^item> rule method
\<^item> rule\_tac method
\<^item> introduction rules
\<^item> intro method
\<close>

subsection "Forward Reasoning"
text_raw\<open>\label{basic-proof-forward}\<close>

text \<open>
\<^item> assumption unification
\<^item> assumption selection
\<^item> rotate method
\<^item> drule method
\<^item> drule\_tac method
\<^item> destruction rules
\<^item> erule method
\<^item> erule\_tac method
\<^item> elimination rules
\<close>

section "Isabelle HOL"
text_raw\<open>\label{basic-hol}\<close>

subsection "Meta Level Operators"
text_raw\<open>\label{basic-hol-meta}\<close>

text \<open>
\<^item> rewrite rules
\<^item> \<open>\<equiv>\<close>
\<^item> \<open>\<Longrightarrow>\<close>
\<close>

subsection "Logical Operators"
text_raw\<open>\label{basic-hol-logop}\<close>

text \<open>
\<^item> \<open>\<and>, \<or>, \<not>, \<longrightarrow>\<close>
\<^item> \<open>=, \<noteq>, \<longleftrightarrow>\<close>
\<^item> \<open>\<forall>, \<exists>\<close>
\<close>

subsection "Logic Rules"
text_raw\<open>\label{basic-hol-logrul}\<close>

text \<open>
\<^item> conjI, conjE, disjI1, disjI2, disjE, impI, mp
\<^item> contrapos\_*
\<^item> iffI, iffE, iffD1, iffD2
\<^item> allI, allE, exI, exE
\<close>

subsection "Equational Reasoning"
text_raw\<open>\label{basic-hol-equational}\<close>

text \<open>
\<^item> Equations, conditional equations
\<^item> Substitution
\<^item> subst method
\<^item> symmetric attribut
\<close>

subsection "The Simplifier"
text_raw\<open>\label{basic-hol-simp}\<close>

text \<open>
\<^item> simpset, simp attribute
\<^item> simp method
\<^item> add:, only:, del:
\<^item> simp\_all method
\<^item> recursive simplification for conditions
\<^item> simp trace
\<^item> debugging with subst
\<close>

end
